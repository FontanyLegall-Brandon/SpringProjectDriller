{"author_date": "2018-07-10 09:45:15+01:00", "msg": "Avoid overriding beans and ensure import order is used for DataSource\n\nDuring processing of a configuration class, the class's complete\nhierarchy is processed and during the processing of each class its\nmember classes are processed. Previously, each pool-specific\ninner-class of DataSourceConfiguration extended the abstract outer\nclass. This meant that when the import from\nDataSourceAutoConfiguration.PooledDataSourceConfiguration caused the\nfirst pool-specific inner-class to be  processed,\nDataSourceConfiguration would be processed as it was the inner-class's\nsuperclass. In turn all of DataSourceConfiguration's member classes\nwould then be processed. This caused the first import (of\nDataSourceConfiguration.Tomcat) to trigger processing of all of the\nother pool-specific inner-classes in whatever order they were found\nrather than them being processed in the order in which they are\nimported by DataSourceAutoConfiguration.PooledDataSourceConfiguration.\n\nAnother part of the problem was that none of the pool-specific\ninner-classes were conditional on a missing DataSource bean. This\nmeant that, when multiple pools were on the classpath, each class\nafter the first would override the previous class's definition of the\nDataSource bean.\n\nThis commit updates each of the pool-specific inner-classes so that\nthey no longer extend DataSourceConfiguration. This ensures that\nthe inner classes are processed in the order defined in the import\non PooledDataSourceConfiguration. Each of the classes has also been\nannotated with @ConditionalOnMissingBean(DataSource.class). This\nprevents the DataSource bean definition from being overridden and\nensures that the order of precedence for the pool that will be used\nis as defined in the import.\n\nCloses gh-13737"}