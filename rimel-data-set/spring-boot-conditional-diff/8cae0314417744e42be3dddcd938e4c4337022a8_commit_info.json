{'_old_path': PosixPath('spring-boot-devtools/src/main/java/org/springframework/boot/devtools/remote/client/RemoteClientConfiguration.java'), '_new_path': PosixPath('spring-boot-devtools/src/main/java/org/springframework/boot/devtools/remote/client/RemoteClientConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2016 the original author or authors.\n+ * Copyright 2012-2017 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the "License");\n  * you may not use this file except in compliance with the License.\n@@ -25,14 +25,12 @@ import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n import javax.annotation.PostConstruct;\n-import javax.servlet.Filter;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Value;\n-import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.context.properties.EnableConfigurationProperties;\n@@ -52,11 +50,7 @@ import org.springframework.boot.devtools.livereload.LiveReloadServer;\n import org.springframework.boot.devtools.restart.DefaultRestartInitializer;\n import org.springframework.boot.devtools.restart.RestartScope;\n import org.springframework.boot.devtools.restart.Restarter;\n-import org.springframework.boot.devtools.tunnel.client.HttpTunnelConnection;\n-import org.springframework.boot.devtools.tunnel.client.TunnelClient;\n-import org.springframework.boot.devtools.tunnel.client.TunnelConnection;\n import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.event.EventListener;\n import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\n@@ -120,9 +114,8 @@ public class RemoteClientConfiguration {\n \t@PostConstruct\n \tprivate void logWarnings() {\n \t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n-\t\tif (!remoteProperties.getDebug().isEnabled()\n-\t\t\t\t&& !remoteProperties.getRestart().isEnabled()) {\n-\t\t\tlogger.warn("Remote restart and debug are both disabled.");\n+\t\tif (!remoteProperties.getRestart().isEnabled()) {\n+\t\t\tlogger.warn("Remote restart is disabled.");\n \t\t}\n \t\tif (!this.remoteUrl.startsWith("https://")) {\n \t\t\tlogger.warn("The connection to " + this.remoteUrl\n@@ -239,32 +232,4 @@ public class RemoteClientConfiguration {\n \n \t}\n \n-\t/**\n-\t * Client configuration for remote debug HTTP tunneling.\n-\t */\n-\t@ConditionalOnProperty(prefix = "spring.devtools.remote.debug", name = "enabled", matchIfMissing = true)\n-\t@ConditionalOnClass(Filter.class)\n-\t@Conditional(LocalDebugPortAvailableCondition.class)\n-\tstatic class RemoteDebugTunnelClientConfiguration {\n-\n-\t\t@Autowired\n-\t\tprivate DevToolsProperties properties;\n-\n-\t\t@Value("${remoteUrl}")\n-\t\tprivate String remoteUrl;\n-\n-\t\t@Bean\n-\t\tpublic TunnelClient remoteDebugTunnelClient(\n-\t\t\t\tClientHttpRequestFactory requestFactory) {\n-\t\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n-\t\t\tString url = this.remoteUrl + remoteProperties.getContextPath() + "/debug";\n-\t\t\tTunnelConnection connection = new HttpTunnelConnection(url, requestFactory);\n-\t\t\tint localPort = remoteProperties.getDebug().getLocalPort();\n-\t\t\tTunnelClient client = new TunnelClient(localPort, connection);\n-\t\t\tclient.addListener(new LoggingTunnelClientListener());\n-\t\t\treturn client;\n-\t\t}\n-\n-\t}\n-\n }\n', 'source_code': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.devtools.remote.client;\n\nimport java.net.InetSocketAddress;\nimport java.net.Proxy.Type;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.annotation.PostConstruct;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties.Restart;\nimport org.springframework.boot.devtools.autoconfigure.OptionalLiveReloadServer;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties.Proxy;\nimport org.springframework.boot.devtools.autoconfigure.TriggerFileFilter;\nimport org.springframework.boot.devtools.classpath.ClassPathChangedEvent;\nimport org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher;\nimport org.springframework.boot.devtools.classpath.ClassPathRestartStrategy;\nimport org.springframework.boot.devtools.classpath.PatternClassPathRestartStrategy;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcher;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcherFactory;\nimport org.springframework.boot.devtools.livereload.LiveReloadServer;\nimport org.springframework.boot.devtools.restart.DefaultRestartInitializer;\nimport org.springframework.boot.devtools.restart.RestartScope;\nimport org.springframework.boot.devtools.restart.Restarter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.InterceptingClientHttpRequestFactory;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n\n/**\n * Configuration used to connect to remote Spring Boot applications.\n *\n * @author Phillip Webb\n * @since 1.3.0\n * @see org.springframework.boot.devtools.RemoteSpringApplication\n */\n@Configuration\n@EnableConfigurationProperties(DevToolsProperties.class)\npublic class RemoteClientConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n\n\tprivate final DevToolsProperties properties;\n\n\t@Value("${remoteUrl}")\n\tprivate String remoteUrl;\n\n\tpublic RemoteClientConfiguration(DevToolsProperties properties) {\n\t\tthis.properties = properties;\n\t}\n\n\t@Bean\n\tpublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n\t}\n\n\t@Bean\n\tpublic ClientHttpRequestFactory clientHttpRequestFactory() {\n\t\tList<ClientHttpRequestInterceptor> interceptors = Arrays\n\t\t\t\t.asList(getSecurityInterceptor());\n\t\tSimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n\t\tProxy proxy = this.properties.getRemote().getProxy();\n\t\tif (proxy.getHost() != null && proxy.getPort() != null) {\n\t\t\trequestFactory.setProxy(new java.net.Proxy(Type.HTTP,\n\t\t\t\t\tnew InetSocketAddress(proxy.getHost(), proxy.getPort())));\n\t\t}\n\t\treturn new InterceptingClientHttpRequestFactory(requestFactory, interceptors);\n\t}\n\n\tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n\t\tString secret = remoteProperties.getSecret();\n\t\tAssert.state(secret != null,\n\t\t\t\t"The environment value \'spring.devtools.remote.secret\' "\n\t\t\t\t\t\t+ "is required to secure your connection.");\n\t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n\t}\n\n\t@PostConstruct\n\tprivate void logWarnings() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tif (!remoteProperties.getRestart().isEnabled()) {\n\t\t\tlogger.warn("Remote restart is disabled.");\n\t\t}\n\t\tif (!this.remoteUrl.startsWith("https://")) {\n\t\t\tlogger.warn("The connection to " + this.remoteUrl\n\t\t\t\t\t+ " is insecure. You should use a URL starting with \'https://\'.");\n\t\t}\n\t}\n\n\t/**\n\t * LiveReload configuration.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.livereload", name = "enabled", matchIfMissing = true)\n\tstatic class LiveReloadConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Autowired(required = false)\n\t\tprivate LiveReloadServer liveReloadServer;\n\n\t\t@Autowired\n\t\tprivate ClientHttpRequestFactory clientHttpRequestFactory;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\n\t\t@Bean\n\t\t@RestartScope\n\t\t@ConditionalOnMissingBean\n\t\tpublic LiveReloadServer liveReloadServer() {\n\t\t\treturn new LiveReloadServer(this.properties.getLivereload().getPort(),\n\t\t\t\t\tRestarter.getInstance().getThreadFactory());\n\t\t}\n\n\t\t@EventListener\n\t\tpublic void onClassPathChanged(ClassPathChangedEvent event) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath();\n\t\t\tthis.executor.execute(new DelayedLiveReloadTrigger(optionalLiveReloadServer(),\n\t\t\t\t\tthis.clientHttpRequestFactory, url));\n\t\t}\n\n\t\t@Bean\n\t\tpublic OptionalLiveReloadServer optionalLiveReloadServer() {\n\t\t\treturn new OptionalLiveReloadServer(this.liveReloadServer);\n\t\t}\n\n\t\tfinal ExecutorService getExecutor() {\n\t\t\treturn this.executor;\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote update and restarts.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.remote.restart", name = "enabled", matchIfMissing = true)\n\tstatic class RemoteRestartClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic ClassPathFileSystemWatcher classPathFileSystemWatcher() {\n\t\t\tDefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();\n\t\t\tURL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());\n\t\t\tif (urls == null) {\n\t\t\t\turls = new URL[0];\n\t\t\t}\n\t\t\treturn new ClassPathFileSystemWatcher(getFileSystemWatcherFactory(),\n\t\t\t\t\tclassPathRestartStrategy(), urls);\n\t\t}\n\n\t\t@Bean\n\t\tpublic FileSystemWatcherFactory getFileSystemWatcherFactory() {\n\t\t\treturn new FileSystemWatcherFactory() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileSystemWatcher getFileSystemWatcher() {\n\t\t\t\t\treturn newFileSystemWatcher();\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tprivate FileSystemWatcher newFileSystemWatcher() {\n\t\t\tRestart restartProperties = this.properties.getRestart();\n\t\t\tFileSystemWatcher watcher = new FileSystemWatcher(true,\n\t\t\t\t\trestartProperties.getPollInterval(),\n\t\t\t\t\trestartProperties.getQuietPeriod());\n\t\t\tString triggerFile = restartProperties.getTriggerFile();\n\t\t\tif (StringUtils.hasLength(triggerFile)) {\n\t\t\t\twatcher.setTriggerFilter(new TriggerFileFilter(triggerFile));\n\t\t\t}\n\t\t\treturn watcher;\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathRestartStrategy classPathRestartStrategy() {\n\t\t\treturn new PatternClassPathRestartStrategy(\n\t\t\t\t\tthis.properties.getRestart().getAllExclude());\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathChangeUploader classPathChangeUploader(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath()\n\t\t\t\t\t+ "/restart";\n\t\t\treturn new ClassPathChangeUploader(url, requestFactory);\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.devtools.remote.client;\n\nimport java.net.InetSocketAddress;\nimport java.net.Proxy.Type;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties.Restart;\nimport org.springframework.boot.devtools.autoconfigure.OptionalLiveReloadServer;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties.Proxy;\nimport org.springframework.boot.devtools.autoconfigure.TriggerFileFilter;\nimport org.springframework.boot.devtools.classpath.ClassPathChangedEvent;\nimport org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher;\nimport org.springframework.boot.devtools.classpath.ClassPathRestartStrategy;\nimport org.springframework.boot.devtools.classpath.PatternClassPathRestartStrategy;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcher;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcherFactory;\nimport org.springframework.boot.devtools.livereload.LiveReloadServer;\nimport org.springframework.boot.devtools.restart.DefaultRestartInitializer;\nimport org.springframework.boot.devtools.restart.RestartScope;\nimport org.springframework.boot.devtools.restart.Restarter;\nimport org.springframework.boot.devtools.tunnel.client.HttpTunnelConnection;\nimport org.springframework.boot.devtools.tunnel.client.TunnelClient;\nimport org.springframework.boot.devtools.tunnel.client.TunnelConnection;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.InterceptingClientHttpRequestFactory;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n\n/**\n * Configuration used to connect to remote Spring Boot applications.\n *\n * @author Phillip Webb\n * @since 1.3.0\n * @see org.springframework.boot.devtools.RemoteSpringApplication\n */\n@Configuration\n@EnableConfigurationProperties(DevToolsProperties.class)\npublic class RemoteClientConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n\n\tprivate final DevToolsProperties properties;\n\n\t@Value("${remoteUrl}")\n\tprivate String remoteUrl;\n\n\tpublic RemoteClientConfiguration(DevToolsProperties properties) {\n\t\tthis.properties = properties;\n\t}\n\n\t@Bean\n\tpublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n\t}\n\n\t@Bean\n\tpublic ClientHttpRequestFactory clientHttpRequestFactory() {\n\t\tList<ClientHttpRequestInterceptor> interceptors = Arrays\n\t\t\t\t.asList(getSecurityInterceptor());\n\t\tSimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n\t\tProxy proxy = this.properties.getRemote().getProxy();\n\t\tif (proxy.getHost() != null && proxy.getPort() != null) {\n\t\t\trequestFactory.setProxy(new java.net.Proxy(Type.HTTP,\n\t\t\t\t\tnew InetSocketAddress(proxy.getHost(), proxy.getPort())));\n\t\t}\n\t\treturn new InterceptingClientHttpRequestFactory(requestFactory, interceptors);\n\t}\n\n\tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n\t\tString secret = remoteProperties.getSecret();\n\t\tAssert.state(secret != null,\n\t\t\t\t"The environment value \'spring.devtools.remote.secret\' "\n\t\t\t\t\t\t+ "is required to secure your connection.");\n\t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n\t}\n\n\t@PostConstruct\n\tprivate void logWarnings() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tif (!remoteProperties.getDebug().isEnabled()\n\t\t\t\t&& !remoteProperties.getRestart().isEnabled()) {\n\t\t\tlogger.warn("Remote restart and debug are both disabled.");\n\t\t}\n\t\tif (!this.remoteUrl.startsWith("https://")) {\n\t\t\tlogger.warn("The connection to " + this.remoteUrl\n\t\t\t\t\t+ " is insecure. You should use a URL starting with \'https://\'.");\n\t\t}\n\t}\n\n\t/**\n\t * LiveReload configuration.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.livereload", name = "enabled", matchIfMissing = true)\n\tstatic class LiveReloadConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Autowired(required = false)\n\t\tprivate LiveReloadServer liveReloadServer;\n\n\t\t@Autowired\n\t\tprivate ClientHttpRequestFactory clientHttpRequestFactory;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\n\t\t@Bean\n\t\t@RestartScope\n\t\t@ConditionalOnMissingBean\n\t\tpublic LiveReloadServer liveReloadServer() {\n\t\t\treturn new LiveReloadServer(this.properties.getLivereload().getPort(),\n\t\t\t\t\tRestarter.getInstance().getThreadFactory());\n\t\t}\n\n\t\t@EventListener\n\t\tpublic void onClassPathChanged(ClassPathChangedEvent event) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath();\n\t\t\tthis.executor.execute(new DelayedLiveReloadTrigger(optionalLiveReloadServer(),\n\t\t\t\t\tthis.clientHttpRequestFactory, url));\n\t\t}\n\n\t\t@Bean\n\t\tpublic OptionalLiveReloadServer optionalLiveReloadServer() {\n\t\t\treturn new OptionalLiveReloadServer(this.liveReloadServer);\n\t\t}\n\n\t\tfinal ExecutorService getExecutor() {\n\t\t\treturn this.executor;\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote update and restarts.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.remote.restart", name = "enabled", matchIfMissing = true)\n\tstatic class RemoteRestartClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic ClassPathFileSystemWatcher classPathFileSystemWatcher() {\n\t\t\tDefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();\n\t\t\tURL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());\n\t\t\tif (urls == null) {\n\t\t\t\turls = new URL[0];\n\t\t\t}\n\t\t\treturn new ClassPathFileSystemWatcher(getFileSystemWatcherFactory(),\n\t\t\t\t\tclassPathRestartStrategy(), urls);\n\t\t}\n\n\t\t@Bean\n\t\tpublic FileSystemWatcherFactory getFileSystemWatcherFactory() {\n\t\t\treturn new FileSystemWatcherFactory() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileSystemWatcher getFileSystemWatcher() {\n\t\t\t\t\treturn newFileSystemWatcher();\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tprivate FileSystemWatcher newFileSystemWatcher() {\n\t\t\tRestart restartProperties = this.properties.getRestart();\n\t\t\tFileSystemWatcher watcher = new FileSystemWatcher(true,\n\t\t\t\t\trestartProperties.getPollInterval(),\n\t\t\t\t\trestartProperties.getQuietPeriod());\n\t\t\tString triggerFile = restartProperties.getTriggerFile();\n\t\t\tif (StringUtils.hasLength(triggerFile)) {\n\t\t\t\twatcher.setTriggerFilter(new TriggerFileFilter(triggerFile));\n\t\t\t}\n\t\t\treturn watcher;\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathRestartStrategy classPathRestartStrategy() {\n\t\t\treturn new PatternClassPathRestartStrategy(\n\t\t\t\t\tthis.properties.getRestart().getAllExclude());\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathChangeUploader classPathChangeUploader(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath()\n\t\t\t\t\t+ "/restart";\n\t\t\treturn new ClassPathChangeUploader(url, requestFactory);\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote debug HTTP tunneling.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.remote.debug", name = "enabled", matchIfMissing = true)\n\t@ConditionalOnClass(Filter.class)\n\t@Conditional(LocalDebugPortAvailableCondition.class)\n\tstatic class RemoteDebugTunnelClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic TunnelClient remoteDebugTunnelClient(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\t\tString url = this.remoteUrl + remoteProperties.getContextPath() + "/debug";\n\t\t\tTunnelConnection connection = new HttpTunnelConnection(url, requestFactory);\n\t\t\tint localPort = remoteProperties.getDebug().getLocalPort();\n\t\t\tTunnelClient client = new TunnelClient(localPort, connection);\n\t\t\tclient.addListener(new LoggingTunnelClientListener());\n\t\t\treturn client;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
