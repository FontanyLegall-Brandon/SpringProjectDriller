{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -238,7 +238,7 @@ public class EndpointWebMvcAutoConfiguration\n \t// Put Servlets and Filters in their own nested class so they don\'t force early\n \t// instantiation of ManagementServerProperties.\n \t@Configuration\n-\t@ConditionalOnProperty(prefix = "management", name = "add-application-context-header", matchIfMissing = true, havingValue = "true")\n+\t@ConditionalOnProperty(prefix = "management", name = "add-application-context-header", havingValue = "true")\n \tprotected static class ApplicationContextFilterConfiguration {\n \n \t\t@Bean\n', 'source_code': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.lang.reflect.Modifier;\n\nimport javax.servlet.Servlet;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.FatalBeanException;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementServletContext;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration;\nimport org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.event.ApplicationFailedEvent;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;\nimport org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext;\nimport org.springframework.boot.web.servlet.filter.ApplicationContextHeaderFilter;\nimport org.springframework.boot.web.servlet.server.ServletWebServerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationCondition;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.core.env.ConfigurableEnvironment;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n * @author Christian Dupuis\n * @author Andy Wilkinson\n * @author Johannes Edmeier\n * @author Eddú Meléndez\n * @author Venil Noronha\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(ManagementServerProperties.class)\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tServletWebServerFactoryAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tRepositoryRestMvcAutoConfiguration.class, HypermediaAutoConfiguration.class,\n\t\tHttpMessageConvertersAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration\n\t\timplements ApplicationContextAware, SmartInitializingSingleton {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Bean\n\tpublic ManagementContextResolver managementContextResolver() {\n\t\treturn new ManagementContextResolver(this.applicationContext);\n\t}\n\n\t@Bean\n\tpublic ManagementServletContext managementServletContext(\n\t\t\tfinal ManagementServerProperties properties) {\n\t\treturn new ManagementServletContext() {\n\n\t\t\t@Override\n\t\t\tpublic String getContextPath() {\n\t\t\t\treturn properties.getContextPath();\n\t\t\t}\n\n\t\t};\n\t}\n\n\t@Override\n\tpublic void afterSingletonsInstantiated() {\n\t\tManagementServerPort managementPort = ManagementServerPort.DIFFERENT;\n\t\tif (this.applicationContext instanceof WebApplicationContext) {\n\t\t\tmanagementPort = ManagementServerPort\n\t\t\t\t\t.get(this.applicationContext.getEnvironment());\n\t\t}\n\t\tif (managementPort == ManagementServerPort.DIFFERENT) {\n\t\t\tif (this.applicationContext instanceof ServletWebServerApplicationContext\n\t\t\t\t\t&& ((ServletWebServerApplicationContext) this.applicationContext)\n\t\t\t\t\t\t\t.getWebServer() != null) {\n\t\t\t\tcreateChildManagementContext();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn("Could not start management web server on "\n\t\t\t\t\t\t+ "different port (management endpoints are still available "\n\t\t\t\t\t\t+ "through JMX)");\n\t\t\t}\n\t\t}\n\t\tif (managementPort == ManagementServerPort.SAME) {\n\t\t\tif (new RelaxedPropertyResolver(this.applicationContext.getEnvironment(),\n\t\t\t\t\t"management.ssl.").getProperty("enabled") != null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t"Management-specific SSL cannot be configured as the management "\n\t\t\t\t\t\t\t\t+ "server is not listening on a separate port");\n\t\t\t}\n\t\t\tif (this.applicationContext\n\t\t\t\t\t.getEnvironment() instanceof ConfigurableEnvironment) {\n\t\t\t\taddLocalManagementPortPropertyAlias(\n\t\t\t\t\t\t(ConfigurableEnvironment) this.applicationContext\n\t\t\t\t\t\t\t\t.getEnvironment());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void createChildManagementContext() {\n\t\tAnnotationConfigServletWebServerApplicationContext childContext = new AnnotationConfigServletWebServerApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setNamespace("management");\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\t\tchildContext.setClassLoader(this.applicationContext.getClassLoader());\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tServletWebServerFactoryAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\t\tregisterServletWebServerFactory(childContext);\n\t\tCloseManagementContextListener.addIfPossible(this.applicationContext,\n\t\t\t\tchildContext);\n\t\tchildContext.refresh();\n\t\tmanagementContextResolver().setApplicationContext(childContext);\n\t}\n\n\tprivate void registerServletWebServerFactory(\n\t\t\tAnnotationConfigServletWebServerApplicationContext childContext) {\n\t\ttry {\n\t\t\tConfigurableListableBeanFactory beanFactory = childContext.getBeanFactory();\n\t\t\tif (beanFactory instanceof BeanDefinitionRegistry) {\n\t\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n\t\t\t\tregistry.registerBeanDefinition("ServletWebServerFactory",\n\t\t\t\t\t\tnew RootBeanDefinition(determineServletWebServerFactoryClass()));\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Ignore and assume auto-configuration\n\t\t}\n\t}\n\n\tprivate Class<?> determineServletWebServerFactoryClass()\n\t\t\tthrows NoSuchBeanDefinitionException {\n\t\tClass<?> factoryClass = this.applicationContext\n\t\t\t\t.getBean(ServletWebServerFactory.class).getClass();\n\t\tif (cannotBeInstantiated(factoryClass)) {\n\t\t\tthrow new FatalBeanException("ServletWebServerFactory implementation "\n\t\t\t\t\t+ factoryClass.getName() + " cannot be instantiated. "\n\t\t\t\t\t+ "To allow a separate management port to be used, a top-level class "\n\t\t\t\t\t+ "or static inner class should be used instead");\n\t\t}\n\t\treturn factoryClass;\n\t}\n\n\tprivate boolean cannotBeInstantiated(Class<?> clazz) {\n\t\treturn clazz.isLocalClass()\n\t\t\t\t|| (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers()))\n\t\t\t\t|| clazz.isAnonymousClass();\n\t}\n\n\t/**\n\t * Add an alias for \'local.management.port\' that actually resolves using\n\t * \'local.server.port\'.\n\t * @param environment the environment\n\t */\n\tprivate void addLocalManagementPortPropertyAlias(\n\t\t\tfinal ConfigurableEnvironment environment) {\n\t\tenvironment.getPropertySources()\n\t\t\t\t.addLast(new PropertySource<Object>("Management Server") {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getProperty(String name) {\n\t\t\t\t\t\tif ("local.management.port".equals(name)) {\n\t\t\t\t\t\t\treturn environment.getProperty("local.server.port");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\t@ConditionalOnProperty(prefix = "management", name = "add-application-context-header", havingValue = "true")\n\tprotected static class ApplicationContextFilterConfiguration {\n\n\t\t@Bean\n\t\tpublic ApplicationContextHeaderFilter applicationContextIdFilter(\n\t\t\t\tApplicationContext context) {\n\t\t\treturn new ApplicationContextHeaderFilter(context);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(OnManagementMvcCondition.class)\n\t@Import(ManagementContextConfigurationsImportSelector.class)\n\tprotected static class EndpointWebMvcConfiguration {\n\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to propagate the {@link ContextClosedEvent} and\n\t * {@link ApplicationFailedEvent} from a parent to a child.\n\t */\n\tprivate static class CloseManagementContextListener\n\t\t\timplements ApplicationListener<ApplicationEvent> {\n\n\t\tprivate final ApplicationContext parentContext;\n\n\t\tprivate final ConfigurableApplicationContext childContext;\n\n\t\tCloseManagementContextListener(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tthis.parentContext = parentContext;\n\t\t\tthis.childContext = childContext;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\t\tif (event instanceof ContextClosedEvent) {\n\t\t\t\tonContextClosedEvent((ContextClosedEvent) event);\n\t\t\t}\n\t\t\tif (event instanceof ApplicationFailedEvent) {\n\t\t\t\tonApplicationFailedEvent((ApplicationFailedEvent) event);\n\t\t\t}\n\t\t};\n\n\t\tprivate void onContextClosedEvent(ContextClosedEvent event) {\n\t\t\tpropagateCloseIfNecessary(event.getApplicationContext());\n\t\t}\n\n\t\tprivate void onApplicationFailedEvent(ApplicationFailedEvent event) {\n\t\t\tpropagateCloseIfNecessary(event.getApplicationContext());\n\t\t}\n\n\t\tprivate void propagateCloseIfNecessary(ApplicationContext applicationContext) {\n\t\t\tif (applicationContext == this.parentContext) {\n\t\t\t\tthis.childContext.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic static void addIfPossible(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tif (parentContext instanceof ConfigurableApplicationContext) {\n\t\t\t\tadd((ConfigurableApplicationContext) parentContext, childContext);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void add(ConfigurableApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tparentContext.addApplicationListener(\n\t\t\t\t\tnew CloseManagementContextListener(parentContext, childContext));\n\t\t}\n\n\t}\n\n\tprivate static class OnManagementMvcCondition extends SpringBootCondition\n\t\t\timplements ConfigurationCondition {\n\n\t\t@Override\n\t\tpublic ConfigurationPhase getConfigurationPhase() {\n\t\t\treturn ConfigurationPhase.REGISTER_BEAN;\n\t\t}\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("Management Server MVC");\n\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch(message.because("non WebApplicationContext"));\n\t\t\t}\n\t\t\tManagementServerPort port = ManagementServerPort\n\t\t\t\t\t.get(context.getEnvironment());\n\t\t\tif (port == ManagementServerPort.SAME) {\n\t\t\t\treturn ConditionOutcome.match(message.because("port is same"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.because("port is not same"));\n\t\t}\n\n\t}\n\n\tprotected enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(Environment environment) {\n\t\t\tInteger serverPort = getPortProperty(environment, "server.");\n\t\t\tInteger managementPort = getPortProperty(environment, "management.");\n\t\t\tif (managementPort != null && managementPort < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\treturn ((managementPort == null)\n\t\t\t\t\t|| (serverPort == null && managementPort.equals(8080))\n\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort)) ? SAME\n\t\t\t\t\t\t\t: DIFFERENT);\n\t\t}\n\n\t\tprivate static Integer getPortProperty(Environment environment, String prefix) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n\t\t\t\t\tprefix);\n\t\t\treturn resolver.getProperty("port", Integer.class);\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.lang.reflect.Modifier;\n\nimport javax.servlet.Servlet;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.FatalBeanException;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementServletContext;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication.Type;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration;\nimport org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.event.ApplicationFailedEvent;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;\nimport org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext;\nimport org.springframework.boot.web.servlet.filter.ApplicationContextHeaderFilter;\nimport org.springframework.boot.web.servlet.server.ServletWebServerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationCondition;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.core.env.ConfigurableEnvironment;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n * @author Christian Dupuis\n * @author Andy Wilkinson\n * @author Johannes Edmeier\n * @author Eddú Meléndez\n * @author Venil Noronha\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication(type = Type.SERVLET)\n@EnableConfigurationProperties(ManagementServerProperties.class)\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tServletWebServerFactoryAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tRepositoryRestMvcAutoConfiguration.class, HypermediaAutoConfiguration.class,\n\t\tHttpMessageConvertersAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration\n\t\timplements ApplicationContextAware, SmartInitializingSingleton {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Bean\n\tpublic ManagementContextResolver managementContextResolver() {\n\t\treturn new ManagementContextResolver(this.applicationContext);\n\t}\n\n\t@Bean\n\tpublic ManagementServletContext managementServletContext(\n\t\t\tfinal ManagementServerProperties properties) {\n\t\treturn new ManagementServletContext() {\n\n\t\t\t@Override\n\t\t\tpublic String getContextPath() {\n\t\t\t\treturn properties.getContextPath();\n\t\t\t}\n\n\t\t};\n\t}\n\n\t@Override\n\tpublic void afterSingletonsInstantiated() {\n\t\tManagementServerPort managementPort = ManagementServerPort.DIFFERENT;\n\t\tif (this.applicationContext instanceof WebApplicationContext) {\n\t\t\tmanagementPort = ManagementServerPort\n\t\t\t\t\t.get(this.applicationContext.getEnvironment());\n\t\t}\n\t\tif (managementPort == ManagementServerPort.DIFFERENT) {\n\t\t\tif (this.applicationContext instanceof ServletWebServerApplicationContext\n\t\t\t\t\t&& ((ServletWebServerApplicationContext) this.applicationContext)\n\t\t\t\t\t\t\t.getWebServer() != null) {\n\t\t\t\tcreateChildManagementContext();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn("Could not start management web server on "\n\t\t\t\t\t\t+ "different port (management endpoints are still available "\n\t\t\t\t\t\t+ "through JMX)");\n\t\t\t}\n\t\t}\n\t\tif (managementPort == ManagementServerPort.SAME) {\n\t\t\tif (new RelaxedPropertyResolver(this.applicationContext.getEnvironment(),\n\t\t\t\t\t"management.ssl.").getProperty("enabled") != null) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t"Management-specific SSL cannot be configured as the management "\n\t\t\t\t\t\t\t\t+ "server is not listening on a separate port");\n\t\t\t}\n\t\t\tif (this.applicationContext\n\t\t\t\t\t.getEnvironment() instanceof ConfigurableEnvironment) {\n\t\t\t\taddLocalManagementPortPropertyAlias(\n\t\t\t\t\t\t(ConfigurableEnvironment) this.applicationContext\n\t\t\t\t\t\t\t\t.getEnvironment());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void createChildManagementContext() {\n\t\tAnnotationConfigServletWebServerApplicationContext childContext = new AnnotationConfigServletWebServerApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setNamespace("management");\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\t\tchildContext.setClassLoader(this.applicationContext.getClassLoader());\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tServletWebServerFactoryAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\t\tregisterServletWebServerFactory(childContext);\n\t\tCloseManagementContextListener.addIfPossible(this.applicationContext,\n\t\t\t\tchildContext);\n\t\tchildContext.refresh();\n\t\tmanagementContextResolver().setApplicationContext(childContext);\n\t}\n\n\tprivate void registerServletWebServerFactory(\n\t\t\tAnnotationConfigServletWebServerApplicationContext childContext) {\n\t\ttry {\n\t\t\tConfigurableListableBeanFactory beanFactory = childContext.getBeanFactory();\n\t\t\tif (beanFactory instanceof BeanDefinitionRegistry) {\n\t\t\t\tBeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;\n\t\t\t\tregistry.registerBeanDefinition("ServletWebServerFactory",\n\t\t\t\t\t\tnew RootBeanDefinition(determineServletWebServerFactoryClass()));\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Ignore and assume auto-configuration\n\t\t}\n\t}\n\n\tprivate Class<?> determineServletWebServerFactoryClass()\n\t\t\tthrows NoSuchBeanDefinitionException {\n\t\tClass<?> factoryClass = this.applicationContext\n\t\t\t\t.getBean(ServletWebServerFactory.class).getClass();\n\t\tif (cannotBeInstantiated(factoryClass)) {\n\t\t\tthrow new FatalBeanException("ServletWebServerFactory implementation "\n\t\t\t\t\t+ factoryClass.getName() + " cannot be instantiated. "\n\t\t\t\t\t+ "To allow a separate management port to be used, a top-level class "\n\t\t\t\t\t+ "or static inner class should be used instead");\n\t\t}\n\t\treturn factoryClass;\n\t}\n\n\tprivate boolean cannotBeInstantiated(Class<?> clazz) {\n\t\treturn clazz.isLocalClass()\n\t\t\t\t|| (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers()))\n\t\t\t\t|| clazz.isAnonymousClass();\n\t}\n\n\t/**\n\t * Add an alias for \'local.management.port\' that actually resolves using\n\t * \'local.server.port\'.\n\t * @param environment the environment\n\t */\n\tprivate void addLocalManagementPortPropertyAlias(\n\t\t\tfinal ConfigurableEnvironment environment) {\n\t\tenvironment.getPropertySources()\n\t\t\t\t.addLast(new PropertySource<Object>("Management Server") {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getProperty(String name) {\n\t\t\t\t\t\tif ("local.management.port".equals(name)) {\n\t\t\t\t\t\t\treturn environment.getProperty("local.server.port");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\t@ConditionalOnProperty(prefix = "management", name = "add-application-context-header", matchIfMissing = true, havingValue = "true")\n\tprotected static class ApplicationContextFilterConfiguration {\n\n\t\t@Bean\n\t\tpublic ApplicationContextHeaderFilter applicationContextIdFilter(\n\t\t\t\tApplicationContext context) {\n\t\t\treturn new ApplicationContextHeaderFilter(context);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(OnManagementMvcCondition.class)\n\t@Import(ManagementContextConfigurationsImportSelector.class)\n\tprotected static class EndpointWebMvcConfiguration {\n\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to propagate the {@link ContextClosedEvent} and\n\t * {@link ApplicationFailedEvent} from a parent to a child.\n\t */\n\tprivate static class CloseManagementContextListener\n\t\t\timplements ApplicationListener<ApplicationEvent> {\n\n\t\tprivate final ApplicationContext parentContext;\n\n\t\tprivate final ConfigurableApplicationContext childContext;\n\n\t\tCloseManagementContextListener(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tthis.parentContext = parentContext;\n\t\t\tthis.childContext = childContext;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\t\tif (event instanceof ContextClosedEvent) {\n\t\t\t\tonContextClosedEvent((ContextClosedEvent) event);\n\t\t\t}\n\t\t\tif (event instanceof ApplicationFailedEvent) {\n\t\t\t\tonApplicationFailedEvent((ApplicationFailedEvent) event);\n\t\t\t}\n\t\t};\n\n\t\tprivate void onContextClosedEvent(ContextClosedEvent event) {\n\t\t\tpropagateCloseIfNecessary(event.getApplicationContext());\n\t\t}\n\n\t\tprivate void onApplicationFailedEvent(ApplicationFailedEvent event) {\n\t\t\tpropagateCloseIfNecessary(event.getApplicationContext());\n\t\t}\n\n\t\tprivate void propagateCloseIfNecessary(ApplicationContext applicationContext) {\n\t\t\tif (applicationContext == this.parentContext) {\n\t\t\t\tthis.childContext.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic static void addIfPossible(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tif (parentContext instanceof ConfigurableApplicationContext) {\n\t\t\t\tadd((ConfigurableApplicationContext) parentContext, childContext);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void add(ConfigurableApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tparentContext.addApplicationListener(\n\t\t\t\t\tnew CloseManagementContextListener(parentContext, childContext));\n\t\t}\n\n\t}\n\n\tprivate static class OnManagementMvcCondition extends SpringBootCondition\n\t\t\timplements ConfigurationCondition {\n\n\t\t@Override\n\t\tpublic ConfigurationPhase getConfigurationPhase() {\n\t\t\treturn ConfigurationPhase.REGISTER_BEAN;\n\t\t}\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("Management Server MVC");\n\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch(message.because("non WebApplicationContext"));\n\t\t\t}\n\t\t\tManagementServerPort port = ManagementServerPort\n\t\t\t\t\t.get(context.getEnvironment());\n\t\t\tif (port == ManagementServerPort.SAME) {\n\t\t\t\treturn ConditionOutcome.match(message.because("port is same"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.because("port is not same"));\n\t\t}\n\n\t}\n\n\tprotected enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(Environment environment) {\n\t\t\tInteger serverPort = getPortProperty(environment, "server.");\n\t\t\tInteger managementPort = getPortProperty(environment, "management.");\n\t\t\tif (managementPort != null && managementPort < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\treturn ((managementPort == null)\n\t\t\t\t\t|| (serverPort == null && managementPort.equals(8080))\n\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort)) ? SAME\n\t\t\t\t\t\t\t: DIFFERENT);\n\t\t}\n\n\t\tprivate static Integer getPortProperty(Environment environment, String prefix) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n\t\t\t\t\tprefix);\n\t\t\treturn resolver.getProperty("port", Integer.class);\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
