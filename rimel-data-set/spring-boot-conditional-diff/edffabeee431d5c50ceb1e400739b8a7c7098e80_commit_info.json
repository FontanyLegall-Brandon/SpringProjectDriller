{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/CrshAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/CrshAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -155,6 +155,7 @@ public class CrshAutoConfiguration {\n \t * Class to configure CRaSH to authenticate against Spring Security.\n \t */\n \t@Configuration\n+\t@ConditionalOnExpression("\'${shell.auth:spring}\' == \'spring\'")\n \t@ConditionalOnBean({ AuthenticationManager.class })\n \t@AutoConfigureAfter(CrshAutoConfiguration.class)\n \tpublic static class AuthenticationManagerAdapterAutoConfiguration {\n@@ -168,7 +169,6 @@ public class CrshAutoConfiguration {\n \t\t}\n \n \t\t@Bean\n-\t\t@ConditionalOnExpression("\'${shell.auth:spring}\' == \'spring\'")\n \t\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n \t\tpublic CrshShellAuthenticationProperties springAuthenticationProperties() {\n \t\t\t// In case no shell.auth property is provided fall back to Spring Security\n', 'source_code': '/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\nimport org.crsh.auth.AuthenticationPlugin;\nimport org.crsh.plugin.CRaSHPlugin;\nimport org.crsh.plugin.PluginContext;\nimport org.crsh.plugin.PluginDiscovery;\nimport org.crsh.plugin.PluginLifeCycle;\nimport org.crsh.plugin.PropertyDescriptor;\nimport org.crsh.plugin.ServiceLoaderDiscovery;\nimport org.crsh.vfs.FS;\nimport org.crsh.vfs.spi.AbstractFSDriver;\nimport org.crsh.vfs.spi.FSDriver;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.CrshShellAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.CrshShellProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.JaasAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.KeyAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.SimpleAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.SpringAuthenticationProperties;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.SpringVersion;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.security.access.AccessDecisionManager;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell\n * into a Spring Boot enabled application. By default a SSH daemon is started on port\n * 2000. If the CRaSH Telnet plugin is available on the classpath, Telnet daemon will be\n * launched on port 5000.\n * <p>\n * The default shell authentication method uses a username and password combination. If no\n * configuration is provided the default username is \'user\' and the password will be\n * printed to console during application startup. Those default values can be overridden\n * by using <code>shell.auth.simple.username</code> and\n * <code>shell.auth.simple.password</code>.\n * <p>\n * If a Spring Security {@link AuthenticationManager} is detected, this configuration will\n * create a {@link CRaSHPlugin} to forward shell authentication requests to Spring\n * Security. This authentication method will get enabled if <code>shell.auth</code> is set\n * to <code>spring</code> or if no explicit <code>shell.auth</code> is provided and a\n * {@link AuthenticationManager} is available. In the latter case shell access will be\n * restricted to users having roles that match those configured in\n * {@link ManagementServerProperties}. Required roles can be overridden by\n * <code>shell.auth.spring.roles</code>.\n * <p>\n * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in\n * the application context. Those beans will get auto detected during startup and\n * registered with the underlying shell infrastructure. To configure plugins and the CRaSH\n * infrastructure add beans of type {@link CrshShellProperties} to the application\n * context.\n * <p>\n * Additional shell commands can be implemented using the guide and documentation at <a\n * href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands\n * using the following classpath scanning pattern <code>classpath*:/commands/**</code>. To\n * add different locations or override the default use\n * <code>shell.command_path_patterns</code> in your application configuration.\n * \n * @author Christian Dupuis\n * @see ShellProperties\n */\n@Configuration\n@ConditionalOnClass({ PluginLifeCycle.class })\n@EnableConfigurationProperties({ ShellProperties.class })\n@AutoConfigureAfter({ SecurityAutoConfiguration.class,\n\t\tManagementSecurityAutoConfiguration.class })\npublic class CrshAutoConfiguration {\n\n\t@Autowired\n\tprivate ShellProperties properties;\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'jaas\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties jaasAuthenticationProperties() {\n\t\treturn new JaasAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'key\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties keyAuthenticationProperties() {\n\t\treturn new KeyAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'simple\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties simpleAuthenticationProperties() {\n\t\treturn new SimpleAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n\tpublic PluginLifeCycle shellBootstrap() {\n\t\tCrshBootstrapBean bootstrapBean = new CrshBootstrapBean();\n\t\tbootstrapBean.setConfig(this.properties.asCrshShellConfig());\n\t\treturn bootstrapBean;\n\t}\n\n\t/**\n\t * Class to configure CRaSH to authenticate against Spring Security.\n\t */\n\t@Configuration\n\t@ConditionalOnExpression("\'${shell.auth:spring}\' == \'spring\'")\n\t@ConditionalOnBean({ AuthenticationManager.class })\n\t@AutoConfigureAfter(CrshAutoConfiguration.class)\n\tpublic static class AuthenticationManagerAdapterAutoConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Bean\n\t\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n\t\t\treturn new AuthenticationManagerAdapter();\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\t\tpublic CrshShellAuthenticationProperties springAuthenticationProperties() {\n\t\t\t// In case no shell.auth property is provided fall back to Spring Security\n\t\t\t// based authentication and get role to access shell from\n\t\t\t// ManagementServerProperties.\n\t\t\t// In case shell.auth is set to spring and roles are configured using\n\t\t\t// shell.auth.spring.roles the below default role will be overridden by\n\t\t\t// ConfigurationProperties.\n\t\t\tSpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties();\n\t\t\tif (this.management != null) {\n\t\t\t\tauthenticationProperties.setRoles(new String[] { this.management\n\t\t\t\t\t\t.getSecurity().getRole() });\n\t\t\t}\n\t\t\treturn authenticationProperties;\n\t\t}\n\n\t}\n\n\t/**\n\t * Spring Bean used to bootstrap the CRaSH shell.\n\t */\n\tpublic static class CrshBootstrapBean extends PluginLifeCycle {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t@Autowired\n\t\tprivate Environment environment;\n\n\t\t@Autowired\n\t\tprivate ShellProperties properties;\n\n\t\t@Autowired\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\t@PreDestroy\n\t\tpublic void destroy() {\n\t\t\tstop();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() {\n\t\t\tFS commandFileSystem = createFileSystem(\n\t\t\t\t\tthis.properties.getCommandPathPatterns(),\n\t\t\t\t\tthis.properties.getDisabledCommands());\n\t\t\tFS configurationFileSystem = createFileSystem(\n\t\t\t\t\tthis.properties.getConfigPathPatterns(), new String[0]);\n\n\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(\n\t\t\t\t\tthis.resourceLoader.getClassLoader(), this.beanFactory,\n\t\t\t\t\tthis.properties.getDisabledPlugins());\n\n\t\t\tPluginContext context = new PluginContext(discovery,\n\t\t\t\t\tcreatePluginContextAttributes(), commandFileSystem,\n\t\t\t\t\tconfigurationFileSystem, this.resourceLoader.getClassLoader());\n\n\t\t\tcontext.refresh();\n\t\t\tstart(context);\n\t\t}\n\n\t\tprotected FS createFileSystem(String[] pathPatterns, String[] filterPatterns) {\n\t\t\tAssert.notNull(pathPatterns, "PathPatterns must not be null");\n\t\t\tAssert.notNull(filterPatterns, "FilterPatterns must not be null");\n\t\t\tFS fileSystem = new FS();\n\t\t\tfor (String pathPattern : pathPatterns) {\n\t\t\t\ttry {\n\t\t\t\t\tfileSystem.mount(new SimpleFileSystemDriver(new DirectoryHandle(\n\t\t\t\t\t\t\tpathPattern, this.resourceLoader, filterPatterns)));\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException("Failed to mount file system for \'"\n\t\t\t\t\t\t\t+ pathPattern + "\'", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fileSystem;\n\t\t}\n\n\t\tprotected Map<String, Object> createPluginContextAttributes() {\n\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage()\n\t\t\t\t\t.getImplementationVersion();\n\t\t\tif (bootVersion != null) {\n\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n\t\t\t}\n\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tattributes.put("spring.beanfactory", this.beanFactory);\n\t\t\t}\n\t\t\tif (this.environment != null) {\n\t\t\t\tattributes.put("spring.environment", this.environment);\n\t\t\t}\n\t\t\treturn attributes;\n\t\t}\n\n\t}\n\n\t/**\n\t * Adapts a Spring Security {@link AuthenticationManager} for use with CRaSH.\n\t */\n\t@SuppressWarnings("rawtypes")\n\tprivate static class AuthenticationManagerAdapter extends\n\t\t\tCRaSHPlugin<AuthenticationPlugin> implements AuthenticationPlugin<String> {\n\n\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor\n\t\t\t\t.create("auth.spring.roles", "ADMIN",\n\t\t\t\t\t\t"Comma separated list of roles required to access the shell");\n\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\n\t\t@Autowired(required = false)\n\t\tprivate AccessDecisionManager accessDecisionManager;\n\n\t\tprivate String[] roles = new String[] { "ADMIN" };\n\n\t\t@Override\n\t\tpublic boolean authenticate(String username, String password) throws Exception {\n\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username,\n\t\t\t\t\tpassword);\n\t\t\ttry {\n\t\t\t\t// Authenticate first to make sure credentials are valid\n\t\t\t\ttoken = this.authenticationManager.authenticate(token);\n\t\t\t}\n\t\t\tcatch (AuthenticationException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n\t\t\tif (this.accessDecisionManager != null && token.isAuthenticated()\n\t\t\t\t\t&& this.roles != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.accessDecisionManager.decide(token, this,\n\t\t\t\t\t\t\tSecurityConfig.createList(this.roles));\n\t\t\t\t}\n\t\t\t\tcatch (AccessDeniedException ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn token.isAuthenticated();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<String> getCredentialType() {\n\t\t\treturn String.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic AuthenticationPlugin<String> getImplementation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn "spring";\n\t\t}\n\n\t\t@Override\n\t\tpublic void init() {\n\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n\t\t\tif (rolesPropertyValue != null) {\n\t\t\t\tthis.roles = StringUtils\n\t\t\t\t\t\t.commaDelimitedListToStringArray(rolesPropertyValue);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n\t\t\treturn Arrays.<PropertyDescriptor<?>> asList(ROLES);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ServiceLoaderDiscovery} to expose {@link CRaSHPlugin} Beans from Spring and\n\t * deal with filtering disabled plugins.\n\t */\n\tprivate static class BeanFactoryFilteringPluginDiscovery extends\n\t\t\tServiceLoaderDiscovery {\n\n\t\tprivate final ListableBeanFactory beanFactory;\n\n\t\tprivate final String[] disabledPlugins;\n\n\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader,\n\t\t\t\tListableBeanFactory beanFactory, String[] disabledPlugins)\n\t\t\t\tthrows NullPointerException {\n\t\t\tsuper(classLoader);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.disabledPlugins = disabledPlugins;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings("rawtypes")\n\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n\n\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n\t\t\t\tif (isEnabled(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollection<CRaSHPlugin> pluginBeans = this.beanFactory.getBeansOfType(\n\t\t\t\t\tCRaSHPlugin.class).values();\n\t\t\tfor (CRaSHPlugin<?> pluginBean : pluginBeans) {\n\t\t\t\tif (isEnabled(pluginBean)) {\n\t\t\t\t\tplugins.add(pluginBean);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn plugins;\n\t\t}\n\n\t\tprotected boolean isEnabled(CRaSHPlugin<?> plugin) {\n\t\t\tAssert.notNull(plugin, "Plugin must not be null");\n\n\t\t\tif (ObjectUtils.isEmpty(this.disabledPlugins)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tSet<Class<?>> pluginClasses = ClassUtils.getAllInterfacesAsSet(plugin);\n\t\t\tpluginClasses.add(plugin.getClass());\n\n\t\t\tfor (Class<?> pluginClass : pluginClasses) {\n\t\t\t\tif (isEnabled(pluginClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean isEnabled(Class<?> pluginClass) {\n\t\t\tfor (String disabledPlugin : this.disabledPlugins) {\n\t\t\t\tif (ClassUtils.getShortName(pluginClass).equalsIgnoreCase(disabledPlugin)\n\t\t\t\t\t\t|| ClassUtils.getQualifiedName(pluginClass).equalsIgnoreCase(\n\t\t\t\t\t\t\t\tdisabledPlugin)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * {@link FSDriver} to wrap Spring\'s {@link Resource} abstraction to CRaSH.\n\t */\n\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n\n\t\tprivate final ResourceHandle root;\n\n\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n\t\t\tthis.root = handle;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle)\n\t\t\t\tthrows IOException {\n\t\t\tif (handle instanceof DirectoryHandle) {\n\t\t\t\treturn ((DirectoryHandle) handle).members();\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn ((FileHandle) handle).getLastModified();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n\t\t\treturn handle instanceof DirectoryHandle;\n\t\t}\n\n\t\t@Override\n\t\tpublic String name(ResourceHandle handle) throws IOException {\n\t\t\treturn handle.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream())\n\t\t\t\t\t\t.iterator();\n\t\t\t}\n\t\t\treturn Collections.<InputStream> emptyList().iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceHandle root() throws IOException {\n\t\t\treturn this.root;\n\t\t}\n\n\t}\n\n\t/**\n\t * Base for handles to Spring {@link Resource}s.\n\t */\n\tprivate abstract static class ResourceHandle {\n\n\t\tprivate final String name;\n\n\t\tpublic ResourceHandle(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a directory.\n\t */\n\tprivate static class DirectoryHandle extends ResourceHandle {\n\n\t\tprivate final ResourcePatternResolver resourceLoader;\n\n\t\tprivate final String[] filterPatterns;\n\n\t\tprivate final AntPathMatcher matcher = new AntPathMatcher();\n\n\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader,\n\t\t\t\tString[] filterPatterns) {\n\t\t\tsuper(name);\n\t\t\tthis.resourceLoader = resourceLoader;\n\t\t\tthis.filterPatterns = filterPatterns;\n\t\t}\n\n\t\tpublic List<ResourceHandle> members() throws IOException {\n\t\t\tResource[] resources = this.resourceLoader.getResources(getName());\n\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (!resource.getURL().getPath().endsWith("/") && !shouldFilter(resource)) {\n\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn files;\n\t\t}\n\n\t\tprivate boolean shouldFilter(Resource resource) {\n\t\t\tfor (String filterPattern : this.filterPatterns) {\n\t\t\t\tif (this.matcher.match(filterPattern, resource.getFilename())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a file backed by a Spring {@link Resource}.\n\t */\n\tprivate static class FileHandle extends ResourceHandle {\n\n\t\tprivate final Resource resource;\n\n\t\tpublic FileHandle(String name, Resource resource) {\n\t\t\tsuper(name);\n\t\t\tthis.resource = resource;\n\t\t}\n\n\t\tpublic InputStream openStream() throws IOException {\n\t\t\treturn this.resource.getInputStream();\n\t\t}\n\n\t\tpublic long getLastModified() {\n\t\t\ttry {\n\t\t\t\treturn this.resource.lastModified();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\nimport org.crsh.auth.AuthenticationPlugin;\nimport org.crsh.plugin.CRaSHPlugin;\nimport org.crsh.plugin.PluginContext;\nimport org.crsh.plugin.PluginDiscovery;\nimport org.crsh.plugin.PluginLifeCycle;\nimport org.crsh.plugin.PropertyDescriptor;\nimport org.crsh.plugin.ServiceLoaderDiscovery;\nimport org.crsh.vfs.FS;\nimport org.crsh.vfs.spi.AbstractFSDriver;\nimport org.crsh.vfs.spi.FSDriver;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.CrshShellAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.CrshShellProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.JaasAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.KeyAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.SimpleAuthenticationProperties;\nimport org.springframework.boot.actuate.autoconfigure.ShellProperties.SpringAuthenticationProperties;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.SpringVersion;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.security.access.AccessDecisionManager;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell\n * into a Spring Boot enabled application. By default a SSH daemon is started on port\n * 2000. If the CRaSH Telnet plugin is available on the classpath, Telnet daemon will be\n * launched on port 5000.\n * <p>\n * The default shell authentication method uses a username and password combination. If no\n * configuration is provided the default username is \'user\' and the password will be\n * printed to console during application startup. Those default values can be overridden\n * by using <code>shell.auth.simple.username</code> and\n * <code>shell.auth.simple.password</code>.\n * <p>\n * If a Spring Security {@link AuthenticationManager} is detected, this configuration will\n * create a {@link CRaSHPlugin} to forward shell authentication requests to Spring\n * Security. This authentication method will get enabled if <code>shell.auth</code> is set\n * to <code>spring</code> or if no explicit <code>shell.auth</code> is provided and a\n * {@link AuthenticationManager} is available. In the latter case shell access will be\n * restricted to users having roles that match those configured in\n * {@link ManagementServerProperties}. Required roles can be overridden by\n * <code>shell.auth.spring.roles</code>.\n * <p>\n * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in\n * the application context. Those beans will get auto detected during startup and\n * registered with the underlying shell infrastructure. To configure plugins and the CRaSH\n * infrastructure add beans of type {@link CrshShellProperties} to the application\n * context.\n * <p>\n * Additional shell commands can be implemented using the guide and documentation at <a\n * href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands\n * using the following classpath scanning pattern <code>classpath*:/commands/**</code>. To\n * add different locations or override the default use\n * <code>shell.command_path_patterns</code> in your application configuration.\n * \n * @author Christian Dupuis\n * @see ShellProperties\n */\n@Configuration\n@ConditionalOnClass({ PluginLifeCycle.class })\n@EnableConfigurationProperties({ ShellProperties.class })\n@AutoConfigureAfter({ SecurityAutoConfiguration.class,\n\t\tManagementSecurityAutoConfiguration.class })\npublic class CrshAutoConfiguration {\n\n\t@Autowired\n\tprivate ShellProperties properties;\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'jaas\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties jaasAuthenticationProperties() {\n\t\treturn new JaasAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'key\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties keyAuthenticationProperties() {\n\t\treturn new KeyAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'simple\'")\n\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\tpublic CrshShellAuthenticationProperties simpleAuthenticationProperties() {\n\t\treturn new SimpleAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n\tpublic PluginLifeCycle shellBootstrap() {\n\t\tCrshBootstrapBean bootstrapBean = new CrshBootstrapBean();\n\t\tbootstrapBean.setConfig(this.properties.asCrshShellConfig());\n\t\treturn bootstrapBean;\n\t}\n\n\t/**\n\t * Class to configure CRaSH to authenticate against Spring Security.\n\t */\n\t@Configuration\n\t@ConditionalOnBean({ AuthenticationManager.class })\n\t@AutoConfigureAfter(CrshAutoConfiguration.class)\n\tpublic static class AuthenticationManagerAdapterAutoConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Bean\n\t\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n\t\t\treturn new AuthenticationManagerAdapter();\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnExpression("\'${shell.auth:spring}\' == \'spring\'")\n\t\t@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class })\n\t\tpublic CrshShellAuthenticationProperties springAuthenticationProperties() {\n\t\t\t// In case no shell.auth property is provided fall back to Spring Security\n\t\t\t// based authentication and get role to access shell from\n\t\t\t// ManagementServerProperties.\n\t\t\t// In case shell.auth is set to spring and roles are configured using\n\t\t\t// shell.auth.spring.roles the below default role will be overridden by\n\t\t\t// ConfigurationProperties.\n\t\t\tSpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties();\n\t\t\tif (this.management != null) {\n\t\t\t\tauthenticationProperties.setRoles(new String[] { this.management\n\t\t\t\t\t\t.getSecurity().getRole() });\n\t\t\t}\n\t\t\treturn authenticationProperties;\n\t\t}\n\n\t}\n\n\t/**\n\t * Spring Bean used to bootstrap the CRaSH shell.\n\t */\n\tpublic static class CrshBootstrapBean extends PluginLifeCycle {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t@Autowired\n\t\tprivate Environment environment;\n\n\t\t@Autowired\n\t\tprivate ShellProperties properties;\n\n\t\t@Autowired\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\t@PreDestroy\n\t\tpublic void destroy() {\n\t\t\tstop();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() {\n\t\t\tFS commandFileSystem = createFileSystem(\n\t\t\t\t\tthis.properties.getCommandPathPatterns(),\n\t\t\t\t\tthis.properties.getDisabledCommands());\n\t\t\tFS configurationFileSystem = createFileSystem(\n\t\t\t\t\tthis.properties.getConfigPathPatterns(), new String[0]);\n\n\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(\n\t\t\t\t\tthis.resourceLoader.getClassLoader(), this.beanFactory,\n\t\t\t\t\tthis.properties.getDisabledPlugins());\n\n\t\t\tPluginContext context = new PluginContext(discovery,\n\t\t\t\t\tcreatePluginContextAttributes(), commandFileSystem,\n\t\t\t\t\tconfigurationFileSystem, this.resourceLoader.getClassLoader());\n\n\t\t\tcontext.refresh();\n\t\t\tstart(context);\n\t\t}\n\n\t\tprotected FS createFileSystem(String[] pathPatterns, String[] filterPatterns) {\n\t\t\tAssert.notNull(pathPatterns, "PathPatterns must not be null");\n\t\t\tAssert.notNull(filterPatterns, "FilterPatterns must not be null");\n\t\t\tFS fileSystem = new FS();\n\t\t\tfor (String pathPattern : pathPatterns) {\n\t\t\t\ttry {\n\t\t\t\t\tfileSystem.mount(new SimpleFileSystemDriver(new DirectoryHandle(\n\t\t\t\t\t\t\tpathPattern, this.resourceLoader, filterPatterns)));\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException("Failed to mount file system for \'"\n\t\t\t\t\t\t\t+ pathPattern + "\'", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fileSystem;\n\t\t}\n\n\t\tprotected Map<String, Object> createPluginContextAttributes() {\n\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage()\n\t\t\t\t\t.getImplementationVersion();\n\t\t\tif (bootVersion != null) {\n\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n\t\t\t}\n\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tattributes.put("spring.beanfactory", this.beanFactory);\n\t\t\t}\n\t\t\tif (this.environment != null) {\n\t\t\t\tattributes.put("spring.environment", this.environment);\n\t\t\t}\n\t\t\treturn attributes;\n\t\t}\n\n\t}\n\n\t/**\n\t * Adapts a Spring Security {@link AuthenticationManager} for use with CRaSH.\n\t */\n\t@SuppressWarnings("rawtypes")\n\tprivate static class AuthenticationManagerAdapter extends\n\t\t\tCRaSHPlugin<AuthenticationPlugin> implements AuthenticationPlugin<String> {\n\n\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor\n\t\t\t\t.create("auth.spring.roles", "ADMIN",\n\t\t\t\t\t\t"Comma separated list of roles required to access the shell");\n\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\n\t\t@Autowired(required = false)\n\t\tprivate AccessDecisionManager accessDecisionManager;\n\n\t\tprivate String[] roles = new String[] { "ADMIN" };\n\n\t\t@Override\n\t\tpublic boolean authenticate(String username, String password) throws Exception {\n\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username,\n\t\t\t\t\tpassword);\n\t\t\ttry {\n\t\t\t\t// Authenticate first to make sure credentials are valid\n\t\t\t\ttoken = this.authenticationManager.authenticate(token);\n\t\t\t}\n\t\t\tcatch (AuthenticationException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n\t\t\tif (this.accessDecisionManager != null && token.isAuthenticated()\n\t\t\t\t\t&& this.roles != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.accessDecisionManager.decide(token, this,\n\t\t\t\t\t\t\tSecurityConfig.createList(this.roles));\n\t\t\t\t}\n\t\t\t\tcatch (AccessDeniedException ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn token.isAuthenticated();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<String> getCredentialType() {\n\t\t\treturn String.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic AuthenticationPlugin<String> getImplementation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn "spring";\n\t\t}\n\n\t\t@Override\n\t\tpublic void init() {\n\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n\t\t\tif (rolesPropertyValue != null) {\n\t\t\t\tthis.roles = StringUtils\n\t\t\t\t\t\t.commaDelimitedListToStringArray(rolesPropertyValue);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n\t\t\treturn Arrays.<PropertyDescriptor<?>> asList(ROLES);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ServiceLoaderDiscovery} to expose {@link CRaSHPlugin} Beans from Spring and\n\t * deal with filtering disabled plugins.\n\t */\n\tprivate static class BeanFactoryFilteringPluginDiscovery extends\n\t\t\tServiceLoaderDiscovery {\n\n\t\tprivate final ListableBeanFactory beanFactory;\n\n\t\tprivate final String[] disabledPlugins;\n\n\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader,\n\t\t\t\tListableBeanFactory beanFactory, String[] disabledPlugins)\n\t\t\t\tthrows NullPointerException {\n\t\t\tsuper(classLoader);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.disabledPlugins = disabledPlugins;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings("rawtypes")\n\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n\n\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n\t\t\t\tif (isEnabled(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollection<CRaSHPlugin> pluginBeans = this.beanFactory.getBeansOfType(\n\t\t\t\t\tCRaSHPlugin.class).values();\n\t\t\tfor (CRaSHPlugin<?> pluginBean : pluginBeans) {\n\t\t\t\tif (isEnabled(pluginBean)) {\n\t\t\t\t\tplugins.add(pluginBean);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn plugins;\n\t\t}\n\n\t\tprotected boolean isEnabled(CRaSHPlugin<?> plugin) {\n\t\t\tAssert.notNull(plugin, "Plugin must not be null");\n\n\t\t\tif (ObjectUtils.isEmpty(this.disabledPlugins)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tSet<Class<?>> pluginClasses = ClassUtils.getAllInterfacesAsSet(plugin);\n\t\t\tpluginClasses.add(plugin.getClass());\n\n\t\t\tfor (Class<?> pluginClass : pluginClasses) {\n\t\t\t\tif (isEnabled(pluginClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean isEnabled(Class<?> pluginClass) {\n\t\t\tfor (String disabledPlugin : this.disabledPlugins) {\n\t\t\t\tif (ClassUtils.getShortName(pluginClass).equalsIgnoreCase(disabledPlugin)\n\t\t\t\t\t\t|| ClassUtils.getQualifiedName(pluginClass).equalsIgnoreCase(\n\t\t\t\t\t\t\t\tdisabledPlugin)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * {@link FSDriver} to wrap Spring\'s {@link Resource} abstraction to CRaSH.\n\t */\n\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n\n\t\tprivate final ResourceHandle root;\n\n\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n\t\t\tthis.root = handle;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle)\n\t\t\t\tthrows IOException {\n\t\t\tif (handle instanceof DirectoryHandle) {\n\t\t\t\treturn ((DirectoryHandle) handle).members();\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn ((FileHandle) handle).getLastModified();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n\t\t\treturn handle instanceof DirectoryHandle;\n\t\t}\n\n\t\t@Override\n\t\tpublic String name(ResourceHandle handle) throws IOException {\n\t\t\treturn handle.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream())\n\t\t\t\t\t\t.iterator();\n\t\t\t}\n\t\t\treturn Collections.<InputStream> emptyList().iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceHandle root() throws IOException {\n\t\t\treturn this.root;\n\t\t}\n\n\t}\n\n\t/**\n\t * Base for handles to Spring {@link Resource}s.\n\t */\n\tprivate abstract static class ResourceHandle {\n\n\t\tprivate final String name;\n\n\t\tpublic ResourceHandle(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a directory.\n\t */\n\tprivate static class DirectoryHandle extends ResourceHandle {\n\n\t\tprivate final ResourcePatternResolver resourceLoader;\n\n\t\tprivate final String[] filterPatterns;\n\n\t\tprivate final AntPathMatcher matcher = new AntPathMatcher();\n\n\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader,\n\t\t\t\tString[] filterPatterns) {\n\t\t\tsuper(name);\n\t\t\tthis.resourceLoader = resourceLoader;\n\t\t\tthis.filterPatterns = filterPatterns;\n\t\t}\n\n\t\tpublic List<ResourceHandle> members() throws IOException {\n\t\t\tResource[] resources = this.resourceLoader.getResources(getName());\n\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (!resource.getURL().getPath().endsWith("/") && !shouldFilter(resource)) {\n\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn files;\n\t\t}\n\n\t\tprivate boolean shouldFilter(Resource resource) {\n\t\t\tfor (String filterPattern : this.filterPatterns) {\n\t\t\t\tif (this.matcher.match(filterPattern, resource.getFilename())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a file backed by a Spring {@link Resource}.\n\t */\n\tprivate static class FileHandle extends ResourceHandle {\n\n\t\tprivate final Resource resource;\n\n\t\tpublic FileHandle(String name, Resource resource) {\n\t\t\tsuper(name);\n\t\t\tthis.resource = resource;\n\t\t}\n\n\t\tpublic InputStream openStream() throws IOException {\n\t\t\treturn this.resource.getInputStream();\n\t\t}\n\n\t\tpublic long getLastModified() {\n\t\t\ttry {\n\t\t\t\treturn this.resource.lastModified();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
