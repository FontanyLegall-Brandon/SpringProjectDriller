{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -60,6 +60,7 @@ import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\n  *\n  * @author Dave Syer\n  * @author Phillip Webb\n+ * @author Stephane Nicoll\n  */\n @Configuration\n @ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@@ -87,10 +88,10 @@ public class DataSourceAutoConfiguration {\n \t\t}\n \t}\n \n-\t@Conditional(DataSourceAutoConfiguration.EmbeddedDataSourceCondition.class)\n+\t@Conditional(EmbeddedDatabaseCondition.class)\n \t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n \t@Import(EmbeddedDataSourceConfiguration.class)\n-\tprotected static class EmbeddedConfiguration {\n+\tprotected static class EmbeddedDatabaseConfiguration {\n \n \t}\n \n@@ -105,9 +106,9 @@ public class DataSourceAutoConfiguration {\n \n \t}\n \n-\t@Conditional(DataSourceAutoConfiguration.NonEmbeddedDataSourceCondition.class)\n+\t@Conditional(PooledDataSourceCondition.class)\n \t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n-\tprotected static class NonEmbeddedConfiguration {\n+\tprotected static class PooledDataSourceConfiguration {\n \n \t\t@Autowired\n \t\tprivate DataSourceProperties properties;\n@@ -171,10 +172,9 @@ public class DataSourceAutoConfiguration {\n \t}\n \n \t/**\n-\t * {@link Condition} to test is a supported non-embedded {@link DataSource} type is\n-\t * available.\n+\t * {@link Condition} to test if a supported connection pool is available.\n \t */\n-\tstatic class NonEmbeddedDataSourceCondition extends SpringBootCondition {\n+\tstatic class PooledDataSourceCondition extends SpringBootCondition {\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n@@ -200,17 +200,20 @@ public class DataSourceAutoConfiguration {\n \n \t/**\n \t * {@link Condition} to detect when an embedded {@link DataSource} type can be used.\n+\t * <p>\n+\t * If a pooled {@link DataSource} is available, it will always be preferred to\n+\t * an {@code EmbeddedDatabase}.\n \t */\n-\tstatic class EmbeddedDataSourceCondition extends SpringBootCondition {\n+\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n \n-\t\tprivate final SpringBootCondition nonEmbedded = new NonEmbeddedDataSourceCondition();\n+\t\tprivate final SpringBootCondition pooledCondition = new PooledDataSourceCondition();\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n \t\t\t\tAnnotatedTypeMetadata metadata) {\n-\t\t\tif (anyMatches(context, metadata, this.nonEmbedded)) {\n+\t\t\tif (anyMatches(context, metadata, this.pooledCondition)) {\n \t\t\t\treturn ConditionOutcome\n-\t\t\t\t\t\t.noMatch("existing non-embedded database detected");\n+\t\t\t\t\t\t.noMatch("supported DataSource class found");\n \t\t\t}\n \t\t\tEmbeddedDatabaseType type = EmbeddedDatabaseConnection\n \t\t\t\t\t.get(context.getClassLoader()).getType();\n@@ -229,9 +232,9 @@ public class DataSourceAutoConfiguration {\n \t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n \tstatic class DataSourceAvailableCondition extends SpringBootCondition {\n \n-\t\tprivate final SpringBootCondition nonEmbedded = new NonEmbeddedDataSourceCondition();\n+\t\tprivate final SpringBootCondition pooledCondition = new PooledDataSourceCondition();\n \n-\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDataSourceCondition();\n+\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDatabaseCondition();\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n@@ -241,7 +244,7 @@ public class DataSourceAutoConfiguration {\n \t\t\t\treturn ConditionOutcome\n \t\t\t\t\t\t.match("existing bean configured database detected");\n \t\t\t}\n-\t\t\tif (anyMatches(context, metadata, this.nonEmbedded, this.embeddedCondition)) {\n+\t\t\tif (anyMatches(context, metadata, this.pooledCondition, this.embeddedCondition)) {\n \t\t\t\treturn ConditionOutcome.match("existing auto database detected");\n \t\t\t}\n \t\t\treturn ConditionOutcome.noMatch("no existing bean configured database");\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jdbc;\n\nimport java.sql.SQLException;\n\nimport javax.sql.DataSource;\nimport javax.sql.XADataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.tomcat.jdbc.pool.DataSourceProxy;\n\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerPostProcessor.Registrar;\nimport org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for {@link DataSource}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n * @author Stephane Nicoll\n */\n@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(DataSourceAutoConfiguration.class);\n\n\t/**\n\t * Determines if the {@code dataSource} being used by Spring was created from\n\t * {@link EmbeddedDataSourceConfiguration}.\n\t * @param beanFactory the bean factory\n\t * @return true if the data source was auto-configured.\n\t */\n\tpublic static boolean containsAutoConfiguredDataSource(\n\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\ttry {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition("dataSource");\n\t\t\treturn EmbeddedDataSourceConfiguration.class.getName()\n\t\t\t\t\t.equals(beanDefinition.getFactoryBeanName());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Conditional(EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedDatabaseConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(DataSourceInitializer.class)\n\tprotected static class DataSourceInitializerConfiguration {\n\n\t\t@Bean\n\t\tpublic DataSourceInitializer dataSourceInitializer() {\n\t\t\treturn new DataSourceInitializer();\n\t\t}\n\n\t}\n\n\t@Conditional(PooledDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\tprotected static class PooledDataSourceConfiguration {\n\n\t\t@Autowired\n\t\tprivate DataSourceProperties properties;\n\n\t\t@Bean\n\t\t@ConfigurationProperties(prefix = DataSourceProperties.PREFIX)\n\t\tpublic DataSource dataSource() {\n\t\t\tDataSourceBuilder factory = DataSourceBuilder\n\t\t\t\t\t.create(this.properties.getClassLoader())\n\t\t\t\t\t.driverClassName(this.properties.determineDriverClassName())\n\t\t\t\t\t.url(this.properties.determineUrl()).username(this.properties.determineUsername())\n\t\t\t\t\t.password(this.properties.determinePassword());\n\t\t\tif (this.properties.getType() != null) {\n\t\t\t\tfactory.type(this.properties.getType());\n\t\t\t}\n\t\t\treturn factory.build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)\n\tprotected static class JdbcTemplateConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate DataSource dataSource;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(JdbcOperations.class)\n\t\tpublic JdbcTemplate jdbcTemplate() {\n\t\t\treturn new JdbcTemplate(this.dataSource);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\n\t\tpublic NamedParameterJdbcTemplate namedParameterJdbcTemplate() {\n\t\t\treturn new NamedParameterJdbcTemplate(this.dataSource);\n\t\t}\n\t}\n\n\t@Configuration\n\t@ConditionalOnProperty(prefix = "spring.datasource", name = "jmx-enabled")\n\t@ConditionalOnClass(name = "org.apache.tomcat.jdbc.pool.DataSourceProxy")\n\t@Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)\n\t@ConditionalOnMissingBean(name = "dataSourceMBean")\n\tprotected static class TomcatDataSourceJmxConfiguration {\n\n\t\t@Bean\n\t\tpublic Object dataSourceMBean(DataSource dataSource) {\n\t\t\tif (dataSource instanceof DataSourceProxy) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ((DataSourceProxy) dataSource).createPool().getJmxPool();\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\tlogger.warn("Cannot expose DataSource to JMX (could not connect)");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to test if a supported connection pool is available.\n\t */\n\tstatic class PooledDataSourceCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (getDataSourceClassLoader(context) != null) {\n\t\t\t\treturn ConditionOutcome.match("supported DataSource class found");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("missing supported DataSource");\n\t\t}\n\n\t\t/**\n\t\t * Returns the class loader for the {@link DataSource} class. Used to ensure that\n\t\t * the driver class can actually be loaded by the data source.\n\t\t * @param context the condition context\n\t\t * @return the class loader\n\t\t */\n\t\tprivate ClassLoader getDataSourceClassLoader(ConditionContext context) {\n\t\t\tClass<?> dataSourceClass = new DataSourceBuilder(context.getClassLoader())\n\t\t\t\t\t.findType();\n\t\t\treturn (dataSourceClass == null ? null : dataSourceClass.getClassLoader());\n\t\t}\n\t}\n\n\t/**\n\t * {@link Condition} to detect when an embedded {@link DataSource} type can be used.\n\t * <p>\n\t * If a pooled {@link DataSource} is available, it will always be preferred to\n\t * an {@code EmbeddedDatabase}.\n\t */\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition pooledCondition = new PooledDataSourceCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (anyMatches(context, metadata, this.pooledCondition)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch("supported DataSource class found");\n\t\t\t}\n\t\t\tEmbeddedDatabaseType type = EmbeddedDatabaseConnection\n\t\t\t\t\t.get(context.getClassLoader()).getType();\n\t\t\tif (type == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no embedded database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.match("embedded database " + type + " detected");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a {@link DataSource} is available (either because\n\t * the user provided one or because one will be auto-configured).\n\t */\n\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n\tstatic class DataSourceAvailableCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition pooledCondition = new PooledDataSourceCondition();\n\n\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDatabaseCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (hasBean(context, DataSource.class)\n\t\t\t\t\t|| hasBean(context, XADataSource.class)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.match("existing bean configured database detected");\n\t\t\t}\n\t\t\tif (anyMatches(context, metadata, this.pooledCondition, this.embeddedCondition)) {\n\t\t\t\treturn ConditionOutcome.match("existing auto database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("no existing bean configured database");\n\t\t}\n\n\t\tprivate boolean hasBean(ConditionContext context, Class<?> type) {\n\t\t\treturn BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tcontext.getBeanFactory(), type, true, false).length > 0;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jdbc;\n\nimport java.sql.SQLException;\n\nimport javax.sql.DataSource;\nimport javax.sql.XADataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.tomcat.jdbc.pool.DataSourceProxy;\n\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerPostProcessor.Registrar;\nimport org.springframework.boot.autoconfigure.jdbc.metadata.DataSourcePoolMetadataProvidersConfiguration;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for {@link DataSource}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n */\n@Configuration\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })\npublic class DataSourceAutoConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(DataSourceAutoConfiguration.class);\n\n\t/**\n\t * Determines if the {@code dataSource} being used by Spring was created from\n\t * {@link EmbeddedDataSourceConfiguration}.\n\t * @param beanFactory the bean factory\n\t * @return true if the data source was auto-configured.\n\t */\n\tpublic static boolean containsAutoConfiguredDataSource(\n\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\ttry {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition("dataSource");\n\t\t\treturn EmbeddedDataSourceConfiguration.class.getName()\n\t\t\t\t\t.equals(beanDefinition.getFactoryBeanName());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.EmbeddedDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(DataSourceInitializer.class)\n\tprotected static class DataSourceInitializerConfiguration {\n\n\t\t@Bean\n\t\tpublic DataSourceInitializer dataSourceInitializer() {\n\t\t\treturn new DataSourceInitializer();\n\t\t}\n\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.NonEmbeddedDataSourceCondition.class)\n\t@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })\n\tprotected static class NonEmbeddedConfiguration {\n\n\t\t@Autowired\n\t\tprivate DataSourceProperties properties;\n\n\t\t@Bean\n\t\t@ConfigurationProperties(prefix = DataSourceProperties.PREFIX)\n\t\tpublic DataSource dataSource() {\n\t\t\tDataSourceBuilder factory = DataSourceBuilder\n\t\t\t\t\t.create(this.properties.getClassLoader())\n\t\t\t\t\t.driverClassName(this.properties.determineDriverClassName())\n\t\t\t\t\t.url(this.properties.determineUrl()).username(this.properties.determineUsername())\n\t\t\t\t\t.password(this.properties.determinePassword());\n\t\t\tif (this.properties.getType() != null) {\n\t\t\t\tfactory.type(this.properties.getType());\n\t\t\t}\n\t\t\treturn factory.build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)\n\tprotected static class JdbcTemplateConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate DataSource dataSource;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(JdbcOperations.class)\n\t\tpublic JdbcTemplate jdbcTemplate() {\n\t\t\treturn new JdbcTemplate(this.dataSource);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\n\t\tpublic NamedParameterJdbcTemplate namedParameterJdbcTemplate() {\n\t\t\treturn new NamedParameterJdbcTemplate(this.dataSource);\n\t\t}\n\t}\n\n\t@Configuration\n\t@ConditionalOnProperty(prefix = "spring.datasource", name = "jmx-enabled")\n\t@ConditionalOnClass(name = "org.apache.tomcat.jdbc.pool.DataSourceProxy")\n\t@Conditional(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)\n\t@ConditionalOnMissingBean(name = "dataSourceMBean")\n\tprotected static class TomcatDataSourceJmxConfiguration {\n\n\t\t@Bean\n\t\tpublic Object dataSourceMBean(DataSource dataSource) {\n\t\t\tif (dataSource instanceof DataSourceProxy) {\n\t\t\t\ttry {\n\t\t\t\t\treturn ((DataSourceProxy) dataSource).createPool().getJmxPool();\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\tlogger.warn("Cannot expose DataSource to JMX (could not connect)");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to test is a supported non-embedded {@link DataSource} type is\n\t * available.\n\t */\n\tstatic class NonEmbeddedDataSourceCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (getDataSourceClassLoader(context) != null) {\n\t\t\t\treturn ConditionOutcome.match("supported DataSource class found");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("missing supported DataSource");\n\t\t}\n\n\t\t/**\n\t\t * Returns the class loader for the {@link DataSource} class. Used to ensure that\n\t\t * the driver class can actually be loaded by the data source.\n\t\t * @param context the condition context\n\t\t * @return the class loader\n\t\t */\n\t\tprivate ClassLoader getDataSourceClassLoader(ConditionContext context) {\n\t\t\tClass<?> dataSourceClass = new DataSourceBuilder(context.getClassLoader())\n\t\t\t\t\t.findType();\n\t\t\treturn (dataSourceClass == null ? null : dataSourceClass.getClassLoader());\n\t\t}\n\t}\n\n\t/**\n\t * {@link Condition} to detect when an embedded {@link DataSource} type can be used.\n\t */\n\tstatic class EmbeddedDataSourceCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition nonEmbedded = new NonEmbeddedDataSourceCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (anyMatches(context, metadata, this.nonEmbedded)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch("existing non-embedded database detected");\n\t\t\t}\n\t\t\tEmbeddedDatabaseType type = EmbeddedDatabaseConnection\n\t\t\t\t\t.get(context.getClassLoader()).getType();\n\t\t\tif (type == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no embedded database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.match("embedded database " + type + " detected");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a {@link DataSource} is available (either because\n\t * the user provided one or because one will be auto-configured).\n\t */\n\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n\tstatic class DataSourceAvailableCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition nonEmbedded = new NonEmbeddedDataSourceCondition();\n\n\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDataSourceCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (hasBean(context, DataSource.class)\n\t\t\t\t\t|| hasBean(context, XADataSource.class)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.match("existing bean configured database detected");\n\t\t\t}\n\t\t\tif (anyMatches(context, metadata, this.nonEmbedded, this.embeddedCondition)) {\n\t\t\t\treturn ConditionOutcome.match("existing auto database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("no existing bean configured database");\n\t\t}\n\n\t\tprivate boolean hasBean(ConditionContext context, Class<?> type) {\n\t\t\treturn BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tcontext.getBeanFactory(), type, true, false).length > 0;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
