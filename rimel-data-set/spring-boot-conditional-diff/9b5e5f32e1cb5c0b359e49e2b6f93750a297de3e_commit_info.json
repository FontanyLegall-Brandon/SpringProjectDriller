{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/client/OAuth2RestOperationsConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/client/OAuth2RestOperationsConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -65,7 +65,6 @@ import org.springframework.util.StringUtils;\n  */\n @Configuration\n @ConditionalOnClass(EnableOAuth2Client.class)\n-@Conditional(OAuth2ClientIdCondition.class)\n public class OAuth2RestOperationsConfiguration {\n \n \t@Configuration\n@@ -89,7 +88,7 @@ public class OAuth2RestOperationsConfiguration {\n \n \t@Configuration\n \t@ConditionalOnBean(OAuth2ClientConfiguration.class)\n-\t@Conditional(NoClientCredentialsCondition.class)\n+\t@Conditional({OAuth2ClientIdCondition.class, NoClientCredentialsCondition.class})\n \t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n \tprotected static class SessionScopedConfiguration {\n \n@@ -128,7 +127,7 @@ public class OAuth2RestOperationsConfiguration {\n \t// refresh tokens you need to @EnableOAuth2Client\n \t@Configuration\n \t@ConditionalOnMissingBean(OAuth2ClientConfiguration.class)\n-\t@Conditional(NoClientCredentialsCondition.class)\n+\t@Conditional({ OAuth2ClientIdCondition.class, NoClientCredentialsCondition.class })\n \t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n \tprotected static class RequestScopedConfiguration {\n \n', 'source_code': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security.oauth2.client;\n\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.condition.AnyNestedCondition;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnNotWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.NoneNestedConditions;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2RestOperationsConfiguration.OAuth2ClientIdCondition;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.context.annotation.ScopedProxyMode;\nimport org.springframework.core.env.PropertyResolver;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.oauth2.client.DefaultOAuth2ClientContext;\nimport org.springframework.security.oauth2.client.filter.OAuth2ClientContextFilter;\nimport org.springframework.security.oauth2.client.token.AccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.DefaultAccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.grant.client.ClientCredentialsResourceDetails;\nimport org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableOAuth2Client;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.OAuth2ClientConfiguration;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationDetails;\nimport org.springframework.util.StringUtils;\n\n/**\n * Configuration for OAuth2 Single Sign On REST operations.\n *\n * @author Dave Syer\n * @since 1.3.0\n */\n@Configuration\n@ConditionalOnClass(EnableOAuth2Client.class)\npublic class OAuth2RestOperationsConfiguration {\n\n\t@Configuration\n\t@Conditional(ClientCredentialsCondition.class)\n\tprotected static class SingletonScopedConfiguration {\n\n\t\t@Bean\n\t\t@ConfigurationProperties(prefix = "security.oauth2.client")\n\t\t@Primary\n\t\tpublic ClientCredentialsResourceDetails oauth2RemoteResource() {\n\t\t\tClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails();\n\t\t\treturn details;\n\t\t}\n\n\t\t@Bean\n\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\treturn new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest());\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnBean(OAuth2ClientConfiguration.class)\n\t@Conditional({OAuth2ClientIdCondition.class, NoClientCredentialsCondition.class})\n\t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n\tprotected static class SessionScopedConfiguration {\n\n\t\t@Bean\n\t\tpublic FilterRegistrationBean oauth2ClientFilterRegistration(\n\t\t\t\tOAuth2ClientContextFilter filter, SecurityProperties security) {\n\t\t\tFilterRegistrationBean registration = new FilterRegistrationBean();\n\t\t\tregistration.setFilter(filter);\n\t\t\tregistration.setOrder(security.getFilterOrder() - 10);\n\t\t\treturn registration;\n\t\t}\n\n\t\t@Configuration\n\t\tprotected static class ClientContextConfiguration {\n\n\t\t\tprivate final AccessTokenRequest accessTokenRequest;\n\n\t\t\tpublic ClientContextConfiguration(\n\t\t\t\t\t@Qualifier("accessTokenRequest") ObjectProvider<AccessTokenRequest> accessTokenRequest) {\n\t\t\t\tthis.accessTokenRequest = accessTokenRequest.getIfAvailable();\n\t\t\t}\n\n\t\t\t@Bean\n\t\t\t@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)\n\t\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\t\treturn new DefaultOAuth2ClientContext(this.accessTokenRequest);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// When the authentication is per cookie but the stored token is an oauth2 one, we can\n\t// pass that on to a client that wants to call downstream. We don\'t even need an\n\t// OAuth2ClientContextFilter until we need to refresh the access token. To handle\n\t// refresh tokens you need to @EnableOAuth2Client\n\t@Configuration\n\t@ConditionalOnMissingBean(OAuth2ClientConfiguration.class)\n\t@Conditional({ OAuth2ClientIdCondition.class, NoClientCredentialsCondition.class })\n\t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n\tprotected static class RequestScopedConfiguration {\n\n\t\t@Bean\n\t\t@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)\n\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\tDefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext(\n\t\t\t\t\tnew DefaultAccessTokenRequest());\n\t\t\tAuthentication principal = SecurityContextHolder.getContext()\n\t\t\t\t\t.getAuthentication();\n\t\t\tif (principal instanceof OAuth2Authentication) {\n\t\t\t\tOAuth2Authentication authentication = (OAuth2Authentication) principal;\n\t\t\t\tObject details = authentication.getDetails();\n\t\t\t\tif (details instanceof OAuth2AuthenticationDetails) {\n\t\t\t\t\tOAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details;\n\t\t\t\t\tString token = oauthsDetails.getTokenValue();\n\t\t\t\t\tcontext.setAccessToken(new DefaultOAuth2AccessToken(token));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check if a {@code security.oauth2.client.client-id} is specified.\n\t */\n\tstatic class OAuth2ClientIdCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tPropertyResolver resolver = new RelaxedPropertyResolver(\n\t\t\t\t\tcontext.getEnvironment(), "security.oauth2.client.");\n\t\t\tString clientId = resolver.getProperty("client-id");\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("OAuth Client ID");\n\t\t\tif (StringUtils.hasLength(clientId)) {\n\t\t\t\treturn ConditionOutcome.match(message\n\t\t\t\t\t\t.foundExactly("security.oauth2.client.client-id property"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message\n\t\t\t\t\t.didNotFind("security.oauth2.client.client-id property").atAll());\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check for no client credentials.\n\t */\n\tstatic class NoClientCredentialsCondition extends NoneNestedConditions {\n\n\t\tNoClientCredentialsCondition() {\n\t\t\tsuper(ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t}\n\n\t\t@Conditional(ClientCredentialsCondition.class)\n\t\tstatic class ClientCredentialsActivated {\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check for client credentials.\n\t */\n\tstatic class ClientCredentialsCondition extends AnyNestedCondition {\n\n\t\tClientCredentialsCondition() {\n\t\t\tsuper(ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t}\n\n\t\t@ConditionalOnProperty(prefix = "security.oauth2.client", name = "grant-type", havingValue = "client_credentials", matchIfMissing = false)\n\t\tstatic class ClientCredentialsConfigured {\n\t\t}\n\n\t\t@ConditionalOnNotWebApplication\n\t\tstatic class NoWebApplication {\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security.oauth2.client;\n\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.condition.AnyNestedCondition;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnNotWebApplication;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.NoneNestedConditions;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.boot.autoconfigure.security.oauth2.client.OAuth2RestOperationsConfiguration.OAuth2ClientIdCondition;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.context.annotation.ScopedProxyMode;\nimport org.springframework.core.env.PropertyResolver;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.oauth2.client.DefaultOAuth2ClientContext;\nimport org.springframework.security.oauth2.client.filter.OAuth2ClientContextFilter;\nimport org.springframework.security.oauth2.client.token.AccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.DefaultAccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.grant.client.ClientCredentialsResourceDetails;\nimport org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.EnableOAuth2Client;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.OAuth2ClientConfiguration;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationDetails;\nimport org.springframework.util.StringUtils;\n\n/**\n * Configuration for OAuth2 Single Sign On REST operations.\n *\n * @author Dave Syer\n * @since 1.3.0\n */\n@Configuration\n@ConditionalOnClass(EnableOAuth2Client.class)\n@Conditional(OAuth2ClientIdCondition.class)\npublic class OAuth2RestOperationsConfiguration {\n\n\t@Configuration\n\t@Conditional(ClientCredentialsCondition.class)\n\tprotected static class SingletonScopedConfiguration {\n\n\t\t@Bean\n\t\t@ConfigurationProperties(prefix = "security.oauth2.client")\n\t\t@Primary\n\t\tpublic ClientCredentialsResourceDetails oauth2RemoteResource() {\n\t\t\tClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails();\n\t\t\treturn details;\n\t\t}\n\n\t\t@Bean\n\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\treturn new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest());\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnBean(OAuth2ClientConfiguration.class)\n\t@Conditional(NoClientCredentialsCondition.class)\n\t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n\tprotected static class SessionScopedConfiguration {\n\n\t\t@Bean\n\t\tpublic FilterRegistrationBean oauth2ClientFilterRegistration(\n\t\t\t\tOAuth2ClientContextFilter filter, SecurityProperties security) {\n\t\t\tFilterRegistrationBean registration = new FilterRegistrationBean();\n\t\t\tregistration.setFilter(filter);\n\t\t\tregistration.setOrder(security.getFilterOrder() - 10);\n\t\t\treturn registration;\n\t\t}\n\n\t\t@Configuration\n\t\tprotected static class ClientContextConfiguration {\n\n\t\t\tprivate final AccessTokenRequest accessTokenRequest;\n\n\t\t\tpublic ClientContextConfiguration(\n\t\t\t\t\t@Qualifier("accessTokenRequest") ObjectProvider<AccessTokenRequest> accessTokenRequest) {\n\t\t\t\tthis.accessTokenRequest = accessTokenRequest.getIfAvailable();\n\t\t\t}\n\n\t\t\t@Bean\n\t\t\t@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)\n\t\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\t\treturn new DefaultOAuth2ClientContext(this.accessTokenRequest);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// When the authentication is per cookie but the stored token is an oauth2 one, we can\n\t// pass that on to a client that wants to call downstream. We don\'t even need an\n\t// OAuth2ClientContextFilter until we need to refresh the access token. To handle\n\t// refresh tokens you need to @EnableOAuth2Client\n\t@Configuration\n\t@ConditionalOnMissingBean(OAuth2ClientConfiguration.class)\n\t@Conditional(NoClientCredentialsCondition.class)\n\t@Import(OAuth2ProtectedResourceDetailsConfiguration.class)\n\tprotected static class RequestScopedConfiguration {\n\n\t\t@Bean\n\t\t@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)\n\t\tpublic DefaultOAuth2ClientContext oauth2ClientContext() {\n\t\t\tDefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext(\n\t\t\t\t\tnew DefaultAccessTokenRequest());\n\t\t\tAuthentication principal = SecurityContextHolder.getContext()\n\t\t\t\t\t.getAuthentication();\n\t\t\tif (principal instanceof OAuth2Authentication) {\n\t\t\t\tOAuth2Authentication authentication = (OAuth2Authentication) principal;\n\t\t\t\tObject details = authentication.getDetails();\n\t\t\t\tif (details instanceof OAuth2AuthenticationDetails) {\n\t\t\t\t\tOAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details;\n\t\t\t\t\tString token = oauthsDetails.getTokenValue();\n\t\t\t\t\tcontext.setAccessToken(new DefaultOAuth2AccessToken(token));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check if a {@code security.oauth2.client.client-id} is specified.\n\t */\n\tstatic class OAuth2ClientIdCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tPropertyResolver resolver = new RelaxedPropertyResolver(\n\t\t\t\t\tcontext.getEnvironment(), "security.oauth2.client.");\n\t\t\tString clientId = resolver.getProperty("client-id");\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("OAuth Client ID");\n\t\t\tif (StringUtils.hasLength(clientId)) {\n\t\t\t\treturn ConditionOutcome.match(message\n\t\t\t\t\t\t.foundExactly("security.oauth2.client.client-id property"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message\n\t\t\t\t\t.didNotFind("security.oauth2.client.client-id property").atAll());\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check for no client credentials.\n\t */\n\tstatic class NoClientCredentialsCondition extends NoneNestedConditions {\n\n\t\tNoClientCredentialsCondition() {\n\t\t\tsuper(ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t}\n\n\t\t@Conditional(ClientCredentialsCondition.class)\n\t\tstatic class ClientCredentialsActivated {\n\t\t}\n\n\t}\n\n\t/**\n\t * Condition to check for client credentials.\n\t */\n\tstatic class ClientCredentialsCondition extends AnyNestedCondition {\n\n\t\tClientCredentialsCondition() {\n\t\t\tsuper(ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t}\n\n\t\t@ConditionalOnProperty(prefix = "security.oauth2.client", name = "grant-type", havingValue = "client_credentials", matchIfMissing = false)\n\t\tstatic class ClientCredentialsConfigured {\n\t\t}\n\n\t\t@ConditionalOnNotWebApplication\n\t\tstatic class NoWebApplication {\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
