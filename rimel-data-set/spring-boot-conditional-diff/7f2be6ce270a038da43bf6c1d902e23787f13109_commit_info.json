{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -33,6 +33,8 @@ import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.ListableBeanFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnJava;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnJava.JavaVersion;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.boot.context.properties.EnableConfigurationProperties;\n import org.springframework.context.ApplicationContext;\n@@ -44,12 +46,14 @@ import org.springframework.util.Assert;\n import org.springframework.util.ClassUtils;\n import org.springframework.util.ReflectionUtils;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.databind.Module;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.datatype.joda.cfg.JacksonJodaDateFormat;\n import com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\n+import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n \n /**\n  * Auto configuration for Jackson. The following auto-configuration will get applied:\n@@ -129,6 +133,19 @@ public class JacksonAutoConfiguration {\n \n \t}\n \n+\t@Configuration\n+\t@ConditionalOnJava(JavaVersion.EIGHT)\n+\t@ConditionalOnClass(ParameterNamesModule.class)\n+\tstatic class ParameterNamesModuleConfiguration {\n+\n+\t\t@Bean\n+\t\t@ConditionalOnMissingBean(ParameterNamesModule.class)\n+\t\tpublic ParameterNamesModule parametersNameModule() {\n+\t\t\treturn new ParameterNamesModule(JsonCreator.Mode.PROPERTIES);\n+\t\t}\n+\n+\t}\n+\n \t@Configuration\n \t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n \t@EnableConfigurationProperties(JacksonProperties.class)\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.joda.time.DateTime;\nimport org.joda.time.format.DateTimeFormat;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava.JavaVersion;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport com.fasterxml.jackson.datatype.joda.cfg.JacksonJodaDateFormat;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @author Johannes Stelzer\n * @since 1.1.0\n */\n@Configuration\n@ConditionalOnClass(ObjectMapper.class)\npublic class JacksonAutoConfiguration {\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(ObjectMapper.class)\n\t\tpublic ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class,\n\t\t\tDateTimeSerializer.class, JacksonJodaDateFormat.class })\n\tstatic class JodaDateTimeJacksonConfiguration {\n\n\t\tprivate final Log log = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Bean\n\t\tpublic SimpleModule jodaDateTimeSerializationModule() {\n\t\t\tSimpleModule module = new SimpleModule();\n\t\t\tJacksonJodaDateFormat jacksonJodaFormat = getJacksonJodaDateFormat();\n\t\t\tif (jacksonJodaFormat != null) {\n\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(\n\t\t\t\t\t\tjacksonJodaFormat));\n\t\t\t}\n\t\t\treturn module;\n\t\t}\n\n\t\tprivate JacksonJodaDateFormat getJacksonJodaDateFormat() {\n\t\t\tif (this.jacksonProperties.getJodaDateTimeFormat() != null) {\n\t\t\t\treturn new JacksonJodaDateFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\tthis.jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n\t\t\t}\n\t\t\tif (this.jacksonProperties.getDateFormat() != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn new JacksonJodaDateFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\t\tthis.jacksonProperties.getDateFormat()).withZoneUTC());\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (this.log.isWarnEnabled()) {\n\t\t\t\t\t\tthis.log.warn("spring.jackson.date-format could not be used to "\n\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as "\n\t\t\t\t\t\t\t\t+ "well.");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnJava(JavaVersion.EIGHT)\n\t@ConditionalOnClass(ParameterNamesModule.class)\n\tstatic class ParameterNamesModuleConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(ParameterNamesModule.class)\n\t\tpublic ParameterNamesModule parametersNameModule() {\n\t\t\treturn new ParameterNamesModule(JsonCreator.Mode.PROPERTIES);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\t@EnableConfigurationProperties(JacksonProperties.class)\n\tstatic class JacksonObjectMapperBuilderConfiguration {\n\n\t\t@Autowired\n\t\tprivate ApplicationContext applicationContext;\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(Jackson2ObjectMapperBuilder.class)\n\t\tpublic Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder() {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\tif (this.jacksonProperties.getSerializationInclusion() != null) {\n\t\t\t\tbuilder.serializationInclusion(this.jacksonProperties\n\t\t\t\t\t\t.getSerializationInclusion());\n\t\t\t}\n\t\t\tif (this.jacksonProperties.getTimeZone() != null) {\n\t\t\t\tbuilder.timeZone(this.jacksonProperties.getTimeZone());\n\t\t\t}\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\tconfigureDateFormat(builder);\n\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\tconfigureModules(builder);\n\t\t\tconfigureLocale(builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tMap<?, Boolean> features) {\n\t\t\tfor (Entry<?, Boolean> entry : features.entrySet()) {\n\t\t\t\tif (entry.getValue() != null && entry.getValue()) {\n\t\t\t\t\tbuilder.featuresToEnable(entry.getKey());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.featuresToDisable(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t// pattern string value\n\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\tif (dateFormat != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils\n\t\t\t\t\t\t\t.instantiateClass(dateFormatClass));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tbuilder.dateFormat(new SimpleDateFormat(dateFormat));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t// names in PropertyNamingStrategy which hold default provided implementations\n\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\tif (strategy != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder,\n\t\t\t\t\t\t\tClassUtils.forName(strategy, null));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyClass(\n\t\t\t\tJackson2ObjectMapperBuilder builder, Class<?> propertyNamingStrategyClass) {\n\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) BeanUtils\n\t\t\t\t\t.instantiateClass(propertyNamingStrategyClass));\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyField(\n\t\t\t\tJackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t// that may be added by Jackson in the future)\n\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class,\n\t\t\t\t\tfieldName, PropertyNamingStrategy.class);\n\t\t\tAssert.notNull(field, "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\ttry {\n\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext,\n\t\t\t\t\tModule.class);\n\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[moduleBeans.size()]));\n\t\t}\n\n\t\tprivate void configureLocale(Jackson2ObjectMapperBuilder builder) {\n\t\t\tLocale locale = this.jacksonProperties.getLocale();\n\t\t\tif (locale != null) {\n\t\t\t\tbuilder.locale(locale);\n\t\t\t}\n\t\t}\n\n\t\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory,\n\t\t\t\tClass<T> type) {\n\t\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type)\n\t\t\t\t\t.values();\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.joda.time.DateTime;\nimport org.joda.time.format.DateTimeFormat;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport com.fasterxml.jackson.datatype.joda.cfg.JacksonJodaDateFormat;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @author Johannes Stelzer\n * @since 1.1.0\n */\n@Configuration\n@ConditionalOnClass(ObjectMapper.class)\npublic class JacksonAutoConfiguration {\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(ObjectMapper.class)\n\t\tpublic ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class,\n\t\t\tDateTimeSerializer.class, JacksonJodaDateFormat.class })\n\tstatic class JodaDateTimeJacksonConfiguration {\n\n\t\tprivate final Log log = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Bean\n\t\tpublic SimpleModule jodaDateTimeSerializationModule() {\n\t\t\tSimpleModule module = new SimpleModule();\n\t\t\tJacksonJodaDateFormat jacksonJodaFormat = getJacksonJodaDateFormat();\n\t\t\tif (jacksonJodaFormat != null) {\n\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(\n\t\t\t\t\t\tjacksonJodaFormat));\n\t\t\t}\n\t\t\treturn module;\n\t\t}\n\n\t\tprivate JacksonJodaDateFormat getJacksonJodaDateFormat() {\n\t\t\tif (this.jacksonProperties.getJodaDateTimeFormat() != null) {\n\t\t\t\treturn new JacksonJodaDateFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\tthis.jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n\t\t\t}\n\t\t\tif (this.jacksonProperties.getDateFormat() != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn new JacksonJodaDateFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\t\tthis.jacksonProperties.getDateFormat()).withZoneUTC());\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (this.log.isWarnEnabled()) {\n\t\t\t\t\t\tthis.log.warn("spring.jackson.date-format could not be used to "\n\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as "\n\t\t\t\t\t\t\t\t+ "well.");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\t@EnableConfigurationProperties(JacksonProperties.class)\n\tstatic class JacksonObjectMapperBuilderConfiguration {\n\n\t\t@Autowired\n\t\tprivate ApplicationContext applicationContext;\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(Jackson2ObjectMapperBuilder.class)\n\t\tpublic Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder() {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\tif (this.jacksonProperties.getSerializationInclusion() != null) {\n\t\t\t\tbuilder.serializationInclusion(this.jacksonProperties\n\t\t\t\t\t\t.getSerializationInclusion());\n\t\t\t}\n\t\t\tif (this.jacksonProperties.getTimeZone() != null) {\n\t\t\t\tbuilder.timeZone(this.jacksonProperties.getTimeZone());\n\t\t\t}\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\tconfigureDateFormat(builder);\n\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\tconfigureModules(builder);\n\t\t\tconfigureLocale(builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tMap<?, Boolean> features) {\n\t\t\tfor (Entry<?, Boolean> entry : features.entrySet()) {\n\t\t\t\tif (entry.getValue() != null && entry.getValue()) {\n\t\t\t\t\tbuilder.featuresToEnable(entry.getKey());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.featuresToDisable(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t// pattern string value\n\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\tif (dateFormat != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils\n\t\t\t\t\t\t\t.instantiateClass(dateFormatClass));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tbuilder.dateFormat(new SimpleDateFormat(dateFormat));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t// names in PropertyNamingStrategy which hold default provided implementations\n\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\tif (strategy != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder,\n\t\t\t\t\t\t\tClassUtils.forName(strategy, null));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyClass(\n\t\t\t\tJackson2ObjectMapperBuilder builder, Class<?> propertyNamingStrategyClass) {\n\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) BeanUtils\n\t\t\t\t\t.instantiateClass(propertyNamingStrategyClass));\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyField(\n\t\t\t\tJackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t// that may be added by Jackson in the future)\n\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class,\n\t\t\t\t\tfieldName, PropertyNamingStrategy.class);\n\t\t\tAssert.notNull(field, "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\ttry {\n\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext,\n\t\t\t\t\tModule.class);\n\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[moduleBeans.size()]));\n\t\t}\n\n\t\tprivate void configureLocale(Jackson2ObjectMapperBuilder builder) {\n\t\t\tLocale locale = this.jacksonProperties.getLocale();\n\t\t\tif (locale != null) {\n\t\t\t\tbuilder.locale(locale);\n\t\t\t}\n\t\t}\n\n\t\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory,\n\t\t\t\tClass<T> type) {\n\t\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type)\n\t\t\t\t\t.values();\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
