{'_old_path': None, '_new_path': PosixPath('spring-boot-autoconfigure/src/test/java/org/springframework/boot/autoconfigure/diagnostics/analyzer/NoSuchBeanDefinitionFailureAnalyzerTests.java'), 'change_type': <ModificationType.ADD: 1>, 'diff': '@@ -0,0 +1,333 @@\n+/*\n+ * Copyright 2012-2016 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.boot.autoconfigure.diagnostics.analyzer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import org.springframework.beans.DirectFieldAccessor;\n+import org.springframework.beans.FatalBeanException;\n+import org.springframework.beans.factory.BeanFactory;\n+import org.springframework.beans.factory.NoUniqueBeanDefinitionException;\n+import org.springframework.boot.autoconfigure.ImportAutoConfiguration;\n+import org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.boot.diagnostics.FailureAnalysis;\n+import org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter;\n+import org.springframework.boot.test.util.EnvironmentTestUtils;\n+import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.util.ClassUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * Tests for {@link NoSuchBeanDefinitionFailureAnalyzer}.\n+ *\n+ * @author Stephane Nicoll\n+ */\n+public class NoSuchBeanDefinitionFailureAnalyzerTests {\n+\n+\tprivate final NoSuchBeanDefinitionFailureAnalyzer analyzer = new NoSuchBeanDefinitionFailureAnalyzer();\n+\n+\t@Test\n+\tpublic void failureAnalysisForMultipleBeans() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tnew NoUniqueBeanDefinitionException(String.class, 2, "Test"));\n+\t\tassertThat(analysis).isNull();\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForNoMatchType() {\n+\t\tFailureAnalysis analysis = analyzeFailure(createFailure(StringHandler.class));\n+\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n+\t\t\t\tString.class);\n+\t\tassertThat(analysis.getDescription()).doesNotContain(\n+\t\t\t\t"No matching auto-configuration has been found for this type.");\n+\t\tassertThat(analysis.getAction()).startsWith(String.format(\n+\t\t\t\t"Consider defining a bean of type \'%s\' in your configuration.",\n+\t\t\t\tString.class.getName()));\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForMissingPropertyExactType() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tcreateFailure(StringPropertyTypeConfiguration.class));\n+\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n+\t\t\t\tString.class);\n+\t\tassertBeanMethodDisabled(analysis,\n+\t\t\t\t"did not find property \'spring.string.enabled\'",\n+\t\t\t\tTestPropertyAutoConfiguration.class, "string");\n+\t\tassertActionMissingType(analysis, String.class);\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForMissingPropertySubType() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tcreateFailure(IntegerPropertyTypeConfiguration.class));\n+\t\tassertThat(analysis).isNotNull();\n+\t\tassertDescriptionConstructorMissingType(analysis, NumberHandler.class, 0,\n+\t\t\t\tNumber.class);\n+\t\tassertBeanMethodDisabled(analysis,\n+\t\t\t\t"did not find property \'spring.integer.enabled\'",\n+\t\t\t\tTestPropertyAutoConfiguration.class, "integer");\n+\t\tassertActionMissingType(analysis, Number.class);\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForMissingClassOnAutoConfigurationType() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tcreateFailure(MissingClassOnAutoConfigurationConfiguration.class));\n+\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n+\t\t\t\tString.class);\n+\t\tassertClassDisabled(analysis, "did not find required class \'com.example.FooBar\'",\n+\t\t\t\t"string");\n+\t\tassertActionMissingType(analysis, String.class);\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForExcludedAutoConfigurationType() {\n+\t\tFatalBeanException failure = createFailure(StringHandler.class);\n+\t\taddExclusions(this.analyzer, TestPropertyAutoConfiguration.class);\n+\t\tFailureAnalysis analysis = analyzeFailure(failure);\n+\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n+\t\t\t\tString.class);\n+\t\tString configClass = ClassUtils\n+\t\t\t\t.getShortName(TestPropertyAutoConfiguration.class.getName());\n+\t\tassertClassDisabled(analysis,\n+\t\t\t\tString.format("auto-configuration \'%s\' was excluded", configClass),\n+\t\t\t\t"string");\n+\t\tassertActionMissingType(analysis, String.class);\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForSeveralConditionsType() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tcreateFailure(SeveralAutoConfigurationTypeConfiguration.class));\n+\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n+\t\t\t\tString.class);\n+\t\tassertBeanMethodDisabled(analysis,\n+\t\t\t\t"did not find property \'spring.string.enabled\'",\n+\t\t\t\tTestPropertyAutoConfiguration.class, "string");\n+\t\tassertClassDisabled(analysis, "did not find required class \'com.example.FooBar\'",\n+\t\t\t\t"string");\n+\t\tassertActionMissingType(analysis, String.class);\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForNoMatchName() {\n+\t\tFailureAnalysis analysis = analyzeFailure(createFailure(StringNameHandler.class));\n+\t\tassertThat(analysis.getDescription()).startsWith(String.format(\n+\t\t\t\t"Constructor in %s required a bean named \'%s\' that could not be found",\n+\t\t\t\tStringNameHandler.class.getName(), "test-string"));\n+\t\tassertThat(analysis.getDescription().contains(\n+\t\t\t\t"No matching auto-configuration has been found for this bean name."));\n+\t\tassertThat(analysis.getAction()).startsWith(String.format(\n+\t\t\t\t"Consider defining a bean named \'%s\' in your configuration.",\n+\t\t\t\t"test-string"));\n+\t}\n+\n+\t@Test\n+\tpublic void failureAnalysisForMissingBeanName() {\n+\t\tFailureAnalysis analysis = analyzeFailure(\n+\t\t\t\tcreateFailure(StringMissingBeanNameConfiguration.class));\n+\t\tassertThat(analysis.getDescription()).startsWith(String.format(\n+\t\t\t\t"Constructor in %s required a bean named \'%s\' that could not be found",\n+\t\t\t\tStringNameHandler.class.getName(), "test-string"));\n+\t\tassertBeanMethodDisabled(analysis,\n+\t\t\t\t"@ConditionalOnBean (types: java.lang.Integer; SearchStrategy: all) did not find any beans",\n+\t\t\t\tTestMissingBeanAutoConfiguration.class, "string");\n+\t\tassertActionMissingName(analysis, "test-string");\n+\t}\n+\n+\tprivate void assertDescriptionConstructorMissingType(FailureAnalysis analysis,\n+\t\t\tClass<?> component, int index, Class<?> type) {\n+\t\tString expected = String.format(\n+\t\t\t\t"Parameter %s of constructor in %s required a bean of "\n+\t\t\t\t\t\t+ "type \'%s\' that could not be found.",\n+\t\t\t\tindex, component.getName(), type.getName());\n+\t\tassertThat(analysis.getDescription()).startsWith(expected);\n+\t}\n+\n+\tprivate void assertActionMissingType(FailureAnalysis analysis, Class<?> type) {\n+\t\tassertThat(analysis.getAction()).startsWith(String\n+\t\t\t\t.format("Consider revisiting the conditions above or defining a bean of type \'%s\' "\n+\t\t\t\t\t\t+ "in your configuration.", type.getName()));\n+\t}\n+\n+\tprivate void assertActionMissingName(FailureAnalysis analysis, String name) {\n+\t\tassertThat(analysis.getAction()).startsWith(String\n+\t\t\t\t.format("Consider revisiting the conditions above or defining a bean named \'%s\' "\n+\t\t\t\t\t\t+ "in your configuration.", name));\n+\t}\n+\n+\tprivate void assertBeanMethodDisabled(FailureAnalysis analysis, String description,\n+\t\t\tClass<?> target, String methodName) {\n+\t\tString expected = String.format("Bean method \'%s\' in \'%s\' not loaded because",\n+\t\t\t\tmethodName, ClassUtils.getShortName(target), description);\n+\t\tassertThat(analysis.getDescription()).contains(expected);\n+\t\tassertThat(analysis.getDescription()).contains(description);\n+\t}\n+\n+\tprivate void assertClassDisabled(FailureAnalysis analysis, String description,\n+\t\t\tString methodName) {\n+\t\tString expected = String.format("Bean method \'%s\' not loaded because", methodName,\n+\t\t\t\tdescription);\n+\t\tassertThat(analysis.getDescription()).contains(expected);\n+\t\tassertThat(analysis.getDescription()).contains(description);\n+\t}\n+\n+\tprivate static void addExclusions(NoSuchBeanDefinitionFailureAnalyzer analyzer,\n+\t\t\tClass<?>... classes) {\n+\t\tConditionEvaluationReport report = (ConditionEvaluationReport) new DirectFieldAccessor(\n+\t\t\t\tanalyzer).getPropertyValue("report");\n+\t\tList<String> exclusions = new ArrayList<String>(report.getExclusions());\n+\t\tfor (Class<?> c : classes) {\n+\t\t\texclusions.add(c.getName());\n+\t\t}\n+\t\treport.recordExclusions(exclusions);\n+\t}\n+\n+\tprivate FatalBeanException createFailure(Class<?> config, String... environment) {\n+\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n+\t\tthis.analyzer.setBeanFactory(context.getBeanFactory());\n+\t\tEnvironmentTestUtils.addEnvironment(context, environment);\n+\t\tcontext.register(config);\n+\t\ttry {\n+\t\t\tcontext.refresh();\n+\t\t\treturn null;\n+\t\t}\n+\t\tcatch (FatalBeanException ex) {\n+\t\t\treturn ex;\n+\t\t}\n+\t\tfinally {\n+\t\t\tcontext.close();\n+\t\t}\n+\t}\n+\n+\tprivate FailureAnalysis analyzeFailure(Exception failure) {\n+\t\tFailureAnalysis analysis = this.analyzer.analyze(failure);\n+\t\tif (analysis != null) {\n+\t\t\tnew LoggingFailureAnalysisReporter().report(analysis);\n+\t\t}\n+\t\treturn analysis;\n+\t}\n+\n+\t@Configuration\n+\t@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)\n+\t@Import(StringHandler.class)\n+\tprotected static class StringPropertyTypeConfiguration {\n+\n+\t}\n+\n+\t@Configuration\n+\t@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)\n+\t@Import(NumberHandler.class)\n+\tprotected static class IntegerPropertyTypeConfiguration {\n+\n+\t}\n+\n+\t@Configuration\n+\t@ImportAutoConfiguration(TestTypeClassAutoConfiguration.class)\n+\t@Import(StringHandler.class)\n+\tprotected static class MissingClassOnAutoConfigurationConfiguration {\n+\n+\t}\n+\n+\t@Configuration\n+\t@ImportAutoConfiguration({ TestPropertyAutoConfiguration.class,\n+\t\t\tTestTypeClassAutoConfiguration.class })\n+\t@Import(StringHandler.class)\n+\tprotected static class SeveralAutoConfigurationTypeConfiguration {\n+\n+\t}\n+\n+\t@Configuration\n+\t@ImportAutoConfiguration(TestMissingBeanAutoConfiguration.class)\n+\t@Import(StringNameHandler.class)\n+\tprotected static class StringMissingBeanNameConfiguration {\n+\n+\t}\n+\n+\t@Configuration\n+\tpublic static class TestPropertyAutoConfiguration {\n+\n+\t\t@ConditionalOnProperty("spring.string.enabled")\n+\t\t@Bean\n+\t\tpublic String string() {\n+\t\t\treturn "Test";\n+\t\t}\n+\n+\t\t@ConditionalOnProperty("spring.integer.enabled")\n+\t\t@Bean\n+\t\tpublic Integer integer() {\n+\t\t\treturn 42;\n+\t\t}\n+\n+\t}\n+\n+\t@Configuration\n+\t@ConditionalOnClass(name = "com.example.FooBar")\n+\tpublic static class TestTypeClassAutoConfiguration {\n+\n+\t\t@Bean\n+\t\tpublic String string() {\n+\t\t\treturn "Test";\n+\t\t}\n+\n+\t}\n+\n+\t@Configuration\n+\tpublic static class TestMissingBeanAutoConfiguration {\n+\n+\t\t@ConditionalOnBean(Integer.class)\n+\t\t@Bean(name = "test-string")\n+\t\tpublic String string() {\n+\t\t\treturn "Test";\n+\t\t}\n+\n+\t}\n+\n+\tprotected static class StringHandler {\n+\n+\t\tpublic StringHandler(String foo) {\n+\t\t}\n+\n+\t}\n+\n+\tprotected static class NumberHandler {\n+\n+\t\tpublic NumberHandler(Number foo) {\n+\t\t}\n+\n+\t}\n+\n+\tprotected static class StringNameHandler {\n+\n+\t\tpublic StringNameHandler(BeanFactory beanFactory) {\n+\t\t\tbeanFactory.getBean("test-string");\n+\t\t}\n+\n+\t}\n+\n+}\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.diagnostics.analyzer;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport org.springframework.beans.DirectFieldAccessor;\nimport org.springframework.beans.FatalBeanException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.NoUniqueBeanDefinitionException;\nimport org.springframework.boot.autoconfigure.ImportAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.diagnostics.FailureAnalysis;\nimport org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter;\nimport org.springframework.boot.test.util.EnvironmentTestUtils;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.util.ClassUtils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * Tests for {@link NoSuchBeanDefinitionFailureAnalyzer}.\n *\n * @author Stephane Nicoll\n */\npublic class NoSuchBeanDefinitionFailureAnalyzerTests {\n\n\tprivate final NoSuchBeanDefinitionFailureAnalyzer analyzer = new NoSuchBeanDefinitionFailureAnalyzer();\n\n\t@Test\n\tpublic void failureAnalysisForMultipleBeans() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tnew NoUniqueBeanDefinitionException(String.class, 2, "Test"));\n\t\tassertThat(analysis).isNull();\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForNoMatchType() {\n\t\tFailureAnalysis analysis = analyzeFailure(createFailure(StringHandler.class));\n\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n\t\t\t\tString.class);\n\t\tassertThat(analysis.getDescription()).doesNotContain(\n\t\t\t\t"No matching auto-configuration has been found for this type.");\n\t\tassertThat(analysis.getAction()).startsWith(String.format(\n\t\t\t\t"Consider defining a bean of type \'%s\' in your configuration.",\n\t\t\t\tString.class.getName()));\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForMissingPropertyExactType() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tcreateFailure(StringPropertyTypeConfiguration.class));\n\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n\t\t\t\tString.class);\n\t\tassertBeanMethodDisabled(analysis,\n\t\t\t\t"did not find property \'spring.string.enabled\'",\n\t\t\t\tTestPropertyAutoConfiguration.class, "string");\n\t\tassertActionMissingType(analysis, String.class);\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForMissingPropertySubType() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tcreateFailure(IntegerPropertyTypeConfiguration.class));\n\t\tassertThat(analysis).isNotNull();\n\t\tassertDescriptionConstructorMissingType(analysis, NumberHandler.class, 0,\n\t\t\t\tNumber.class);\n\t\tassertBeanMethodDisabled(analysis,\n\t\t\t\t"did not find property \'spring.integer.enabled\'",\n\t\t\t\tTestPropertyAutoConfiguration.class, "integer");\n\t\tassertActionMissingType(analysis, Number.class);\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForMissingClassOnAutoConfigurationType() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tcreateFailure(MissingClassOnAutoConfigurationConfiguration.class));\n\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n\t\t\t\tString.class);\n\t\tassertClassDisabled(analysis, "did not find required class \'com.example.FooBar\'",\n\t\t\t\t"string");\n\t\tassertActionMissingType(analysis, String.class);\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForExcludedAutoConfigurationType() {\n\t\tFatalBeanException failure = createFailure(StringHandler.class);\n\t\taddExclusions(this.analyzer, TestPropertyAutoConfiguration.class);\n\t\tFailureAnalysis analysis = analyzeFailure(failure);\n\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n\t\t\t\tString.class);\n\t\tString configClass = ClassUtils\n\t\t\t\t.getShortName(TestPropertyAutoConfiguration.class.getName());\n\t\tassertClassDisabled(analysis,\n\t\t\t\tString.format("auto-configuration \'%s\' was excluded", configClass),\n\t\t\t\t"string");\n\t\tassertActionMissingType(analysis, String.class);\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForSeveralConditionsType() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tcreateFailure(SeveralAutoConfigurationTypeConfiguration.class));\n\t\tassertDescriptionConstructorMissingType(analysis, StringHandler.class, 0,\n\t\t\t\tString.class);\n\t\tassertBeanMethodDisabled(analysis,\n\t\t\t\t"did not find property \'spring.string.enabled\'",\n\t\t\t\tTestPropertyAutoConfiguration.class, "string");\n\t\tassertClassDisabled(analysis, "did not find required class \'com.example.FooBar\'",\n\t\t\t\t"string");\n\t\tassertActionMissingType(analysis, String.class);\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForNoMatchName() {\n\t\tFailureAnalysis analysis = analyzeFailure(createFailure(StringNameHandler.class));\n\t\tassertThat(analysis.getDescription()).startsWith(String.format(\n\t\t\t\t"Constructor in %s required a bean named \'%s\' that could not be found",\n\t\t\t\tStringNameHandler.class.getName(), "test-string"));\n\t\tassertThat(analysis.getDescription().contains(\n\t\t\t\t"No matching auto-configuration has been found for this bean name."));\n\t\tassertThat(analysis.getAction()).startsWith(String.format(\n\t\t\t\t"Consider defining a bean named \'%s\' in your configuration.",\n\t\t\t\t"test-string"));\n\t}\n\n\t@Test\n\tpublic void failureAnalysisForMissingBeanName() {\n\t\tFailureAnalysis analysis = analyzeFailure(\n\t\t\t\tcreateFailure(StringMissingBeanNameConfiguration.class));\n\t\tassertThat(analysis.getDescription()).startsWith(String.format(\n\t\t\t\t"Constructor in %s required a bean named \'%s\' that could not be found",\n\t\t\t\tStringNameHandler.class.getName(), "test-string"));\n\t\tassertBeanMethodDisabled(analysis,\n\t\t\t\t"@ConditionalOnBean (types: java.lang.Integer; SearchStrategy: all) did not find any beans",\n\t\t\t\tTestMissingBeanAutoConfiguration.class, "string");\n\t\tassertActionMissingName(analysis, "test-string");\n\t}\n\n\tprivate void assertDescriptionConstructorMissingType(FailureAnalysis analysis,\n\t\t\tClass<?> component, int index, Class<?> type) {\n\t\tString expected = String.format(\n\t\t\t\t"Parameter %s of constructor in %s required a bean of "\n\t\t\t\t\t\t+ "type \'%s\' that could not be found.",\n\t\t\t\tindex, component.getName(), type.getName());\n\t\tassertThat(analysis.getDescription()).startsWith(expected);\n\t}\n\n\tprivate void assertActionMissingType(FailureAnalysis analysis, Class<?> type) {\n\t\tassertThat(analysis.getAction()).startsWith(String\n\t\t\t\t.format("Consider revisiting the conditions above or defining a bean of type \'%s\' "\n\t\t\t\t\t\t+ "in your configuration.", type.getName()));\n\t}\n\n\tprivate void assertActionMissingName(FailureAnalysis analysis, String name) {\n\t\tassertThat(analysis.getAction()).startsWith(String\n\t\t\t\t.format("Consider revisiting the conditions above or defining a bean named \'%s\' "\n\t\t\t\t\t\t+ "in your configuration.", name));\n\t}\n\n\tprivate void assertBeanMethodDisabled(FailureAnalysis analysis, String description,\n\t\t\tClass<?> target, String methodName) {\n\t\tString expected = String.format("Bean method \'%s\' in \'%s\' not loaded because",\n\t\t\t\tmethodName, ClassUtils.getShortName(target), description);\n\t\tassertThat(analysis.getDescription()).contains(expected);\n\t\tassertThat(analysis.getDescription()).contains(description);\n\t}\n\n\tprivate void assertClassDisabled(FailureAnalysis analysis, String description,\n\t\t\tString methodName) {\n\t\tString expected = String.format("Bean method \'%s\' not loaded because", methodName,\n\t\t\t\tdescription);\n\t\tassertThat(analysis.getDescription()).contains(expected);\n\t\tassertThat(analysis.getDescription()).contains(description);\n\t}\n\n\tprivate static void addExclusions(NoSuchBeanDefinitionFailureAnalyzer analyzer,\n\t\t\tClass<?>... classes) {\n\t\tConditionEvaluationReport report = (ConditionEvaluationReport) new DirectFieldAccessor(\n\t\t\t\tanalyzer).getPropertyValue("report");\n\t\tList<String> exclusions = new ArrayList<String>(report.getExclusions());\n\t\tfor (Class<?> c : classes) {\n\t\t\texclusions.add(c.getName());\n\t\t}\n\t\treport.recordExclusions(exclusions);\n\t}\n\n\tprivate FatalBeanException createFailure(Class<?> config, String... environment) {\n\t\tAnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n\t\tthis.analyzer.setBeanFactory(context.getBeanFactory());\n\t\tEnvironmentTestUtils.addEnvironment(context, environment);\n\t\tcontext.register(config);\n\t\ttry {\n\t\t\tcontext.refresh();\n\t\t\treturn null;\n\t\t}\n\t\tcatch (FatalBeanException ex) {\n\t\t\treturn ex;\n\t\t}\n\t\tfinally {\n\t\t\tcontext.close();\n\t\t}\n\t}\n\n\tprivate FailureAnalysis analyzeFailure(Exception failure) {\n\t\tFailureAnalysis analysis = this.analyzer.analyze(failure);\n\t\tif (analysis != null) {\n\t\t\tnew LoggingFailureAnalysisReporter().report(analysis);\n\t\t}\n\t\treturn analysis;\n\t}\n\n\t@Configuration\n\t@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)\n\t@Import(StringHandler.class)\n\tprotected static class StringPropertyTypeConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)\n\t@Import(NumberHandler.class)\n\tprotected static class IntegerPropertyTypeConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ImportAutoConfiguration(TestTypeClassAutoConfiguration.class)\n\t@Import(StringHandler.class)\n\tprotected static class MissingClassOnAutoConfigurationConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ImportAutoConfiguration({ TestPropertyAutoConfiguration.class,\n\t\t\tTestTypeClassAutoConfiguration.class })\n\t@Import(StringHandler.class)\n\tprotected static class SeveralAutoConfigurationTypeConfiguration {\n\n\t}\n\n\t@Configuration\n\t@ImportAutoConfiguration(TestMissingBeanAutoConfiguration.class)\n\t@Import(StringNameHandler.class)\n\tprotected static class StringMissingBeanNameConfiguration {\n\n\t}\n\n\t@Configuration\n\tpublic static class TestPropertyAutoConfiguration {\n\n\t\t@ConditionalOnProperty("spring.string.enabled")\n\t\t@Bean\n\t\tpublic String string() {\n\t\t\treturn "Test";\n\t\t}\n\n\t\t@ConditionalOnProperty("spring.integer.enabled")\n\t\t@Bean\n\t\tpublic Integer integer() {\n\t\t\treturn 42;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(name = "com.example.FooBar")\n\tpublic static class TestTypeClassAutoConfiguration {\n\n\t\t@Bean\n\t\tpublic String string() {\n\t\t\treturn "Test";\n\t\t}\n\n\t}\n\n\t@Configuration\n\tpublic static class TestMissingBeanAutoConfiguration {\n\n\t\t@ConditionalOnBean(Integer.class)\n\t\t@Bean(name = "test-string")\n\t\tpublic String string() {\n\t\t\treturn "Test";\n\t\t}\n\n\t}\n\n\tprotected static class StringHandler {\n\n\t\tpublic StringHandler(String foo) {\n\t\t}\n\n\t}\n\n\tprotected static class NumberHandler {\n\n\t\tpublic NumberHandler(Number foo) {\n\t\t}\n\n\t}\n\n\tprotected static class StringNameHandler {\n\n\t\tpublic StringNameHandler(BeanFactory beanFactory) {\n\t\t\tbeanFactory.getBean("test-string");\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': None, '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
