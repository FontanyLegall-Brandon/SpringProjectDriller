{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -16,8 +16,9 @@\n \n package org.springframework.boot.actuate.autoconfigure;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -30,15 +31,15 @@ import org.springframework.boot.actuate.metrics.buffer.CounterBuffers;\n import org.springframework.boot.actuate.metrics.buffer.GaugeBuffers;\n import org.springframework.boot.actuate.metrics.export.Exporter;\n import org.springframework.boot.actuate.metrics.export.MetricCopyExporter;\n+import org.springframework.boot.actuate.metrics.export.MetricExportProperties;\n+import org.springframework.boot.actuate.metrics.export.MetricExporters;\n import org.springframework.boot.actuate.metrics.reader.MetricReader;\n import org.springframework.boot.actuate.metrics.repository.InMemoryMetricRepository;\n import org.springframework.boot.actuate.metrics.repository.MetricRepository;\n-import org.springframework.boot.actuate.metrics.writer.CompositeMetricWriter;\n import org.springframework.boot.actuate.metrics.writer.DefaultCounterService;\n import org.springframework.boot.actuate.metrics.writer.DefaultGaugeService;\n import org.springframework.boot.actuate.metrics.writer.MetricWriter;\n import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n-import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnJava;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnJava.JavaVersion;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnJava.Range;\n@@ -50,7 +51,6 @@ import org.springframework.context.annotation.Configuration;\n import org.springframework.context.annotation.Primary;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.scheduling.annotation.EnableScheduling;\n-import org.springframework.scheduling.annotation.Scheduled;\n \n import com.codahale.metrics.MetricRegistry;\n \n@@ -91,7 +91,7 @@ import com.codahale.metrics.MetricRegistry;\n  * @author Dave Syer\n  */\n @Configuration\n-@EnableConfigurationProperties(MetricsProperties.class)\n+@EnableConfigurationProperties(MetricExportProperties.class)\n public class MetricRepositoryAutoConfiguration {\n \n \t@Configuration\n@@ -173,10 +173,10 @@ public class MetricRepositoryAutoConfiguration {\n \tstatic class DefaultMetricsExporterConfiguration {\n \n \t\t@Autowired(required = false)\n-\t\tprivate List<MetricWriter> writers;\n+\t\tprivate Map<String, MetricWriter> writers = Collections.emptyMap();\n \n \t\t@Autowired\n-\t\tprivate MetricsProperties metrics;\n+\t\tprivate MetricExportProperties metrics;\n \n \t\t@Autowired(required = false)\n \t\t@Qualifier("actuatorMetricRepository")\n@@ -184,27 +184,19 @@ public class MetricRepositoryAutoConfiguration {\n \n \t\t@Bean\n \t\t@ConditionalOnMissingBean\n-\t\t@ConditionalOnBean(MetricWriter.class)\n-\t\tpublic MetricCopyExporter metricWritersMetricExporter(MetricReader reader) {\n-\t\t\tList<MetricWriter> writers = new ArrayList<MetricWriter>(this.writers);\n+\t\tpublic MetricExporters metricWritersMetricExporter(MetricReader reader) {\n+\t\t\tMap<String, MetricWriter> writers = new HashMap<String, MetricWriter>(\n+\t\t\t\t\tthis.writers);\n \t\t\tif (this.actuatorMetricRepository != null\n-\t\t\t\t\t&& writers.contains(this.actuatorMetricRepository)) {\n-\t\t\t\twriters.remove(this.actuatorMetricRepository);\n-\t\t\t}\n-\t\t\tMetricCopyExporter exporter = new MetricCopyExporter(reader,\n-\t\t\t\t\tnew CompositeMetricWriter(writers)) {\n-\t\t\t\t@Scheduled(fixedDelayString = "${spring.metrics.export.delayMillis:5000}")\n-\t\t\t\t@Override\n-\t\t\t\tpublic void export() {\n-\t\t\t\t\tsuper.export();\n+\t\t\t\t\t&& writers.containsValue(this.actuatorMetricRepository)) {\n+\t\t\t\tfor (String name : this.writers.keySet()) {\n+\t\t\t\t\tif (writers.get(name).equals(this.actuatorMetricRepository)) {\n+\t\t\t\t\t\twriters.remove(name);\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t};\n-\t\t\tif (this.metrics.getExport().getIncludes() != null\n-\t\t\t\t\t|| this.metrics.getExport().getExcludes() != null) {\n-\t\t\t\texporter.setIncludes(this.metrics.getExport().getIncludes());\n-\t\t\t\texporter.setExcludes(this.metrics.getExport().getExcludes());\n \t\t\t}\n-\t\t\treturn exporter;\n+\t\t\tMetricExporters exporters = new MetricExporters(reader, writers, this.metrics);\n+\t\t\treturn exporters;\n \t\t}\n \t}\n \n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.actuate.metrics.CounterService;\nimport org.springframework.boot.actuate.metrics.GaugeService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferCounterService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferGaugeService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferMetricReader;\nimport org.springframework.boot.actuate.metrics.buffer.CounterBuffers;\nimport org.springframework.boot.actuate.metrics.buffer.GaugeBuffers;\nimport org.springframework.boot.actuate.metrics.export.Exporter;\nimport org.springframework.boot.actuate.metrics.export.MetricCopyExporter;\nimport org.springframework.boot.actuate.metrics.export.MetricExportProperties;\nimport org.springframework.boot.actuate.metrics.export.MetricExporters;\nimport org.springframework.boot.actuate.metrics.reader.MetricReader;\nimport org.springframework.boot.actuate.metrics.repository.InMemoryMetricRepository;\nimport org.springframework.boot.actuate.metrics.repository.MetricRepository;\nimport org.springframework.boot.actuate.metrics.writer.DefaultCounterService;\nimport org.springframework.boot.actuate.metrics.writer.DefaultGaugeService;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava.JavaVersion;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava.Range;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\nimport com.codahale.metrics.MetricRegistry;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for metrics services. Creates\n * user-facing {@link GaugeService} and {@link CounterService} instances, and also back\n * end repositories to catch the data pumped into them.\n * <p>\n * An {@link InMemoryMetricRepository} is always created unless another\n * {@link MetricRepository} is already provided by the user. In general, even if metric\n * data needs to be stored and analysed remotely, it is recommended to use an in-memory\n * repository to buffer metric updates locally. The values can be exported (e.g. on a\n * periodic basis) using an {@link Exporter}, most implementations of which have\n * optimizations for sending data to remote repositories.\n * <p>\n * If Spring Messaging is on the classpath and a {@link MessageChannel} called\n * "metricsChannel" is also available, all metric update events are published additionally\n * as messages on that channel. Additional analysis or actions can be taken by clients\n * subscribing to that channel.\n * <p>\n * In addition if Dropwizard\'s metrics library is on the classpath a\n * {@link MetricRegistry} will be created and the default counter and gauge services will\n * switch to using it instead of the default repository. Users can create "special"\n * Dropwizard metrics by prefixing their metric names with the appropriate type (e.g.\n * "histogram.*", "meter.*". "timer.*") and sending them to the <code>GaugeService</code>\n * or <code>CounterService</code>.\n * <p>\n * By default all metric updates go to all {@link MetricWriter} instances in the\n * application context via a {@link MetricCopyExporter} firing every 5 seconds (disable\n * this by setting <code>spring.metrics.export.enabled=false</code>).\n *\n * @see GaugeService\n * @see CounterService\n * @see MetricWriter\n * @see InMemoryMetricRepository\n * @see Exporter\n *\n * @author Dave Syer\n */\n@Configuration\n@EnableConfigurationProperties(MetricExportProperties.class)\npublic class MetricRepositoryAutoConfiguration {\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT, range = Range.OLDER_THAN)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class LegacyMetricServicesConfiguration {\n\n\t\t@Autowired\n\t\tprivate MetricWriter writer;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterService counterService() {\n\t\t\treturn new DefaultCounterService(this.writer);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeService gaugeService() {\n\t\t\treturn new DefaultGaugeService(this.writer);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class FastMetricServicesConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterBuffers counterBuffers() {\n\t\t\treturn new CounterBuffers();\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeBuffers gaugeBuffers() {\n\t\t\treturn new GaugeBuffers();\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean\n\t\tpublic BufferMetricReader metricReader(CounterBuffers counters,\n\t\t\t\tGaugeBuffers gauges) {\n\t\t\treturn new BufferMetricReader(counters, gauges);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterService counterService(CounterBuffers writer) {\n\t\t\treturn new BufferCounterService(writer);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeService gaugeService(GaugeBuffers writer) {\n\t\t\treturn new BufferGaugeService(writer);\n\t\t}\n\t}\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT, range = Range.OLDER_THAN)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class LegacyMetricRepositoryConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\tpublic InMemoryMetricRepository actuatorMetricRepository() {\n\t\t\treturn new InMemoryMetricRepository();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@EnableScheduling\n\t@ConditionalOnProperty(value = "spring.metrics.export.enabled", matchIfMissing = true)\n\tstatic class DefaultMetricsExporterConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate Map<String, MetricWriter> writers = Collections.emptyMap();\n\n\t\t@Autowired\n\t\tprivate MetricExportProperties metrics;\n\n\t\t@Autowired(required = false)\n\t\t@Qualifier("actuatorMetricRepository")\n\t\tprivate MetricWriter actuatorMetricRepository;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic MetricExporters metricWritersMetricExporter(MetricReader reader) {\n\t\t\tMap<String, MetricWriter> writers = new HashMap<String, MetricWriter>(\n\t\t\t\t\tthis.writers);\n\t\t\tif (this.actuatorMetricRepository != null\n\t\t\t\t\t&& writers.containsValue(this.actuatorMetricRepository)) {\n\t\t\t\tfor (String name : this.writers.keySet()) {\n\t\t\t\t\tif (writers.get(name).equals(this.actuatorMetricRepository)) {\n\t\t\t\t\t\twriters.remove(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tMetricExporters exporters = new MetricExporters(reader, writers, this.metrics);\n\t\t\treturn exporters;\n\t\t}\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.actuate.metrics.CounterService;\nimport org.springframework.boot.actuate.metrics.GaugeService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferCounterService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferGaugeService;\nimport org.springframework.boot.actuate.metrics.buffer.BufferMetricReader;\nimport org.springframework.boot.actuate.metrics.buffer.CounterBuffers;\nimport org.springframework.boot.actuate.metrics.buffer.GaugeBuffers;\nimport org.springframework.boot.actuate.metrics.export.Exporter;\nimport org.springframework.boot.actuate.metrics.export.MetricCopyExporter;\nimport org.springframework.boot.actuate.metrics.reader.MetricReader;\nimport org.springframework.boot.actuate.metrics.repository.InMemoryMetricRepository;\nimport org.springframework.boot.actuate.metrics.repository.MetricRepository;\nimport org.springframework.boot.actuate.metrics.writer.CompositeMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.DefaultCounterService;\nimport org.springframework.boot.actuate.metrics.writer.DefaultGaugeService;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava.JavaVersion;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnJava.Range;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.scheduling.annotation.EnableScheduling;\nimport org.springframework.scheduling.annotation.Scheduled;\n\nimport com.codahale.metrics.MetricRegistry;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for metrics services. Creates\n * user-facing {@link GaugeService} and {@link CounterService} instances, and also back\n * end repositories to catch the data pumped into them.\n * <p>\n * An {@link InMemoryMetricRepository} is always created unless another\n * {@link MetricRepository} is already provided by the user. In general, even if metric\n * data needs to be stored and analysed remotely, it is recommended to use an in-memory\n * repository to buffer metric updates locally. The values can be exported (e.g. on a\n * periodic basis) using an {@link Exporter}, most implementations of which have\n * optimizations for sending data to remote repositories.\n * <p>\n * If Spring Messaging is on the classpath and a {@link MessageChannel} called\n * "metricsChannel" is also available, all metric update events are published additionally\n * as messages on that channel. Additional analysis or actions can be taken by clients\n * subscribing to that channel.\n * <p>\n * In addition if Dropwizard\'s metrics library is on the classpath a\n * {@link MetricRegistry} will be created and the default counter and gauge services will\n * switch to using it instead of the default repository. Users can create "special"\n * Dropwizard metrics by prefixing their metric names with the appropriate type (e.g.\n * "histogram.*", "meter.*". "timer.*") and sending them to the <code>GaugeService</code>\n * or <code>CounterService</code>.\n * <p>\n * By default all metric updates go to all {@link MetricWriter} instances in the\n * application context via a {@link MetricCopyExporter} firing every 5 seconds (disable\n * this by setting <code>spring.metrics.export.enabled=false</code>).\n *\n * @see GaugeService\n * @see CounterService\n * @see MetricWriter\n * @see InMemoryMetricRepository\n * @see Exporter\n *\n * @author Dave Syer\n */\n@Configuration\n@EnableConfigurationProperties(MetricsProperties.class)\npublic class MetricRepositoryAutoConfiguration {\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT, range = Range.OLDER_THAN)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class LegacyMetricServicesConfiguration {\n\n\t\t@Autowired\n\t\tprivate MetricWriter writer;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterService counterService() {\n\t\t\treturn new DefaultCounterService(this.writer);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeService gaugeService() {\n\t\t\treturn new DefaultGaugeService(this.writer);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class FastMetricServicesConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterBuffers counterBuffers() {\n\t\t\treturn new CounterBuffers();\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeBuffers gaugeBuffers() {\n\t\t\treturn new GaugeBuffers();\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean\n\t\tpublic BufferMetricReader metricReader(CounterBuffers counters,\n\t\t\t\tGaugeBuffers gauges) {\n\t\t\treturn new BufferMetricReader(counters, gauges);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic CounterService counterService(CounterBuffers writer) {\n\t\t\treturn new BufferCounterService(writer);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic GaugeService gaugeService(GaugeBuffers writer) {\n\t\t\treturn new BufferGaugeService(writer);\n\t\t}\n\t}\n\n\t@Configuration\n\t@ConditionalOnJava(value = JavaVersion.EIGHT, range = Range.OLDER_THAN)\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class LegacyMetricRepositoryConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\tpublic InMemoryMetricRepository actuatorMetricRepository() {\n\t\t\treturn new InMemoryMetricRepository();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@EnableScheduling\n\t@ConditionalOnProperty(value = "spring.metrics.export.enabled", matchIfMissing = true)\n\tstatic class DefaultMetricsExporterConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate List<MetricWriter> writers;\n\n\t\t@Autowired\n\t\tprivate MetricsProperties metrics;\n\n\t\t@Autowired(required = false)\n\t\t@Qualifier("actuatorMetricRepository")\n\t\tprivate MetricWriter actuatorMetricRepository;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\t@ConditionalOnBean(MetricWriter.class)\n\t\tpublic MetricCopyExporter metricWritersMetricExporter(MetricReader reader) {\n\t\t\tList<MetricWriter> writers = new ArrayList<MetricWriter>(this.writers);\n\t\t\tif (this.actuatorMetricRepository != null\n\t\t\t\t\t&& writers.contains(this.actuatorMetricRepository)) {\n\t\t\t\twriters.remove(this.actuatorMetricRepository);\n\t\t\t}\n\t\t\tMetricCopyExporter exporter = new MetricCopyExporter(reader,\n\t\t\t\t\tnew CompositeMetricWriter(writers)) {\n\t\t\t\t@Scheduled(fixedDelayString = "${spring.metrics.export.delayMillis:5000}")\n\t\t\t\t@Override\n\t\t\t\tpublic void export() {\n\t\t\t\t\tsuper.export();\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (this.metrics.getExport().getIncludes() != null\n\t\t\t\t\t|| this.metrics.getExport().getExcludes() != null) {\n\t\t\t\texporter.setIncludes(this.metrics.getExport().getIncludes());\n\t\t\t\texporter.setExcludes(this.metrics.getExport().getExcludes());\n\t\t\t}\n\t\t\treturn exporter;\n\t\t}\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
