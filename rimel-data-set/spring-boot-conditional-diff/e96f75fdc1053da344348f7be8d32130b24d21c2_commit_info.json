{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -39,6 +39,7 @@ import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\n import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\n import org.springframework.boot.autoconfigure.condition.SearchStrategy;\n import org.springframework.boot.autoconfigure.web.ErrorAttributes;\n import org.springframework.boot.autoconfigure.web.HttpMessageConverters;\n@@ -50,6 +51,7 @@ import org.springframework.boot.context.embedded.ErrorPage;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n+import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n import org.springframework.web.servlet.DispatcherServlet;\n import org.springframework.web.servlet.HandlerAdapter;\n import org.springframework.web.servlet.HandlerMapping;\n@@ -133,40 +135,6 @@ public class EndpointWebMvcChildContextConfiguration {\n \t\treturn adapter;\n \t}\n \n-\t@Bean\n-\tpublic HandlerMapping handlerMapping(MvcEndpoints endpoints,\n-\t\t\tListableBeanFactory beanFactory) {\n-\t\tSet<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints());\n-\t\tset.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values());\n-\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(set);\n-\t\t// In a child context we definitely want to see the parent endpoints\n-\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n-\t\tinjectIntoSecurityFilter(beanFactory, mapping);\n-\t\tif (this.mappingCustomizers != null) {\n-\t\t\tfor (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {\n-\t\t\t\tcustomizer.customize(mapping);\n-\t\t\t}\n-\t\t}\n-\t\treturn mapping;\n-\t}\n-\n-\tprivate void injectIntoSecurityFilter(ListableBeanFactory beanFactory,\n-\t\t\tEndpointHandlerMapping mapping) {\n-\t\t// The parent context has the security filter, so we need to get it injected with\n-\t\t// our EndpointHandlerMapping if we can.\n-\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n-\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n-\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n-\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n-\t\t\tbean.setEndpointHandlerMapping(mapping);\n-\t\t}\n-\t\telse {\n-\t\t\tlogger.warn("No single bean of type "\n-\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n-\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n-\t\t}\n-\t}\n-\n \t/*\n \t * The error controller is present but not mapped as an endpoint in this context\n \t * because of the DispatcherServlet having had it\'s HandlerMapping explicitly\n@@ -177,6 +145,71 @@ public class EndpointWebMvcChildContextConfiguration {\n \t\treturn new ManagementErrorEndpoint(this.errorPath, errorAttributes);\n \t}\n \n+\t@Configuration\n+\t@ConditionalOnMissingClass(WebSecurityConfigurerAdapter.class)\n+\tstatic class EndpointHandlerMappingSimpleConfiguration {\n+\n+\t\t@Autowired(required = false)\n+\t\tprivate List<EndpointHandlerMappingCustomizer> mappingCustomizers;\n+\n+\t\t@Bean\n+\t\tpublic HandlerMapping handlerMapping(MvcEndpoints endpoints,\n+\t\t\t\tListableBeanFactory beanFactory) {\n+\n+\t\t\tEndpointHandlerMapping mapping = doCreateEndpointHandlerMapping(endpoints, beanFactory);\n+\t\t\tif (this.mappingCustomizers != null) {\n+\t\t\t\tfor (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {\n+\t\t\t\t\tcustomizer.customize(mapping);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mapping;\n+\t\t}\n+\n+\t\tprotected EndpointHandlerMapping doCreateEndpointHandlerMapping(MvcEndpoints endpoints,\n+\t\t\t\tListableBeanFactory beanFactory) {\n+\t\t\tSet<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints());\n+\t\t\tset.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values());\n+\t\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(set);\n+\t\t\t// In a child context we definitely want to see the parent endpoints\n+\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n+\t\t\treturn mapping;\n+\t\t}\n+\n+\t}\n+\n+\t@Configuration\n+\t@ConditionalOnClass(WebSecurityConfigurerAdapter.class)\n+\tstatic class EndpointHandlerMappingSecurityConfiguration\n+\t\t\textends EndpointHandlerMappingSimpleConfiguration {\n+\n+\t\t@Override\n+\t\tprotected EndpointHandlerMapping doCreateEndpointHandlerMapping(MvcEndpoints endpoints,\n+\t\t\t\tListableBeanFactory beanFactory) {\n+\n+\t\t\tEndpointHandlerMapping mapping = super.doCreateEndpointHandlerMapping(endpoints, beanFactory);\n+\t\t\tinjectIntoSecurityFilter(beanFactory, mapping);\n+\t\t\treturn mapping;\n+\t\t}\n+\n+\t\tprivate void injectIntoSecurityFilter(ListableBeanFactory beanFactory,\n+\t\t\t\tEndpointHandlerMapping mapping) {\n+\t\t\t// The parent context has the security filter, so we need to get it injected with\n+\t\t\t// our EndpointHandlerMapping if we can.\n+\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n+\t\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n+\t\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n+\t\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n+\t\t\t\tbean.setEndpointHandlerMapping(mapping);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tlogger.warn("No single bean of type "\n+\t\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n+\t\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n \t@Configuration\n \t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n \t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.servlet.Filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.actuate.autoconfigure.ManagementSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.HttpMessageConverters;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.context.embedded.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\npublic class EndpointWebMvcChildContextConfiguration {\n\n\tprivate static Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcChildContextConfiguration.class);\n\n\t@Value("${error.path:/error}")\n\tprivate String errorPath = "/error";\n\n\t@Autowired(required = false)\n\tprivate List<EndpointHandlerMappingCustomizer> mappingCustomizers;\n\n\t@Configuration\n\tprotected static class ServerCustomization implements\n\t\t\tEmbeddedServletContainerCustomizer {\n\n\t\t@Value("${error.path:/error}")\n\t\tprivate String errorPath = "/error";\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage> emptySet());\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.setContextPath(this.managementServerProperties.getContextPath());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.errorPath));\n\t\t}\n\n\t}\n\n\t@Bean\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean\n\tpublic HandlerAdapter handlerAdapter(HttpMessageConverters converters) {\n\t\tRequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();\n\t\tadapter.setMessageConverters(converters.getConverters());\n\t\treturn adapter;\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had it\'s HandlerMapping explicitly\n\t * disabled. So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\tpublic ManagementErrorEndpoint errorEndpoint(final ErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(this.errorPath, errorAttributes);\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingClass(WebSecurityConfigurerAdapter.class)\n\tstatic class EndpointHandlerMappingSimpleConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate List<EndpointHandlerMappingCustomizer> mappingCustomizers;\n\n\t\t@Bean\n\t\tpublic HandlerMapping handlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory) {\n\n\t\t\tEndpointHandlerMapping mapping = doCreateEndpointHandlerMapping(endpoints, beanFactory);\n\t\t\tif (this.mappingCustomizers != null) {\n\t\t\t\tfor (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {\n\t\t\t\t\tcustomizer.customize(mapping);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mapping;\n\t\t}\n\n\t\tprotected EndpointHandlerMapping doCreateEndpointHandlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory) {\n\t\t\tSet<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints());\n\t\t\tset.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values());\n\t\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(set);\n\t\t\t// In a child context we definitely want to see the parent endpoints\n\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\t\treturn mapping;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(WebSecurityConfigurerAdapter.class)\n\tstatic class EndpointHandlerMappingSecurityConfiguration\n\t\t\textends EndpointHandlerMappingSimpleConfiguration {\n\n\t\t@Override\n\t\tprotected EndpointHandlerMapping doCreateEndpointHandlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory) {\n\n\t\t\tEndpointHandlerMapping mapping = super.doCreateEndpointHandlerMapping(endpoints, beanFactory);\n\t\t\tinjectIntoSecurityFilter(beanFactory, mapping);\n\t\t\treturn mapping;\n\t\t}\n\n\t\tprivate void injectIntoSecurityFilter(ListableBeanFactory beanFactory,\n\t\t\t\tEndpointHandlerMapping mapping) {\n\t\t\t// The parent context has the security filter, so we need to get it injected with\n\t\t\t// our EndpointHandlerMapping if we can.\n\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n\t\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n\t\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n\t\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n\t\t\t\tbean.setEndpointHandlerMapping(mapping);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn("No single bean of type "\n\t\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n\t\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.servlet.Filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.actuate.autoconfigure.ManagementSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.HttpMessageConverters;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.context.embedded.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\npublic class EndpointWebMvcChildContextConfiguration {\n\n\tprivate static Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcChildContextConfiguration.class);\n\n\t@Value("${error.path:/error}")\n\tprivate String errorPath = "/error";\n\n\t@Autowired(required = false)\n\tprivate List<EndpointHandlerMappingCustomizer> mappingCustomizers;\n\n\t@Configuration\n\tprotected static class ServerCustomization implements\n\t\t\tEmbeddedServletContainerCustomizer {\n\n\t\t@Value("${error.path:/error}")\n\t\tprivate String errorPath = "/error";\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage> emptySet());\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.setContextPath(this.managementServerProperties.getContextPath());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.errorPath));\n\t\t}\n\n\t}\n\n\t@Bean\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean\n\tpublic HandlerAdapter handlerAdapter(HttpMessageConverters converters) {\n\t\tRequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();\n\t\tadapter.setMessageConverters(converters.getConverters());\n\t\treturn adapter;\n\t}\n\n\t@Bean\n\tpublic HandlerMapping handlerMapping(MvcEndpoints endpoints,\n\t\t\tListableBeanFactory beanFactory) {\n\t\tSet<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints());\n\t\tset.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values());\n\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(set);\n\t\t// In a child context we definitely want to see the parent endpoints\n\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\tinjectIntoSecurityFilter(beanFactory, mapping);\n\t\tif (this.mappingCustomizers != null) {\n\t\t\tfor (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {\n\t\t\t\tcustomizer.customize(mapping);\n\t\t\t}\n\t\t}\n\t\treturn mapping;\n\t}\n\n\tprivate void injectIntoSecurityFilter(ListableBeanFactory beanFactory,\n\t\t\tEndpointHandlerMapping mapping) {\n\t\t// The parent context has the security filter, so we need to get it injected with\n\t\t// our EndpointHandlerMapping if we can.\n\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n\t\t\tbean.setEndpointHandlerMapping(mapping);\n\t\t}\n\t\telse {\n\t\t\tlogger.warn("No single bean of type "\n\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n\t\t}\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had it\'s HandlerMapping explicitly\n\t * disabled. So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\tpublic ManagementErrorEndpoint errorEndpoint(final ErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(this.errorPath, errorAttributes);\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
