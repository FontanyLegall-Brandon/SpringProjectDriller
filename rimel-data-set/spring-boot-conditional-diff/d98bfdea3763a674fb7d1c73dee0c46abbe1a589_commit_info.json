{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/MetricRepositoryAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -18,7 +18,6 @@ package org.springframework.boot.actuate.autoconfigure;\n \n import java.util.List;\n import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n \n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.beans.factory.annotation.Qualifier;\n@@ -44,6 +43,7 @@ import org.springframework.context.annotation.Primary;\n import org.springframework.messaging.MessageChannel;\n import org.springframework.messaging.SubscribableChannel;\n import org.springframework.messaging.support.ExecutorSubscribableChannel;\n+import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n \n import com.codahale.metrics.MetricRegistry;\n \n@@ -121,9 +121,9 @@ public class MetricRepositoryAutoConfiguration {\n \t@ConditionalOnClass(MessageChannel.class)\n \tstatic class MetricsChannelConfiguration {\n \n-\t\t@Autowired(required = false)\n+\t\t@Autowired\n \t\t@Qualifier("metricsExecutor")\n-\t\tprivate final Executor executor = Executors.newSingleThreadExecutor();\n+\t\tprivate Executor executor;\n \n \t\t@Bean\n \t\t@ConditionalOnMissingBean(name = "metricsChannel")\n@@ -131,6 +131,13 @@ public class MetricRepositoryAutoConfiguration {\n \t\t\treturn new ExecutorSubscribableChannel(this.executor);\n \t\t}\n \n+\t\t@Bean\n+\t\t@ConditionalOnMissingBean(name = "metricsExecutor")\n+\t\tprotected Executor metricsExecutor() {\n+\t\t\tThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n+\t\t\treturn executor;\n+\t\t}\n+\n \t\t@Bean\n \t\t@Primary\n \t\t@ConditionalOnMissingBean(name = "primaryMetricWriter")\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.List;\nimport java.util.concurrent.Executor;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.actuate.metrics.CounterService;\nimport org.springframework.boot.actuate.metrics.GaugeService;\nimport org.springframework.boot.actuate.metrics.export.Exporter;\nimport org.springframework.boot.actuate.metrics.repository.InMemoryMetricRepository;\nimport org.springframework.boot.actuate.metrics.repository.MetricRepository;\nimport org.springframework.boot.actuate.metrics.writer.CodahaleMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.CompositeMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.DefaultCounterService;\nimport org.springframework.boot.actuate.metrics.writer.DefaultGaugeService;\nimport org.springframework.boot.actuate.metrics.writer.MessageChannelMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriterMessageHandler;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.SubscribableChannel;\nimport org.springframework.messaging.support.ExecutorSubscribableChannel;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\nimport com.codahale.metrics.MetricRegistry;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for metrics services. Creates\n * user-facing {@link GaugeService} and {@link CounterService} instances, and also back\n * end repositories to catch the data pumped into them. </p>\n * <p>\n * An {@link InMemoryMetricRepository} is always created unless another\n * {@link MetricRepository} is already provided by the user. In general, even if metric\n * data needs to be stored and analysed remotely, it is recommended to use an in-memory\n * repository to buffer metric updates locally. The values can be exported (e.g. on a\n * periodic basis) using an {@link Exporter}, most implementations of which have\n * optimizations for sending data to remote repositories.\n * </p>\n * <p>\n * If Spring Messaging is on the classpath a {@link MessageChannel} called\n * "metricsChannel" is also created (unless one already exists) and all metric update\n * events are published additionally as messages on that channel. Additional analysis or\n * actions can be taken by clients subscribing to that channel.\n * </p>\n * <p>\n * In addition if Codahale\'s metrics library is on the classpath a {@link MetricRegistry}\n * will be created and wired up to the counter and gauge services in addition to the basic\n * repository. Users can create Codahale metrics by prefixing their metric names with the\n * appropriate type (e.g. "histogram.*", "meter.*").\n * </p>\n * <p>\n * By default all metric updates go to all {@link MetricWriter} instances in the\n * application context. To change this behaviour define your own metric writer bean called\n * "primaryMetricWriter", mark it <code>@Primary</code>, and this one will receive all\n * updates from the default counter and gauge services. ALternatively you can provide your\n * own counter and gauge services and wire them to whichever writer you choose.\n * </p>\n * \n * @see GaugeService\n * @see CounterService\n * @see MetricWriter\n * @see InMemoryMetricRepository\n * @see CodahaleMetricWriter\n * @see Exporter\n * \n * @author Dave Syer\n */\n@Configuration\npublic class MetricRepositoryAutoConfiguration {\n\n\t@Autowired\n\tprivate MetricWriter writer;\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic CounterService counterService() {\n\t\treturn new DefaultCounterService(this.writer);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic GaugeService gaugeService() {\n\t\treturn new DefaultGaugeService(this.writer);\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class MetricRepositoryConfiguration {\n\n\t\t@Bean\n\t\tpublic InMemoryMetricRepository metricRepository() {\n\t\t\treturn new InMemoryMetricRepository();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(MessageChannel.class)\n\tstatic class MetricsChannelConfiguration {\n\n\t\t@Autowired\n\t\t@Qualifier("metricsExecutor")\n\t\tprivate Executor executor;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(name = "metricsChannel")\n\t\tpublic SubscribableChannel metricsChannel() {\n\t\t\treturn new ExecutorSubscribableChannel(this.executor);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(name = "metricsExecutor")\n\t\tprotected Executor metricsExecutor() {\n\t\t\tThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n\t\t\treturn executor;\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(name = "primaryMetricWriter")\n\t\tpublic MetricWriter primaryMetricWriter(\n\t\t\t\t@Qualifier("metricsChannel") SubscribableChannel channel,\n\t\t\t\tList<MetricWriter> writers) {\n\t\t\tfinal MetricWriter observer = new CompositeMetricWriter(writers);\n\t\t\tchannel.subscribe(new MetricWriterMessageHandler(observer));\n\t\t\treturn new MessageChannelMetricWriter(channel);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(MetricRegistry.class)\n\tstatic class CodahaleMetricRegistryConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic MetricRegistry metricRegistry() {\n\t\t\treturn new MetricRegistry();\n\t\t}\n\n\t\t@Bean\n\t\tpublic CodahaleMetricWriter codahaleMetricWriter(MetricRegistry metricRegistry) {\n\t\t\treturn new CodahaleMetricWriter(metricRegistry);\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingClass(name = "org.springframework.messaging.MessageChannel")\n\t\t@ConditionalOnMissingBean(name = "primaryMetricWriter")\n\t\tpublic MetricWriter primaryMetricWriter(List<MetricWriter> writers) {\n\t\t\treturn new CompositeMetricWriter(writers);\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.actuate.metrics.CounterService;\nimport org.springframework.boot.actuate.metrics.GaugeService;\nimport org.springframework.boot.actuate.metrics.export.Exporter;\nimport org.springframework.boot.actuate.metrics.repository.InMemoryMetricRepository;\nimport org.springframework.boot.actuate.metrics.repository.MetricRepository;\nimport org.springframework.boot.actuate.metrics.writer.CodahaleMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.CompositeMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.DefaultCounterService;\nimport org.springframework.boot.actuate.metrics.writer.DefaultGaugeService;\nimport org.springframework.boot.actuate.metrics.writer.MessageChannelMetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriter;\nimport org.springframework.boot.actuate.metrics.writer.MetricWriterMessageHandler;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.SubscribableChannel;\nimport org.springframework.messaging.support.ExecutorSubscribableChannel;\n\nimport com.codahale.metrics.MetricRegistry;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for metrics services. Creates\n * user-facing {@link GaugeService} and {@link CounterService} instances, and also back\n * end repositories to catch the data pumped into them. </p>\n * <p>\n * An {@link InMemoryMetricRepository} is always created unless another\n * {@link MetricRepository} is already provided by the user. In general, even if metric\n * data needs to be stored and analysed remotely, it is recommended to use an in-memory\n * repository to buffer metric updates locally. The values can be exported (e.g. on a\n * periodic basis) using an {@link Exporter}, most implementations of which have\n * optimizations for sending data to remote repositories.\n * </p>\n * <p>\n * If Spring Messaging is on the classpath a {@link MessageChannel} called\n * "metricsChannel" is also created (unless one already exists) and all metric update\n * events are published additionally as messages on that channel. Additional analysis or\n * actions can be taken by clients subscribing to that channel.\n * </p>\n * <p>\n * In addition if Codahale\'s metrics library is on the classpath a {@link MetricRegistry}\n * will be created and wired up to the counter and gauge services in addition to the basic\n * repository. Users can create Codahale metrics by prefixing their metric names with the\n * appropriate type (e.g. "histogram.*", "meter.*").\n * </p>\n * <p>\n * By default all metric updates go to all {@link MetricWriter} instances in the\n * application context. To change this behaviour define your own metric writer bean called\n * "primaryMetricWriter", mark it <code>@Primary</code>, and this one will receive all\n * updates from the default counter and gauge services. ALternatively you can provide your\n * own counter and gauge services and wire them to whichever writer you choose.\n * </p>\n * \n * @see GaugeService\n * @see CounterService\n * @see MetricWriter\n * @see InMemoryMetricRepository\n * @see CodahaleMetricWriter\n * @see Exporter\n * \n * @author Dave Syer\n */\n@Configuration\npublic class MetricRepositoryAutoConfiguration {\n\n\t@Autowired\n\tprivate MetricWriter writer;\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic CounterService counterService() {\n\t\treturn new DefaultCounterService(this.writer);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic GaugeService gaugeService() {\n\t\treturn new DefaultGaugeService(this.writer);\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(MetricRepository.class)\n\tstatic class MetricRepositoryConfiguration {\n\n\t\t@Bean\n\t\tpublic InMemoryMetricRepository metricRepository() {\n\t\t\treturn new InMemoryMetricRepository();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(MessageChannel.class)\n\tstatic class MetricsChannelConfiguration {\n\n\t\t@Autowired(required = false)\n\t\t@Qualifier("metricsExecutor")\n\t\tprivate final Executor executor = Executors.newSingleThreadExecutor();\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(name = "metricsChannel")\n\t\tpublic SubscribableChannel metricsChannel() {\n\t\t\treturn new ExecutorSubscribableChannel(this.executor);\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(name = "primaryMetricWriter")\n\t\tpublic MetricWriter primaryMetricWriter(\n\t\t\t\t@Qualifier("metricsChannel") SubscribableChannel channel,\n\t\t\t\tList<MetricWriter> writers) {\n\t\t\tfinal MetricWriter observer = new CompositeMetricWriter(writers);\n\t\t\tchannel.subscribe(new MetricWriterMessageHandler(observer));\n\t\t\treturn new MessageChannelMetricWriter(channel);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(MetricRegistry.class)\n\tstatic class CodahaleMetricRegistryConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic MetricRegistry metricRegistry() {\n\t\t\treturn new MetricRegistry();\n\t\t}\n\n\t\t@Bean\n\t\tpublic CodahaleMetricWriter codahaleMetricWriter(MetricRegistry metricRegistry) {\n\t\t\treturn new CodahaleMetricWriter(metricRegistry);\n\t\t}\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingClass(name = "org.springframework.messaging.MessageChannel")\n\t\t@ConditionalOnMissingBean(name = "primaryMetricWriter")\n\t\tpublic MetricWriter primaryMetricWriter(List<MetricWriter> writers) {\n\t\t\treturn new CompositeMetricWriter(writers);\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
