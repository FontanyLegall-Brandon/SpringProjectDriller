{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/SecurityAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/SecurityAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -17,7 +17,10 @@\n package org.springframework.boot.actuate.autoconfigure;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n@@ -25,8 +28,8 @@ import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.actuate.endpoint.Endpoint;\n import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\n import org.springframework.boot.actuate.properties.ManagementServerProperties;\n-import org.springframework.boot.actuate.properties.ManagementServerProperties.User;\n import org.springframework.boot.actuate.properties.SecurityProperties;\n+import org.springframework.boot.actuate.properties.SecurityProperties.User;\n import org.springframework.boot.actuate.web.ErrorController;\n import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n@@ -40,13 +43,14 @@ import org.springframework.security.authentication.AuthenticationEventPublisher;\n import org.springframework.security.authentication.AuthenticationManager;\n import org.springframework.security.authentication.DefaultAuthenticationEventPublisher;\n import org.springframework.security.authentication.ProviderManager;\n+import org.springframework.security.config.annotation.ObjectPostProcessor;\n import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n+import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;\n import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n import org.springframework.security.config.annotation.web.builders.WebSecurity;\n import org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\n import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n-import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;\n import org.springframework.security.web.AuthenticationEntryPoint;\n import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;\n \n@@ -85,6 +89,7 @@ import org.springframework.security.web.authentication.www.BasicAuthenticationEn\n @Configuration\n @ConditionalOnClass({ EnableWebSecurity.class })\n @EnableWebSecurity\n+// (debug = true)\n @EnableConfigurationProperties\n public class SecurityAutoConfiguration {\n \n@@ -101,27 +106,25 @@ public class SecurityAutoConfiguration {\n \t}\n \n \t@Bean\n-\t@ConditionalOnMissingBean({ BoostrapWebSecurityConfigurerAdapter.class })\n-\tpublic WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() {\n-\t\treturn new BoostrapWebSecurityConfigurerAdapter();\n+\t@ConditionalOnMissingBean({ ApplicationWebSecurityConfigurerAdapter.class })\n+\tpublic WebSecurityConfigurerAdapter applicationWebSecurityConfigurerAdapter() {\n+\t\treturn new ApplicationWebSecurityConfigurerAdapter();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })\n+\tpublic WebSecurityConfigurerAdapter managementWebSecurityConfigurerAdapter() {\n+\t\treturn new ManagementWebSecurityConfigurerAdapter();\n \t}\n \n \t// Give user-supplied filters a chance to be last in line\n-\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n-\tprivate static class BoostrapWebSecurityConfigurerAdapter extends\n+\t@Order(Ordered.LOWEST_PRECEDENCE - 5)\n+\tprivate static class ApplicationWebSecurityConfigurerAdapter extends\n \t\t\tWebSecurityConfigurerAdapter {\n \n-\t\tprivate static final String[] NO_PATHS = new String[0];\n-\n \t\t@Autowired\n \t\tprivate SecurityProperties security;\n \n-\t\t@Autowired\n-\t\tprivate ManagementServerProperties management;\n-\n-\t\t@Autowired(required = false)\n-\t\tprivate EndpointHandlerMapping endpointHandlerMapping;\n-\n \t\t@Autowired\n \t\tprivate AuthenticationEventPublisher authenticationEventPublisher;\n \n@@ -135,26 +138,20 @@ public class SecurityAutoConfiguration {\n \t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n \t\t\t}\n \n-\t\t\tif (this.security.getBasic().isEnabled()) {\n+\t\t\tString[] paths = getSecureApplicationPaths();\n+\t\t\tif (this.security.getBasic().isEnabled() && paths.length > 0) {\n \t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint());\n-\t\t\t\thttp.httpBasic().and().anonymous().disable();\n-\t\t\t\tExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http\n-\t\t\t\t\t\t.authorizeUrls();\n-\t\t\t\tString[] paths = getEndpointPaths(true);\n-\t\t\t\tif (paths.length > 0) {\n-\t\t\t\t\tauthorizeUrls.antMatchers(getEndpointPaths(true)).hasRole(\n-\t\t\t\t\t\t\tthis.management.getUser().getRole());\n-\t\t\t\t}\n-\t\t\t\tpaths = getSecureApplicationPaths();\n-\t\t\t\tif (paths.length > 0) {\n-\t\t\t\t\tauthorizeUrls.antMatchers(getSecureApplicationPaths()).hasRole(\n-\t\t\t\t\t\t\tthis.security.getBasic().getRole());\n-\t\t\t\t}\n-\t\t\t\tauthorizeUrls.and().httpBasic();\n+\t\t\t\thttp.requestMatchers().antMatchers(paths);\n+\t\t\t\thttp.authorizeRequests().anyRequest()\n+\t\t\t\t\t\t.hasRole(this.security.getUser().getRole()) //\n+\t\t\t\t\t\t.and().httpBasic() //\n+\t\t\t\t\t\t.and().anonymous().disable();\n \t\t\t}\n-\n-\t\t\t// No cookies for service endpoints by default\n+\t\t\t// Remove this when session creation is disabled by default\n+\t\t\thttp.csrf().disable();\n+\t\t\t// No cookies for application endpoints by default\n \t\t\thttp.sessionManagement().sessionCreationPolicy(this.security.getSessions());\n+\n \t\t}\n \n \t\tprivate String[] getSecureApplicationPaths() {\n@@ -181,12 +178,74 @@ public class SecurityAutoConfiguration {\n \t\tpublic void configure(WebSecurity builder) throws Exception {\n \t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n \t\t\tignoring.antMatchers(this.security.getIgnored());\n-\t\t\tignoring.antMatchers(getEndpointPaths(false));\n \t\t\tif (this.errorController != null) {\n \t\t\t\tignoring.antMatchers(this.errorController.getErrorPath());\n \t\t\t}\n \t\t}\n \n+\t\t@Override\n+\t\tprotected AuthenticationManager authenticationManager() throws Exception {\n+\t\t\tAuthenticationManager manager = super.authenticationManager();\n+\t\t\tif (manager instanceof ProviderManager) {\n+\t\t\t\t((ProviderManager) manager)\n+\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n+\t\t\t}\n+\t\t\treturn manager;\n+\t\t}\n+\n+\t}\n+\n+\t// Give user-supplied filters a chance to be last in line\n+\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n+\tprivate static class ManagementWebSecurityConfigurerAdapter extends\n+\t\t\tWebSecurityConfigurerAdapter {\n+\n+\t\tprivate static final String[] NO_PATHS = new String[0];\n+\n+\t\t@Autowired\n+\t\tprivate SecurityProperties security;\n+\n+\t\t@Autowired\n+\t\tprivate ManagementServerProperties management;\n+\n+\t\t@Autowired(required = false)\n+\t\tprivate EndpointHandlerMapping endpointHandlerMapping;\n+\n+\t\t@Override\n+\t\tprotected void configure(HttpSecurity http) throws Exception {\n+\n+\t\t\tif (this.security.isRequireSsl()) {\n+\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n+\t\t\t}\n+\n+\t\t\tString[] paths = getEndpointPaths(true);\n+\t\t\tif (this.security.getBasic().isEnabled() && paths.length > 0) {\n+\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint());\n+\t\t\t\thttp.requestMatchers().antMatchers(paths);\n+\t\t\t\thttp.authorizeRequests().anyRequest()\n+\t\t\t\t\t\t.hasRole(this.security.getManagement().getRole()) //\n+\t\t\t\t\t\t.and().httpBasic() //\n+\t\t\t\t\t\t.and().anonymous().disable();\n+\t\t\t}\n+\t\t\t// No cookies for management endpoints by default\n+\t\t\thttp.csrf().disable();\n+\t\t\thttp.sessionManagement().sessionCreationPolicy(\n+\t\t\t\t\tthis.security.getManagement().getSessions());\n+\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void configure(WebSecurity builder) throws Exception {\n+\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n+\t\t\tignoring.antMatchers(getEndpointPaths(false));\n+\t\t}\n+\n+\t\tprivate AuthenticationEntryPoint entryPoint() {\n+\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n+\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n+\t\t\treturn entryPoint;\n+\t\t}\n+\n \t\tprivate String[] getEndpointPaths(boolean secure) {\n \t\t\tif (this.endpointHandlerMapping == null) {\n \t\t\t\treturn NO_PATHS;\n@@ -202,16 +261,6 @@ public class SecurityAutoConfiguration {\n \t\t\treturn paths.toArray(new String[paths.size()]);\n \t\t}\n \n-\t\t@Override\n-\t\tprotected AuthenticationManager authenticationManager() throws Exception {\n-\t\t\tAuthenticationManager manager = super.authenticationManager();\n-\t\t\tif (manager instanceof ProviderManager) {\n-\t\t\t\t((ProviderManager) manager)\n-\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n-\t\t\t}\n-\t\t\treturn manager;\n-\t\t}\n-\n \t}\n \n \t@ConditionalOnMissingBean(AuthenticationManager.class)\n@@ -222,23 +271,28 @@ public class SecurityAutoConfiguration {\n \t\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n \n \t\t@Autowired\n-\t\tprivate ManagementServerProperties management;\n+\t\tprivate SecurityProperties security;\n \n \t\t@Bean\n \t\tpublic AuthenticationManager authenticationManager() throws Exception {\n-\t\t\tUser user = this.management.getUser();\n+\n+\t\t\tInMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder(\n+\t\t\t\t\tObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication();\n+\t\t\tUser user = this.security.getUser();\n+\n \t\t\tif (user.isDefaultPassword()) {\n-\t\t\t\tlogger.info("Using default password for management endpoints: "\n+\t\t\t\tlogger.info("Using default password for application endpoints: "\n \t\t\t\t\t\t+ user.getPassword());\n \t\t\t}\n-\t\t\tList<String> roles = new ArrayList<String>();\n-\t\t\troles.add("USER");\n-\t\t\tif (!"USER".equals(user.getRole())) {\n-\t\t\t\troles.add(user.getRole());\n-\t\t\t}\n-\t\t\treturn new AuthenticationManagerBuilder().inMemoryAuthentication()\n-\t\t\t\t\t.withUser(user.getName()).password(user.getPassword())\n-\t\t\t\t\t.roles(roles.toArray(new String[roles.size()])).and().and().build();\n+\n+\t\t\tSet<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security\n+\t\t\t\t\t.getManagement().getRole(), user.getRole()));\n+\n+\t\t\tbuilder.withUser(user.getName()).password(user.getPassword())\n+\t\t\t\t\t.roles(roles.toArray(new String[roles.size()]));\n+\n+\t\t\treturn builder.and().build();\n+\n \t\t}\n \n \t}\n', 'source_code': '/*\n * Copyright 2012-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.properties.ManagementServerProperties;\nimport org.springframework.boot.actuate.properties.SecurityProperties;\nimport org.springframework.boot.actuate.properties.SecurityProperties.User;\nimport org.springframework.boot.actuate.web.ErrorController;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.DefaultAuthenticationEventPublisher;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.ObjectPostProcessor;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for security of a web application or\n * service. By default everything is secured with HTTP Basic authentication except the\n * {@link SecurityProperties#getIgnored() explicitly ignored} paths (defaults to\n * <code>&#47;css&#47;**, &#47;js&#47;**, &#47;images&#47;**, &#47;**&#47;favicon.ico</code>\n * ). Many aspects of the behavior can be controller with {@link SecurityProperties} via\n * externalized application properties (or via an bean definition of that type to set the\n * defaults). The user details for authentication are just placeholders\n * <code>(username=user,\n * password=password)</code> but can easily be customized by providing a bean definition\n * of type {@link AuthenticationManager}. Also provides audit logging of authentication\n * events.\n * \n * <p>\n * The framework {@link Endpoint}s (used to expose application information to operations)\n * include a {@link Endpoint#isSensitive() sensitive} configuration option which will be\n * used as a security hint by the filter created here.\n * \n * <p>\n * Some common simple customizations:\n * <ul>\n * <li>Switch off security completely and permanently: remove Spring Security from the\n * classpath or {@link EnableAutoConfiguration#exclude() exclude} this configuration.</li>\n * <li>Switch off security temporarily (e.g. for a dev environment): set\n * <code>security.basic.enabled: false</code></li>\n * <li>Customize the user details: add an AuthenticationManager bean</li>\n * <li>Add form login for user facing resources: add a\n * {@link WebSecurityConfigurerAdapter} and use {@link HttpSecurity#formLogin()}</li>\n * </ul>\n * \n * @author Dave Syer\n */\n@Configuration\n@ConditionalOnClass({ EnableWebSecurity.class })\n@EnableWebSecurity\n// (debug = true)\n@EnableConfigurationProperties\npublic class SecurityAutoConfiguration {\n\n\t@Bean(name = "org.springframework.actuate.properties.SecurityProperties")\n\t@ConditionalOnMissingBean\n\tpublic SecurityProperties securityProperties() {\n\t\treturn new SecurityProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic AuthenticationEventPublisher authenticationEventPublisher() {\n\t\treturn new DefaultAuthenticationEventPublisher();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ ApplicationWebSecurityConfigurerAdapter.class })\n\tpublic WebSecurityConfigurerAdapter applicationWebSecurityConfigurerAdapter() {\n\t\treturn new ApplicationWebSecurityConfigurerAdapter();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })\n\tpublic WebSecurityConfigurerAdapter managementWebSecurityConfigurerAdapter() {\n\t\treturn new ManagementWebSecurityConfigurerAdapter();\n\t}\n\n\t// Give user-supplied filters a chance to be last in line\n\t@Order(Ordered.LOWEST_PRECEDENCE - 5)\n\tprivate static class ApplicationWebSecurityConfigurerAdapter extends\n\t\t\tWebSecurityConfigurerAdapter {\n\n\t\t@Autowired\n\t\tprivate SecurityProperties security;\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher authenticationEventPublisher;\n\n\t\t@Autowired(required = false)\n\t\tprivate ErrorController errorController;\n\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\n\t\t\tif (this.security.isRequireSsl()) {\n\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n\t\t\t}\n\n\t\t\tString[] paths = getSecureApplicationPaths();\n\t\t\tif (this.security.getBasic().isEnabled() && paths.length > 0) {\n\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint());\n\t\t\t\thttp.requestMatchers().antMatchers(paths);\n\t\t\t\thttp.authorizeRequests().anyRequest()\n\t\t\t\t\t\t.hasRole(this.security.getUser().getRole()) //\n\t\t\t\t\t\t.and().httpBasic() //\n\t\t\t\t\t\t.and().anonymous().disable();\n\t\t\t}\n\t\t\t// Remove this when session creation is disabled by default\n\t\t\thttp.csrf().disable();\n\t\t\t// No cookies for application endpoints by default\n\t\t\thttp.sessionManagement().sessionCreationPolicy(this.security.getSessions());\n\n\t\t}\n\n\t\tprivate String[] getSecureApplicationPaths() {\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tfor (String path : this.security.getBasic().getPath()) {\n\t\t\t\tpath = (path == null ? "" : path.trim());\n\t\t\t\tif (path.equals("/**")) {\n\t\t\t\t\treturn new String[] { path };\n\t\t\t\t}\n\t\t\t\tif (!path.equals("")) {\n\t\t\t\t\tlist.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list.toArray(new String[list.size()]);\n\t\t}\n\n\t\tprivate AuthenticationEntryPoint entryPoint() {\n\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n\t\t\treturn entryPoint;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(WebSecurity builder) throws Exception {\n\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n\t\t\tignoring.antMatchers(this.security.getIgnored());\n\t\t\tif (this.errorController != null) {\n\t\t\t\tignoring.antMatchers(this.errorController.getErrorPath());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected AuthenticationManager authenticationManager() throws Exception {\n\t\t\tAuthenticationManager manager = super.authenticationManager();\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n\t\t\t}\n\t\t\treturn manager;\n\t\t}\n\n\t}\n\n\t// Give user-supplied filters a chance to be last in line\n\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n\tprivate static class ManagementWebSecurityConfigurerAdapter extends\n\t\t\tWebSecurityConfigurerAdapter {\n\n\t\tprivate static final String[] NO_PATHS = new String[0];\n\n\t\t@Autowired\n\t\tprivate SecurityProperties security;\n\n\t\t@Autowired\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Autowired(required = false)\n\t\tprivate EndpointHandlerMapping endpointHandlerMapping;\n\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\n\t\t\tif (this.security.isRequireSsl()) {\n\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n\t\t\t}\n\n\t\t\tString[] paths = getEndpointPaths(true);\n\t\t\tif (this.security.getBasic().isEnabled() && paths.length > 0) {\n\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint());\n\t\t\t\thttp.requestMatchers().antMatchers(paths);\n\t\t\t\thttp.authorizeRequests().anyRequest()\n\t\t\t\t\t\t.hasRole(this.security.getManagement().getRole()) //\n\t\t\t\t\t\t.and().httpBasic() //\n\t\t\t\t\t\t.and().anonymous().disable();\n\t\t\t}\n\t\t\t// No cookies for management endpoints by default\n\t\t\thttp.csrf().disable();\n\t\t\thttp.sessionManagement().sessionCreationPolicy(\n\t\t\t\t\tthis.security.getManagement().getSessions());\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(WebSecurity builder) throws Exception {\n\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n\t\t\tignoring.antMatchers(getEndpointPaths(false));\n\t\t}\n\n\t\tprivate AuthenticationEntryPoint entryPoint() {\n\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n\t\t\treturn entryPoint;\n\t\t}\n\n\t\tprivate String[] getEndpointPaths(boolean secure) {\n\t\t\tif (this.endpointHandlerMapping == null) {\n\t\t\t\treturn NO_PATHS;\n\t\t\t}\n\n\t\t\tList<Endpoint<?>> endpoints = this.endpointHandlerMapping.getEndpoints();\n\t\t\tList<String> paths = new ArrayList<String>(endpoints.size());\n\t\t\tfor (Endpoint<?> endpoint : endpoints) {\n\t\t\t\tif (endpoint.isSensitive() == secure) {\n\t\t\t\t\tpaths.add(endpoint.getPath());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paths.toArray(new String[paths.size()]);\n\t\t}\n\n\t}\n\n\t@ConditionalOnMissingBean(AuthenticationManager.class)\n\t@Configuration\n\tpublic static class AuthenticationManagerConfiguration {\n\n\t\tprivate static Log logger = LogFactory\n\t\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t\t@Autowired\n\t\tprivate SecurityProperties security;\n\n\t\t@Bean\n\t\tpublic AuthenticationManager authenticationManager() throws Exception {\n\n\t\t\tInMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder(\n\t\t\t\t\tObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication();\n\t\t\tUser user = this.security.getUser();\n\n\t\t\tif (user.isDefaultPassword()) {\n\t\t\t\tlogger.info("Using default password for application endpoints: "\n\t\t\t\t\t\t+ user.getPassword());\n\t\t\t}\n\n\t\t\tSet<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security\n\t\t\t\t\t.getManagement().getRole(), user.getRole()));\n\n\t\t\tbuilder.withUser(user.getName()).password(user.getPassword())\n\t\t\t\t\t.roles(roles.toArray(new String[roles.size()]));\n\n\t\t\treturn builder.and().build();\n\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.properties.ManagementServerProperties;\nimport org.springframework.boot.actuate.properties.ManagementServerProperties.User;\nimport org.springframework.boot.actuate.properties.SecurityProperties;\nimport org.springframework.boot.actuate.web.ErrorController;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.DefaultAuthenticationEventPublisher;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for security of a web application or\n * service. By default everything is secured with HTTP Basic authentication except the\n * {@link SecurityProperties#getIgnored() explicitly ignored} paths (defaults to\n * <code>&#47;css&#47;**, &#47;js&#47;**, &#47;images&#47;**, &#47;**&#47;favicon.ico</code>\n * ). Many aspects of the behavior can be controller with {@link SecurityProperties} via\n * externalized application properties (or via an bean definition of that type to set the\n * defaults). The user details for authentication are just placeholders\n * <code>(username=user,\n * password=password)</code> but can easily be customized by providing a bean definition\n * of type {@link AuthenticationManager}. Also provides audit logging of authentication\n * events.\n * \n * <p>\n * The framework {@link Endpoint}s (used to expose application information to operations)\n * include a {@link Endpoint#isSensitive() sensitive} configuration option which will be\n * used as a security hint by the filter created here.\n * \n * <p>\n * Some common simple customizations:\n * <ul>\n * <li>Switch off security completely and permanently: remove Spring Security from the\n * classpath or {@link EnableAutoConfiguration#exclude() exclude} this configuration.</li>\n * <li>Switch off security temporarily (e.g. for a dev environment): set\n * <code>security.basic.enabled: false</code></li>\n * <li>Customize the user details: add an AuthenticationManager bean</li>\n * <li>Add form login for user facing resources: add a\n * {@link WebSecurityConfigurerAdapter} and use {@link HttpSecurity#formLogin()}</li>\n * </ul>\n * \n * @author Dave Syer\n */\n@Configuration\n@ConditionalOnClass({ EnableWebSecurity.class })\n@EnableWebSecurity\n@EnableConfigurationProperties\npublic class SecurityAutoConfiguration {\n\n\t@Bean(name = "org.springframework.actuate.properties.SecurityProperties")\n\t@ConditionalOnMissingBean\n\tpublic SecurityProperties securityProperties() {\n\t\treturn new SecurityProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic AuthenticationEventPublisher authenticationEventPublisher() {\n\t\treturn new DefaultAuthenticationEventPublisher();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ BoostrapWebSecurityConfigurerAdapter.class })\n\tpublic WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() {\n\t\treturn new BoostrapWebSecurityConfigurerAdapter();\n\t}\n\n\t// Give user-supplied filters a chance to be last in line\n\t@Order(Ordered.LOWEST_PRECEDENCE - 10)\n\tprivate static class BoostrapWebSecurityConfigurerAdapter extends\n\t\t\tWebSecurityConfigurerAdapter {\n\n\t\tprivate static final String[] NO_PATHS = new String[0];\n\n\t\t@Autowired\n\t\tprivate SecurityProperties security;\n\n\t\t@Autowired\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Autowired(required = false)\n\t\tprivate EndpointHandlerMapping endpointHandlerMapping;\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher authenticationEventPublisher;\n\n\t\t@Autowired(required = false)\n\t\tprivate ErrorController errorController;\n\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\n\t\t\tif (this.security.isRequireSsl()) {\n\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n\t\t\t}\n\n\t\t\tif (this.security.getBasic().isEnabled()) {\n\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint());\n\t\t\t\thttp.httpBasic().and().anonymous().disable();\n\t\t\t\tExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http\n\t\t\t\t\t\t.authorizeUrls();\n\t\t\t\tString[] paths = getEndpointPaths(true);\n\t\t\t\tif (paths.length > 0) {\n\t\t\t\t\tauthorizeUrls.antMatchers(getEndpointPaths(true)).hasRole(\n\t\t\t\t\t\t\tthis.management.getUser().getRole());\n\t\t\t\t}\n\t\t\t\tpaths = getSecureApplicationPaths();\n\t\t\t\tif (paths.length > 0) {\n\t\t\t\t\tauthorizeUrls.antMatchers(getSecureApplicationPaths()).hasRole(\n\t\t\t\t\t\t\tthis.security.getBasic().getRole());\n\t\t\t\t}\n\t\t\t\tauthorizeUrls.and().httpBasic();\n\t\t\t}\n\n\t\t\t// No cookies for service endpoints by default\n\t\t\thttp.sessionManagement().sessionCreationPolicy(this.security.getSessions());\n\t\t}\n\n\t\tprivate String[] getSecureApplicationPaths() {\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tfor (String path : this.security.getBasic().getPath()) {\n\t\t\t\tpath = (path == null ? "" : path.trim());\n\t\t\t\tif (path.equals("/**")) {\n\t\t\t\t\treturn new String[] { path };\n\t\t\t\t}\n\t\t\t\tif (!path.equals("")) {\n\t\t\t\t\tlist.add(path);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list.toArray(new String[list.size()]);\n\t\t}\n\n\t\tprivate AuthenticationEntryPoint entryPoint() {\n\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n\t\t\treturn entryPoint;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(WebSecurity builder) throws Exception {\n\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n\t\t\tignoring.antMatchers(this.security.getIgnored());\n\t\t\tignoring.antMatchers(getEndpointPaths(false));\n\t\t\tif (this.errorController != null) {\n\t\t\t\tignoring.antMatchers(this.errorController.getErrorPath());\n\t\t\t}\n\t\t}\n\n\t\tprivate String[] getEndpointPaths(boolean secure) {\n\t\t\tif (this.endpointHandlerMapping == null) {\n\t\t\t\treturn NO_PATHS;\n\t\t\t}\n\n\t\t\tList<Endpoint<?>> endpoints = this.endpointHandlerMapping.getEndpoints();\n\t\t\tList<String> paths = new ArrayList<String>(endpoints.size());\n\t\t\tfor (Endpoint<?> endpoint : endpoints) {\n\t\t\t\tif (endpoint.isSensitive() == secure) {\n\t\t\t\t\tpaths.add(endpoint.getPath());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paths.toArray(new String[paths.size()]);\n\t\t}\n\n\t\t@Override\n\t\tprotected AuthenticationManager authenticationManager() throws Exception {\n\t\t\tAuthenticationManager manager = super.authenticationManager();\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n\t\t\t}\n\t\t\treturn manager;\n\t\t}\n\n\t}\n\n\t@ConditionalOnMissingBean(AuthenticationManager.class)\n\t@Configuration\n\tpublic static class AuthenticationManagerConfiguration {\n\n\t\tprivate static Log logger = LogFactory\n\t\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t\t@Autowired\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Bean\n\t\tpublic AuthenticationManager authenticationManager() throws Exception {\n\t\t\tUser user = this.management.getUser();\n\t\t\tif (user.isDefaultPassword()) {\n\t\t\t\tlogger.info("Using default password for management endpoints: "\n\t\t\t\t\t\t+ user.getPassword());\n\t\t\t}\n\t\t\tList<String> roles = new ArrayList<String>();\n\t\t\troles.add("USER");\n\t\t\tif (!"USER".equals(user.getRole())) {\n\t\t\t\troles.add(user.getRole());\n\t\t\t}\n\t\t\treturn new AuthenticationManagerBuilder().inMemoryAuthentication()\n\t\t\t\t\t.withUser(user.getName()).password(user.getPassword())\n\t\t\t\t\t.roles(roles.toArray(new String[roles.size()])).and().and().build();\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
