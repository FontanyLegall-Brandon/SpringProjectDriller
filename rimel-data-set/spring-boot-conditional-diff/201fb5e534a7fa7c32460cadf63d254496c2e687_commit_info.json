{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -25,6 +25,10 @@ import java.util.Map.Entry;\n \n import javax.annotation.PostConstruct;\n \n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.ListableBeanFactory;\n@@ -47,6 +51,9 @@ import com.fasterxml.jackson.databind.Module;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\n+import com.fasterxml.jackson.datatype.joda.ser.JacksonJodaFormat;\n \n /**\n  * Auto configuration for Jackson. The following auto-configuration will get applied:\n@@ -97,6 +104,50 @@ public class JacksonAutoConfiguration {\n \n \t}\n \n+\t@Configuration\n+\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class,\n+\t\t\tDateTimeSerializer.class })\n+\tstatic class JodaDateTimeJacksonConfiguration {\n+\n+\t\tprivate final Log log = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n+\n+\t\t@Autowired\n+\t\tprivate JacksonProperties jacksonProperties;\n+\n+\t\t@Bean\n+\t\tpublic Module jodaDateTimeSerializationModule() {\n+\t\t\tSimpleModule module = new SimpleModule();\n+\n+\t\t\tJacksonJodaFormat jacksonJodaFormat = null;\n+\n+\t\t\tif (this.jacksonProperties.getJodaDateTimeFormat() != null) {\n+\t\t\t\tjacksonJodaFormat = new JacksonJodaFormat(DateTimeFormat.forPattern(\n+\t\t\t\t\t\tthis.jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n+\t\t\t}\n+\t\t\telse if (this.jacksonProperties.getDateFormat() != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tjacksonJodaFormat = new JacksonJodaFormat(DateTimeFormat.forPattern(\n+\t\t\t\t\t\t\tthis.jacksonProperties.getDateFormat()).withZoneUTC());\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\tif (this.log.isWarnEnabled()) {\n+\t\t\t\t\t\tthis.log.warn("spring.jackson.date-format could not be used to "\n+\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n+\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as "\n+\t\t\t\t\t\t\t\t+ "well.");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (jacksonJodaFormat != null) {\n+\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(\n+\t\t\t\t\t\tjacksonJodaFormat));\n+\t\t\t}\n+\n+\t\t\treturn module;\n+\t\t}\n+\t}\n+\n \t@Configuration\n \t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n \t@EnableConfigurationProperties({ HttpMapperProperties.class, JacksonProperties.class })\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport javax.annotation.PostConstruct;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.joda.time.DateTime;\nimport org.joda.time.format.DateTimeFormat;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.web.HttpMapperProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\nimport com.fasterxml.jackson.datatype.joda.ser.JacksonJodaFormat;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @since 1.1.0\n */\n@Configuration\n@ConditionalOnClass(ObjectMapper.class)\n@SuppressWarnings("deprecation")\npublic class JacksonAutoConfiguration {\n\n\t@Autowired\n\tprivate ListableBeanFactory beanFactory;\n\n\t@PostConstruct\n\tprivate void registerModulesWithObjectMappers() {\n\t\tCollection<Module> modules = getBeans(this.beanFactory, Module.class);\n\t\tfor (ObjectMapper objectMapper : getBeans(this.beanFactory, ObjectMapper.class)) {\n\t\t\tobjectMapper.registerModules(modules);\n\t\t}\n\t}\n\n\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory,\n\t\t\tClass<T> type) {\n\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type).values();\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(ObjectMapper.class)\n\t\tpublic ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class,\n\t\t\tDateTimeSerializer.class })\n\tstatic class JodaDateTimeJacksonConfiguration {\n\n\t\tprivate final Log log = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Bean\n\t\tpublic Module jodaDateTimeSerializationModule() {\n\t\t\tSimpleModule module = new SimpleModule();\n\n\t\t\tJacksonJodaFormat jacksonJodaFormat = null;\n\n\t\t\tif (this.jacksonProperties.getJodaDateTimeFormat() != null) {\n\t\t\t\tjacksonJodaFormat = new JacksonJodaFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\tthis.jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n\t\t\t}\n\t\t\telse if (this.jacksonProperties.getDateFormat() != null) {\n\t\t\t\ttry {\n\t\t\t\t\tjacksonJodaFormat = new JacksonJodaFormat(DateTimeFormat.forPattern(\n\t\t\t\t\t\t\tthis.jacksonProperties.getDateFormat()).withZoneUTC());\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (this.log.isWarnEnabled()) {\n\t\t\t\t\t\tthis.log.warn("spring.jackson.date-format could not be used to "\n\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as "\n\t\t\t\t\t\t\t\t+ "well.");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (jacksonJodaFormat != null) {\n\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(\n\t\t\t\t\t\tjacksonJodaFormat));\n\t\t\t}\n\n\t\t\treturn module;\n\t\t}\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\t@EnableConfigurationProperties({ HttpMapperProperties.class, JacksonProperties.class })\n\tstatic class JacksonObjectMapperBuilderConfiguration implements\n\t\t\tApplicationContextAware {\n\n\t\tprivate ApplicationContext applicationContext;\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Autowired\n\t\tprivate HttpMapperProperties httpMapperProperties;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(Jackson2ObjectMapperBuilder.class)\n\t\tpublic Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder() {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\tBoolean isJsonSortKeys = this.httpMapperProperties.isJsonSortKeys();\n\t\t\tif (isJsonSortKeys != null && isJsonSortKeys) {\n\t\t\t\tbuilder.featuresToEnable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS);\n\t\t\t}\n\t\t\tBoolean isJsonPrettyPrint = this.httpMapperProperties.isJsonPrettyPrint();\n\t\t\tif (isJsonPrettyPrint != null && isJsonPrettyPrint) {\n\t\t\t\tbuilder.featuresToEnable(SerializationFeature.INDENT_OUTPUT);\n\t\t\t}\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\tconfigureDateFormat(builder);\n\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\tconfigureModules(builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tMap<?, Boolean> features) {\n\t\t\tfor (Entry<?, Boolean> entry : features.entrySet()) {\n\t\t\t\tif (entry.getValue() != null && entry.getValue()) {\n\t\t\t\t\tbuilder.featuresToEnable(entry.getKey());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.featuresToDisable(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t// pattern string value\n\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\tif (dateFormat != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils\n\t\t\t\t\t\t\t.instantiateClass(dateFormatClass));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tbuilder.dateFormat(new SimpleDateFormat(dateFormat));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t// names in PropertyNamingStrategy which hold default provided implementations\n\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\tif (strategy != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder,\n\t\t\t\t\t\t\tClassUtils.forName(strategy, null));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyClass(\n\t\t\t\tJackson2ObjectMapperBuilder builder, Class<?> propertyNamingStrategyClass) {\n\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) BeanUtils\n\t\t\t\t\t.instantiateClass(propertyNamingStrategyClass));\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyField(\n\t\t\t\tJackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t// that may be added by Jackson in the future)\n\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class,\n\t\t\t\t\tfieldName, PropertyNamingStrategy.class);\n\t\t\tAssert.notNull(field, "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\ttry {\n\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext,\n\t\t\t\t\tModule.class);\n\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[moduleBeans.size()]));\n\t\t}\n\n\t\t@Override\n\t\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\t\tthis.applicationContext = applicationContext;\n\t\t}\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.web.HttpMapperProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.SerializationFeature;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @since 1.1.0\n */\n@Configuration\n@ConditionalOnClass(ObjectMapper.class)\n@SuppressWarnings("deprecation")\npublic class JacksonAutoConfiguration {\n\n\t@Autowired\n\tprivate ListableBeanFactory beanFactory;\n\n\t@PostConstruct\n\tprivate void registerModulesWithObjectMappers() {\n\t\tCollection<Module> modules = getBeans(this.beanFactory, Module.class);\n\t\tfor (ObjectMapper objectMapper : getBeans(this.beanFactory, ObjectMapper.class)) {\n\t\t\tobjectMapper.registerModules(modules);\n\t\t}\n\t}\n\n\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory,\n\t\t\tClass<T> type) {\n\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type).values();\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean(ObjectMapper.class)\n\t\tpublic ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })\n\t@EnableConfigurationProperties({ HttpMapperProperties.class, JacksonProperties.class })\n\tstatic class JacksonObjectMapperBuilderConfiguration implements\n\t\t\tApplicationContextAware {\n\n\t\tprivate ApplicationContext applicationContext;\n\n\t\t@Autowired\n\t\tprivate JacksonProperties jacksonProperties;\n\n\t\t@Autowired\n\t\tprivate HttpMapperProperties httpMapperProperties;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(Jackson2ObjectMapperBuilder.class)\n\t\tpublic Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder() {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(this.applicationContext);\n\t\t\tBoolean isJsonSortKeys = this.httpMapperProperties.isJsonSortKeys();\n\t\t\tif (isJsonSortKeys != null && isJsonSortKeys) {\n\t\t\t\tbuilder.featuresToEnable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS);\n\t\t\t}\n\t\t\tBoolean isJsonPrettyPrint = this.httpMapperProperties.isJsonPrettyPrint();\n\t\t\tif (isJsonPrettyPrint != null && isJsonPrettyPrint) {\n\t\t\t\tbuilder.featuresToEnable(SerializationFeature.INDENT_OUTPUT);\n\t\t\t}\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\tconfigureDateFormat(builder);\n\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\tconfigureModules(builder);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tMap<?, Boolean> features) {\n\t\t\tfor (Entry<?, Boolean> entry : features.entrySet()) {\n\t\t\t\tif (entry.getValue() != null && entry.getValue()) {\n\t\t\t\t\tbuilder.featuresToEnable(entry.getKey());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.featuresToDisable(entry.getKey());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t// pattern string value\n\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\tif (dateFormat != null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils\n\t\t\t\t\t\t\t.instantiateClass(dateFormatClass));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tbuilder.dateFormat(new SimpleDateFormat(dateFormat));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t// names in PropertyNamingStrategy which hold default provided implementations\n\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\tif (strategy != null) {\n\t\t\t\ttry {\n\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder,\n\t\t\t\t\t\t\tClassUtils.forName(strategy, null));\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyClass(\n\t\t\t\tJackson2ObjectMapperBuilder builder, Class<?> propertyNamingStrategyClass) {\n\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) BeanUtils\n\t\t\t\t\t.instantiateClass(propertyNamingStrategyClass));\n\t\t}\n\n\t\tprivate void configurePropertyNamingStrategyField(\n\t\t\t\tJackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t// that may be added by Jackson in the future)\n\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class,\n\t\t\t\t\tfieldName, PropertyNamingStrategy.class);\n\t\t\tAssert.notNull(field, "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\ttry {\n\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext,\n\t\t\t\t\tModule.class);\n\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[moduleBeans.size()]));\n\t\t}\n\n\t\t@Override\n\t\tpublic void setApplicationContext(ApplicationContext applicationContext) {\n\t\t\tthis.applicationContext = applicationContext;\n\t\t}\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
