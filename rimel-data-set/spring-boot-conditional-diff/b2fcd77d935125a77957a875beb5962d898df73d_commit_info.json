{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -29,13 +29,11 @@ import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n import org.springframework.beans.BeansException;\n import org.springframework.beans.factory.BeanFactory;\n-import org.springframework.beans.factory.BeanFactoryUtils;\n-import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n+import org.springframework.beans.factory.BeanFactoryAware;\n import org.springframework.beans.factory.SmartInitializingSingleton;\n+import org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\n import org.springframework.beans.factory.config.BeanDefinition;\n import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n-import org.springframework.beans.factory.support.DefaultListableBeanFactory;\n-import org.springframework.beans.factory.support.RootBeanDefinition;\n import org.springframework.boot.actuate.endpoint.Endpoint;\n import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n@@ -49,6 +47,7 @@ import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfigura\n import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;\n import org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration;\n import org.springframework.boot.autoconfigure.web.ServerProperties;\n+import org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration;\n import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;\n import org.springframework.boot.bind.RelaxedPropertyResolver;\n import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;\n@@ -62,11 +61,14 @@ import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.ConditionContext;\n import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.ConfigurationCondition;\n import org.springframework.context.annotation.Import;\n import org.springframework.context.event.ContextClosedEvent;\n import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.Environment;\n import org.springframework.core.env.PropertySource;\n import org.springframework.core.type.AnnotatedTypeMetadata;\n+import org.springframework.core.type.MethodMetadata;\n import org.springframework.web.context.WebApplicationContext;\n import org.springframework.web.filter.OncePerRequestFilter;\n import org.springframework.web.servlet.DispatcherServlet;\n@@ -92,22 +94,24 @@ import org.springframework.web.servlet.DispatcherServlet;\n \t\tManagementServerPropertiesAutoConfiguration.class,\n \t\tHypermediaAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class })\n public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n-\t\tSmartInitializingSingleton {\n+\t\tBeanFactoryAware, SmartInitializingSingleton {\n \n-\tprivate static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);\n+\tprivate static final Log logger = LogFactory\n+\t\t\t.getLog(EndpointWebMvcAutoConfiguration.class);\n \n \tprivate ApplicationContext applicationContext;\n \n+\tprivate BeanFactory beanFactory;\n+\n \t@Override\n \tpublic void setApplicationContext(ApplicationContext applicationContext)\n \t\t\tthrows BeansException {\n \t\tthis.applicationContext = applicationContext;\n \t}\n \n-\t@Conditional(OnManagementMvcCondition.class)\n-\t@Configuration\n-\t@Import(EndpointWebMvcImportSelector.class)\n-\tprotected static class EndpointWebMvcConfiguration {\n+\t@Override\n+\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n+\t\tthis.beanFactory = beanFactory;\n \t}\n \n \t@Bean\n@@ -117,8 +121,11 @@ public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n \n \t@Override\n \tpublic void afterSingletonsInstantiated() {\n-\t\tManagementServerPort managementPort = ManagementServerPort\n-\t\t\t\t.get(this.applicationContext);\n+\t\tManagementServerPort managementPort = ManagementServerPort.DIFFERENT;\n+\t\tif (this.applicationContext instanceof WebApplicationContext) {\n+\t\t\tmanagementPort = ManagementServerPort.get(\n+\t\t\t\t\tthis.applicationContext.getEnvironment(), this.beanFactory);\n+\t\t}\n \t\tif (managementPort == ManagementServerPort.DIFFERENT\n \t\t\t\t&& this.applicationContext instanceof EmbeddedWebApplicationContext\n \t\t\t\t&& ((EmbeddedWebApplicationContext) this.applicationContext)\n@@ -191,6 +198,12 @@ public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n \n \t}\n \n+\t@Configuration\n+\t@Conditional(OnManagementMvcCondition.class)\n+\t@Import(EndpointWebMvcImportSelector.class)\n+\tprotected static class EndpointWebMvcConfiguration {\n+\t}\n+\n \t/**\n \t * {@link OncePerRequestFilter} to add the {@literal X-Application-Context} if\n \t * required.\n@@ -261,122 +274,91 @@ public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n \n \t}\n \n-\tprotected static enum ManagementServerPort {\n+\tprivate static class OnManagementMvcCondition extends SpringBootCondition\n+\t\t\timplements ConfigurationCondition {\n \n-\t\tDISABLE, SAME, DIFFERENT;\n+\t\t@Override\n+\t\tpublic ConfigurationPhase getConfigurationPhase() {\n+\t\t\treturn ConfigurationPhase.REGISTER_BEAN;\n+\t\t}\n \n-\t\tpublic static ManagementServerPort get(BeanFactory beanFactory) {\n-\t\t\tServerProperties serverProperties;\n-\t\t\ttry {\n-\t\t\t\tserverProperties = beanFactory.getBean(ServerProperties.class);\n-\t\t\t}\n-\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n-\t\t\t\tserverProperties = new ServerProperties();\n-\t\t\t}\n-\t\t\tManagementServerProperties managementServerProperties;\n-\t\t\ttry {\n-\t\t\t\tmanagementServerProperties = beanFactory\n-\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n-\t\t\t}\n-\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n-\t\t\t\tmanagementServerProperties = new ManagementServerProperties();\n-\t\t\t}\n-\t\t\tInteger port = managementServerProperties.getPort();\n-\t\t\tif (port != null && port < 0) {\n-\t\t\t\treturn DISABLE;\n-\t\t\t}\n-\t\t\tif (!(beanFactory instanceof WebApplicationContext)) {\n-\t\t\t\t// Current context is not a webapp\n-\t\t\t\treturn DIFFERENT;\n+\t\t@Override\n+\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n+\t\t\t\tAnnotatedTypeMetadata metadata) {\n+\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n+\t\t\t\treturn ConditionOutcome.noMatch("Non WebApplicationContext");\n \t\t\t}\n-\t\t\treturn ((port == null)\n-\t\t\t\t\t|| (serverProperties.getPort() == null && port.equals(8080))\n-\t\t\t\t\t|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME\n-\t\t\t\t\t: DIFFERENT);\n+\t\t\tManagementServerPort port = ManagementServerPort.get(\n+\t\t\t\t\tcontext.getEnvironment(), context.getBeanFactory());\n+\t\t\treturn new ConditionOutcome(port == ManagementServerPort.SAME,\n+\t\t\t\t\t"Management context");\n \t\t}\n \n \t}\n \n-\tprivate static class OnManagementMvcCondition extends SpringBootCondition {\n+\tprotected static enum ManagementServerPort {\n \n-\t\t@Override\n-\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n-\t\t\t\tAnnotatedTypeMetadata metadata) {\n-\t\t\tRelaxedPropertyResolver management = new RelaxedPropertyResolver(\n-\t\t\t\t\tcontext.getEnvironment(), "management.");\n-\t\t\tRelaxedPropertyResolver server = new RelaxedPropertyResolver(\n-\t\t\t\t\tcontext.getEnvironment(), "server.");\n-\t\t\tInteger managementPort = management.getProperty("port", Integer.class);\n-\t\t\tif (managementPort == null) {\n-\t\t\t\tManagementServerProperties managementServerProperties = getBeanCarefully(\n-\t\t\t\t\t\tcontext, ManagementServerProperties.class);\n-\t\t\t\tif (managementServerProperties != null) {\n-\t\t\t\t\tmanagementPort = managementServerProperties.getPort();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (managementPort != null && managementPort < 0) {\n-\t\t\t\treturn new ConditionOutcome(false, "The mangagement port is disabled");\n+\t\tDISABLE, SAME, DIFFERENT;\n+\n+\t\tpublic static ManagementServerPort get(Environment environment,\n+\t\t\t\tBeanFactory beanFactory) {\n+\t\t\tInteger serverPort = getPortProperty(environment, "server.");\n+\t\t\tif (serverPort == null\n+\t\t\t\t\t&& hasCustomBeanDefinition(beanFactory, ServerProperties.class,\n+\t\t\t\t\t\t\tServerPropertiesAutoConfiguration.class)) {\n+\t\t\t\tServerProperties bean = beanFactory.getBean(ServerProperties.class);\n+\t\t\t\tserverPort = bean.getPort();\n \t\t\t}\n-\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n-\t\t\t\t// Current context is not a webapp\n-\t\t\t\treturn new ConditionOutcome(false, "The context is not a webapp");\n+\t\t\tInteger managementPort = getPortProperty(environment, "management.");\n+\t\t\tif (managementPort == null\n+\t\t\t\t\t&& hasCustomBeanDefinition(beanFactory,\n+\t\t\t\t\t\t\tManagementServerProperties.class,\n+\t\t\t\t\t\t\tManagementServerPropertiesAutoConfiguration.class)) {\n+\t\t\t\tManagementServerProperties bean = beanFactory\n+\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n+\t\t\t\tmanagementPort = bean.getPort();\n \t\t\t}\n-\t\t\tInteger serverPort = server.getProperty("port", Integer.class);\n-\t\t\tif (serverPort == null) {\n-\t\t\t\tServerProperties serverProperties = getBeanCarefully(context,\n-\t\t\t\t\t\tServerProperties.class);\n-\t\t\t\tif (serverProperties != null) {\n-\t\t\t\t\tserverPort = serverProperties.getPort();\n-\t\t\t\t}\n+\t\t\tif (managementPort != null && managementPort < 0) {\n+\t\t\t\treturn DISABLE;\n \t\t\t}\n-\t\t\tif ((managementPort == null)\n+\t\t\treturn ((managementPort == null)\n \t\t\t\t\t|| (serverPort == null && managementPort.equals(8080))\n-\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort))) {\n-\t\t\t\treturn ConditionOutcome\n-\t\t\t\t\t\t.match("The main context is the management context");\n-\t\t\t}\n-\t\t\treturn ConditionOutcome\n-\t\t\t\t\t.noMatch("The main context is not the management context");\n+\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort)) ? SAME\n+\t\t\t\t\t: DIFFERENT);\n \t\t}\n \n-\t\tprivate <T> T getBeanCarefully(ConditionContext context, Class<T> type) {\n-\t\t\tString[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n-\t\t\t\t\tcontext.getBeanFactory(), type, false, false);\n-\t\t\tif (names.length == 1) {\n-\t\t\t\tBeanDefinition original = findBeanDefinition(context.getBeanFactory(),\n-\t\t\t\t\t\tnames[0]);\n-\t\t\t\tif (original instanceof RootBeanDefinition) {\n-\t\t\t\t\tDefaultListableBeanFactory temp = new DefaultListableBeanFactory();\n-\t\t\t\t\ttemp.setParentBeanFactory(context.getBeanFactory());\n-\t\t\t\t\ttemp.registerBeanDefinition("bean",\n-\t\t\t\t\t\t\t((RootBeanDefinition) original).cloneBeanDefinition());\n-\t\t\t\t\treturn temp.getBean(type);\n-\t\t\t\t}\n-\t\t\t\treturn BeanFactoryUtils.beanOfType(context.getBeanFactory(), type, false,\n-\t\t\t\t\t\tfalse);\n+\t\tprivate static Integer getPortProperty(Environment environment, String prefix) {\n+\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n+\t\t\t\t\tprefix);\n+\t\t\treturn resolver.getProperty("port", Integer.class);\n+\t\t}\n+\n+\t\tprivate static <T> boolean hasCustomBeanDefinition(BeanFactory beanFactory,\n+\t\t\t\tClass<T> type, Class<?> configClass) {\n+\t\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory)) {\n+\t\t\t\treturn false;\n \t\t\t}\n-\t\t\t;\n-\t\t\treturn null;\n+\t\t\treturn hasCustomBeanDefinition((ConfigurableListableBeanFactory) beanFactory,\n+\t\t\t\t\ttype, configClass);\n \t\t}\n \n-\t\tprivate BeanDefinition findBeanDefinition(\n-\t\t\t\tConfigurableListableBeanFactory beanFactory, String name) {\n-\t\t\tBeanDefinition original = null;\n-\t\t\twhile (beanFactory != null && original == null) {\n-\t\t\t\tif (beanFactory.containsLocalBean(name)) {\n-\t\t\t\t\toriginal = beanFactory.getBeanDefinition(name);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tBeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();\n-\t\t\t\t\tif (parentBeanFactory instanceof ConfigurableListableBeanFactory) {\n-\t\t\t\t\t\tbeanFactory = (ConfigurableListableBeanFactory) parentBeanFactory;\n-\t\t\t\t\t}\n-\t\t\t\t\telse {\n-\t\t\t\t\t\tbeanFactory = null;\n-\t\t\t\t\t}\n+\t\tprivate static <T> boolean hasCustomBeanDefinition(\n+\t\t\t\tConfigurableListableBeanFactory beanFactory, Class<T> type,\n+\t\t\t\tClass<?> configClass) {\n+\t\t\tString[] names = beanFactory.getBeanNamesForType(type, true, false);\n+\t\t\tif (names == null || names.length != 1) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(names[0]);\n+\t\t\tif (definition instanceof AnnotatedBeanDefinition) {\n+\t\t\t\tMethodMetadata factoryMethodMetadata = ((AnnotatedBeanDefinition) definition)\n+\t\t\t\t\t\t.getFactoryMethodMetadata();\n+\t\t\t\tif (factoryMethodMetadata != null) {\n+\t\t\t\t\tString className = factoryMethodMetadata.getDeclaringClassName();\n+\t\t\t\t\treturn !configClass.getName().equals(className);\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn original;\n+\t\t\treturn true;\n \t\t}\n \n \t}\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.annotation.AnnotatedBeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerException;\nimport org.springframework.boot.context.embedded.EmbeddedWebApplicationContext;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ConfigurationCondition;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.core.env.ConfigurableEnvironment;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.core.type.MethodMetadata;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n * @author Christian Dupuis\n * @author Andy Wilkinson\n * @author Johannes Stelzer\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tEmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tManagementServerPropertiesAutoConfiguration.class,\n\t\tHypermediaAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n\t\tBeanFactoryAware, SmartInitializingSingleton {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\tprivate BeanFactory beanFactory;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tthis.beanFactory = beanFactory;\n\t}\n\n\t@Bean\n\tpublic ManagementContextResolver managementContextResolver() {\n\t\treturn new ManagementContextResolver(this.applicationContext);\n\t}\n\n\t@Override\n\tpublic void afterSingletonsInstantiated() {\n\t\tManagementServerPort managementPort = ManagementServerPort.DIFFERENT;\n\t\tif (this.applicationContext instanceof WebApplicationContext) {\n\t\t\tmanagementPort = ManagementServerPort.get(\n\t\t\t\t\tthis.applicationContext.getEnvironment(), this.beanFactory);\n\t\t}\n\t\tif (managementPort == ManagementServerPort.DIFFERENT\n\t\t\t\t&& this.applicationContext instanceof EmbeddedWebApplicationContext\n\t\t\t\t&& ((EmbeddedWebApplicationContext) this.applicationContext)\n\t\t\t\t\t\t.getEmbeddedServletContainer() != null) {\n\t\t\tcreateChildManagementContext();\n\t\t}\n\t\tif (managementPort == ManagementServerPort.SAME\n\t\t\t\t&& this.applicationContext.getEnvironment() instanceof ConfigurableEnvironment) {\n\t\t\taddLocalManagementPortPropertyAlias((ConfigurableEnvironment) this.applicationContext\n\t\t\t\t\t.getEnvironment());\n\t\t}\n\t}\n\n\tprivate void createChildManagementContext() {\n\t\tfinal AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setNamespace("management");\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tEmbeddedServletContainerAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\t\tCloseEventPropagationListener\n\t\t\t\t.addIfPossible(this.applicationContext, childContext);\n\t\ttry {\n\t\t\tchildContext.refresh();\n\t\t\tmanagementContextResolver().setApplicationContext(childContext);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// No support currently for deploying a war with management.port=<different>,\n\t\t\t// and this is the signature of that happening\n\t\t\tif (ex instanceof EmbeddedServletContainerException\n\t\t\t\t\t|| ex.getCause() instanceof EmbeddedServletContainerException) {\n\t\t\t\tlogger.warn("Could not start embedded container (management endpoints are still available through JMX)");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add an alias for \'local.management.port\' that actually resolves using\n\t * \'local.server.port\'.\n\t * @param environment the environment\n\t */\n\tprivate void addLocalManagementPortPropertyAlias(\n\t\t\tfinal ConfigurableEnvironment environment) {\n\t\tenvironment.getPropertySources().addLast(\n\t\t\t\tnew PropertySource<Object>("Management Server") {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getProperty(String name) {\n\t\t\t\t\t\tif ("local.management.port".equals(name)) {\n\t\t\t\t\t\t\treturn environment.getProperty("local.server.port");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\tprotected static class ApplicationContextFilterConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter applicationContextIdFilter(ApplicationContext context) {\n\t\t\treturn new ApplicationContextHeaderFilter(context);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(OnManagementMvcCondition.class)\n\t@Import(EndpointWebMvcImportSelector.class)\n\tprotected static class EndpointWebMvcConfiguration {\n\t}\n\n\t/**\n\t * {@link OncePerRequestFilter} to add the {@literal X-Application-Context} if\n\t * required.\n\t */\n\tprivate static class ApplicationContextHeaderFilter extends OncePerRequestFilter {\n\n\t\tprivate final ApplicationContext applicationContext;\n\n\t\tprivate ManagementServerProperties properties;\n\n\t\tpublic ApplicationContextHeaderFilter(ApplicationContext applicationContext) {\n\t\t\tthis.applicationContext = applicationContext;\n\t\t}\n\n\t\t@Override\n\t\tprotected void doFilterInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, FilterChain filterChain)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tif (this.properties == null) {\n\t\t\t\tthis.properties = this.applicationContext\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t}\n\t\t\tif (this.properties.getAddApplicationContextHeader()) {\n\t\t\t\tresponse.addHeader("X-Application-Context",\n\t\t\t\t\t\tthis.applicationContext.getId());\n\t\t\t}\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to propagate the {@link ContextClosedEvent} from a\n\t * parent to a child.\n\t */\n\tprivate static class CloseEventPropagationListener implements\n\t\t\tApplicationListener<ContextClosedEvent> {\n\n\t\tprivate final ApplicationContext parentContext;\n\n\t\tprivate final ConfigurableApplicationContext childContext;\n\n\t\tpublic CloseEventPropagationListener(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tthis.parentContext = parentContext;\n\t\t\tthis.childContext = childContext;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\t\tif (event.getApplicationContext() == this.parentContext) {\n\t\t\t\tthis.childContext.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic static void addIfPossible(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tif (parentContext instanceof ConfigurableApplicationContext) {\n\t\t\t\tadd((ConfigurableApplicationContext) parentContext, childContext);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void add(ConfigurableApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tparentContext.addApplicationListener(new CloseEventPropagationListener(\n\t\t\t\t\tparentContext, childContext));\n\t\t}\n\n\t}\n\n\tprivate static class OnManagementMvcCondition extends SpringBootCondition\n\t\t\timplements ConfigurationCondition {\n\n\t\t@Override\n\t\tpublic ConfigurationPhase getConfigurationPhase() {\n\t\t\treturn ConfigurationPhase.REGISTER_BEAN;\n\t\t}\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n\t\t\t\treturn ConditionOutcome.noMatch("Non WebApplicationContext");\n\t\t\t}\n\t\t\tManagementServerPort port = ManagementServerPort.get(\n\t\t\t\t\tcontext.getEnvironment(), context.getBeanFactory());\n\t\t\treturn new ConditionOutcome(port == ManagementServerPort.SAME,\n\t\t\t\t\t"Management context");\n\t\t}\n\n\t}\n\n\tprotected static enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(Environment environment,\n\t\t\t\tBeanFactory beanFactory) {\n\t\t\tInteger serverPort = getPortProperty(environment, "server.");\n\t\t\tif (serverPort == null\n\t\t\t\t\t&& hasCustomBeanDefinition(beanFactory, ServerProperties.class,\n\t\t\t\t\t\t\tServerPropertiesAutoConfiguration.class)) {\n\t\t\t\tServerProperties bean = beanFactory.getBean(ServerProperties.class);\n\t\t\t\tserverPort = bean.getPort();\n\t\t\t}\n\t\t\tInteger managementPort = getPortProperty(environment, "management.");\n\t\t\tif (managementPort == null\n\t\t\t\t\t&& hasCustomBeanDefinition(beanFactory,\n\t\t\t\t\t\t\tManagementServerProperties.class,\n\t\t\t\t\t\t\tManagementServerPropertiesAutoConfiguration.class)) {\n\t\t\t\tManagementServerProperties bean = beanFactory\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t\tmanagementPort = bean.getPort();\n\t\t\t}\n\t\t\tif (managementPort != null && managementPort < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\treturn ((managementPort == null)\n\t\t\t\t\t|| (serverPort == null && managementPort.equals(8080))\n\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort)) ? SAME\n\t\t\t\t\t: DIFFERENT);\n\t\t}\n\n\t\tprivate static Integer getPortProperty(Environment environment, String prefix) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n\t\t\t\t\tprefix);\n\t\t\treturn resolver.getProperty("port", Integer.class);\n\t\t}\n\n\t\tprivate static <T> boolean hasCustomBeanDefinition(BeanFactory beanFactory,\n\t\t\t\tClass<T> type, Class<?> configClass) {\n\t\t\tif (!(beanFactory instanceof ConfigurableListableBeanFactory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn hasCustomBeanDefinition((ConfigurableListableBeanFactory) beanFactory,\n\t\t\t\t\ttype, configClass);\n\t\t}\n\n\t\tprivate static <T> boolean hasCustomBeanDefinition(\n\t\t\t\tConfigurableListableBeanFactory beanFactory, Class<T> type,\n\t\t\t\tClass<?> configClass) {\n\t\t\tString[] names = beanFactory.getBeanNamesForType(type, true, false);\n\t\t\tif (names == null || names.length != 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(names[0]);\n\t\t\tif (definition instanceof AnnotatedBeanDefinition) {\n\t\t\t\tMethodMetadata factoryMethodMetadata = ((AnnotatedBeanDefinition) definition)\n\t\t\t\t\t\t.getFactoryMethodMetadata();\n\t\t\t\tif (factoryMethodMetadata != null) {\n\t\t\t\t\tString className = factoryMethodMetadata.getDeclaringClassName();\n\t\t\t\t\treturn !configClass.getName().equals(className);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerException;\nimport org.springframework.boot.context.embedded.EmbeddedWebApplicationContext;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.core.env.ConfigurableEnvironment;\nimport org.springframework.core.env.PropertySource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n *\n * @author Dave Syer\n * @author Phillip Webb\n * @author Christian Dupuis\n * @author Andy Wilkinson\n * @author Johannes Stelzer\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tEmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tManagementServerPropertiesAutoConfiguration.class,\n\t\tHypermediaAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n\t\tSmartInitializingSingleton {\n\n\tprivate static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Conditional(OnManagementMvcCondition.class)\n\t@Configuration\n\t@Import(EndpointWebMvcImportSelector.class)\n\tprotected static class EndpointWebMvcConfiguration {\n\t}\n\n\t@Bean\n\tpublic ManagementContextResolver managementContextResolver() {\n\t\treturn new ManagementContextResolver(this.applicationContext);\n\t}\n\n\t@Override\n\tpublic void afterSingletonsInstantiated() {\n\t\tManagementServerPort managementPort = ManagementServerPort\n\t\t\t\t.get(this.applicationContext);\n\t\tif (managementPort == ManagementServerPort.DIFFERENT\n\t\t\t\t&& this.applicationContext instanceof EmbeddedWebApplicationContext\n\t\t\t\t&& ((EmbeddedWebApplicationContext) this.applicationContext)\n\t\t\t\t\t\t.getEmbeddedServletContainer() != null) {\n\t\t\tcreateChildManagementContext();\n\t\t}\n\t\tif (managementPort == ManagementServerPort.SAME\n\t\t\t\t&& this.applicationContext.getEnvironment() instanceof ConfigurableEnvironment) {\n\t\t\taddLocalManagementPortPropertyAlias((ConfigurableEnvironment) this.applicationContext\n\t\t\t\t\t.getEnvironment());\n\t\t}\n\t}\n\n\tprivate void createChildManagementContext() {\n\t\tfinal AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setNamespace("management");\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tEmbeddedServletContainerAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\t\tCloseEventPropagationListener\n\t\t\t\t.addIfPossible(this.applicationContext, childContext);\n\t\ttry {\n\t\t\tchildContext.refresh();\n\t\t\tmanagementContextResolver().setApplicationContext(childContext);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\t// No support currently for deploying a war with management.port=<different>,\n\t\t\t// and this is the signature of that happening\n\t\t\tif (ex instanceof EmbeddedServletContainerException\n\t\t\t\t\t|| ex.getCause() instanceof EmbeddedServletContainerException) {\n\t\t\t\tlogger.warn("Could not start embedded container (management endpoints are still available through JMX)");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Add an alias for \'local.management.port\' that actually resolves using\n\t * \'local.server.port\'.\n\t * @param environment the environment\n\t */\n\tprivate void addLocalManagementPortPropertyAlias(\n\t\t\tfinal ConfigurableEnvironment environment) {\n\t\tenvironment.getPropertySources().addLast(\n\t\t\t\tnew PropertySource<Object>("Management Server") {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getProperty(String name) {\n\t\t\t\t\t\tif ("local.management.port".equals(name)) {\n\t\t\t\t\t\t\treturn environment.getProperty("local.server.port");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\tprotected static class ApplicationContextFilterConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter applicationContextIdFilter(ApplicationContext context) {\n\t\t\treturn new ApplicationContextHeaderFilter(context);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link OncePerRequestFilter} to add the {@literal X-Application-Context} if\n\t * required.\n\t */\n\tprivate static class ApplicationContextHeaderFilter extends OncePerRequestFilter {\n\n\t\tprivate final ApplicationContext applicationContext;\n\n\t\tprivate ManagementServerProperties properties;\n\n\t\tpublic ApplicationContextHeaderFilter(ApplicationContext applicationContext) {\n\t\t\tthis.applicationContext = applicationContext;\n\t\t}\n\n\t\t@Override\n\t\tprotected void doFilterInternal(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, FilterChain filterChain)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tif (this.properties == null) {\n\t\t\t\tthis.properties = this.applicationContext\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t}\n\t\t\tif (this.properties.getAddApplicationContextHeader()) {\n\t\t\t\tresponse.addHeader("X-Application-Context",\n\t\t\t\t\t\tthis.applicationContext.getId());\n\t\t\t}\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to propagate the {@link ContextClosedEvent} from a\n\t * parent to a child.\n\t */\n\tprivate static class CloseEventPropagationListener implements\n\t\t\tApplicationListener<ContextClosedEvent> {\n\n\t\tprivate final ApplicationContext parentContext;\n\n\t\tprivate final ConfigurableApplicationContext childContext;\n\n\t\tpublic CloseEventPropagationListener(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tthis.parentContext = parentContext;\n\t\t\tthis.childContext = childContext;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\t\tif (event.getApplicationContext() == this.parentContext) {\n\t\t\t\tthis.childContext.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic static void addIfPossible(ApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tif (parentContext instanceof ConfigurableApplicationContext) {\n\t\t\t\tadd((ConfigurableApplicationContext) parentContext, childContext);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void add(ConfigurableApplicationContext parentContext,\n\t\t\t\tConfigurableApplicationContext childContext) {\n\t\t\tparentContext.addApplicationListener(new CloseEventPropagationListener(\n\t\t\t\t\tparentContext, childContext));\n\t\t}\n\n\t}\n\n\tprotected static enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(BeanFactory beanFactory) {\n\t\t\tServerProperties serverProperties;\n\t\t\ttry {\n\t\t\t\tserverProperties = beanFactory.getBean(ServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tserverProperties = new ServerProperties();\n\t\t\t}\n\t\t\tManagementServerProperties managementServerProperties;\n\t\t\ttry {\n\t\t\t\tmanagementServerProperties = beanFactory\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tmanagementServerProperties = new ManagementServerProperties();\n\t\t\t}\n\t\t\tInteger port = managementServerProperties.getPort();\n\t\t\tif (port != null && port < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\tif (!(beanFactory instanceof WebApplicationContext)) {\n\t\t\t\t// Current context is not a webapp\n\t\t\t\treturn DIFFERENT;\n\t\t\t}\n\t\t\treturn ((port == null)\n\t\t\t\t\t|| (serverProperties.getPort() == null && port.equals(8080))\n\t\t\t\t\t|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME\n\t\t\t\t\t: DIFFERENT);\n\t\t}\n\n\t}\n\n\tprivate static class OnManagementMvcCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tRelaxedPropertyResolver management = new RelaxedPropertyResolver(\n\t\t\t\t\tcontext.getEnvironment(), "management.");\n\t\t\tRelaxedPropertyResolver server = new RelaxedPropertyResolver(\n\t\t\t\t\tcontext.getEnvironment(), "server.");\n\t\t\tInteger managementPort = management.getProperty("port", Integer.class);\n\t\t\tif (managementPort == null) {\n\t\t\t\tManagementServerProperties managementServerProperties = getBeanCarefully(\n\t\t\t\t\t\tcontext, ManagementServerProperties.class);\n\t\t\t\tif (managementServerProperties != null) {\n\t\t\t\t\tmanagementPort = managementServerProperties.getPort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (managementPort != null && managementPort < 0) {\n\t\t\t\treturn new ConditionOutcome(false, "The mangagement port is disabled");\n\t\t\t}\n\t\t\tif (!(context.getResourceLoader() instanceof WebApplicationContext)) {\n\t\t\t\t// Current context is not a webapp\n\t\t\t\treturn new ConditionOutcome(false, "The context is not a webapp");\n\t\t\t}\n\t\t\tInteger serverPort = server.getProperty("port", Integer.class);\n\t\t\tif (serverPort == null) {\n\t\t\t\tServerProperties serverProperties = getBeanCarefully(context,\n\t\t\t\t\t\tServerProperties.class);\n\t\t\t\tif (serverProperties != null) {\n\t\t\t\t\tserverPort = serverProperties.getPort();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((managementPort == null)\n\t\t\t\t\t|| (serverPort == null && managementPort.equals(8080))\n\t\t\t\t\t|| (managementPort != 0 && managementPort.equals(serverPort))) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.match("The main context is the management context");\n\t\t\t}\n\t\t\treturn ConditionOutcome\n\t\t\t\t\t.noMatch("The main context is not the management context");\n\t\t}\n\n\t\tprivate <T> T getBeanCarefully(ConditionContext context, Class<T> type) {\n\t\t\tString[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tcontext.getBeanFactory(), type, false, false);\n\t\t\tif (names.length == 1) {\n\t\t\t\tBeanDefinition original = findBeanDefinition(context.getBeanFactory(),\n\t\t\t\t\t\tnames[0]);\n\t\t\t\tif (original instanceof RootBeanDefinition) {\n\t\t\t\t\tDefaultListableBeanFactory temp = new DefaultListableBeanFactory();\n\t\t\t\t\ttemp.setParentBeanFactory(context.getBeanFactory());\n\t\t\t\t\ttemp.registerBeanDefinition("bean",\n\t\t\t\t\t\t\t((RootBeanDefinition) original).cloneBeanDefinition());\n\t\t\t\t\treturn temp.getBean(type);\n\t\t\t\t}\n\t\t\t\treturn BeanFactoryUtils.beanOfType(context.getBeanFactory(), type, false,\n\t\t\t\t\t\tfalse);\n\t\t\t}\n\t\t\t;\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate BeanDefinition findBeanDefinition(\n\t\t\t\tConfigurableListableBeanFactory beanFactory, String name) {\n\t\t\tBeanDefinition original = null;\n\t\t\twhile (beanFactory != null && original == null) {\n\t\t\t\tif (beanFactory.containsLocalBean(name)) {\n\t\t\t\t\toriginal = beanFactory.getBeanDefinition(name);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tBeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();\n\t\t\t\t\tif (parentBeanFactory instanceof ConfigurableListableBeanFactory) {\n\t\t\t\t\t\tbeanFactory = (ConfigurableListableBeanFactory) parentBeanFactory;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanFactory = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn original;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
