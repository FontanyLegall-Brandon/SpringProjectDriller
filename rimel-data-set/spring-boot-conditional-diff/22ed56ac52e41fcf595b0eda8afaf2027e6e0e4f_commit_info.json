{'_old_path': None, '_new_path': PosixPath('spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/saml2/Saml2RelyingPartyRegistrationConfiguration.java'), 'change_type': <ModificationType.ADD: 1>, 'diff': '@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2012-2019 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.boot.autoconfigure.security.saml2;\n+\n+import java.io.InputStream;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Identityprovider.Verification;\n+import org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Registration;\n+import org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Registration.Signing;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Conditional;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.io.Resource;\n+import org.springframework.security.converter.RsaKeyConverters;\n+import org.springframework.security.saml2.credentials.Saml2X509Credential;\n+import org.springframework.security.saml2.credentials.Saml2X509Credential.Saml2X509CredentialType;\n+import org.springframework.security.saml2.provider.service.registration.InMemoryRelyingPartyRegistrationRepository;\n+import org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistration;\n+import org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository;\n+import org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationFilter;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * {@link Configuration @Configuration} used to map {@link Saml2RelyingPartyProperties} to\n+ * relying party registrations in a {@link RelyingPartyRegistrationRepository}.\n+ *\n+ * @author Madhura Bhave\n+ * @author Phillip Webb\n+ */\n+@Configuration(proxyBeanMethods = false)\n+@Conditional(RegistrationConfiguredCondition.class)\n+@ConditionalOnMissingBean(RelyingPartyRegistrationRepository.class)\n+class Saml2RelyingPartyRegistrationConfiguration {\n+\n+\t@Bean\n+\tRelyingPartyRegistrationRepository relyingPartyRegistrationRepository(Saml2RelyingPartyProperties properties) {\n+\t\tList<RelyingPartyRegistration> registrations = properties.getRegistration().entrySet().stream()\n+\t\t\t\t.map(this::asRegistration).collect(Collectors.toList());\n+\t\treturn new InMemoryRelyingPartyRegistrationRepository(registrations);\n+\t}\n+\n+\tprivate RelyingPartyRegistration asRegistration(Map.Entry<String, Registration> entry) {\n+\t\treturn asRegistration(entry.getKey(), entry.getValue());\n+\t}\n+\n+\tprivate RelyingPartyRegistration asRegistration(String id, Registration properties) {\n+\t\tRelyingPartyRegistration.Builder builder = RelyingPartyRegistration.withRegistrationId(id);\n+\t\tbuilder.assertionConsumerServiceUrlTemplate(\n+\t\t\t\t"{baseUrl}" + Saml2WebSsoAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI);\n+\t\tbuilder.idpWebSsoUrl(properties.getIdentityprovider().getSsoUrl());\n+\t\tbuilder.remoteIdpEntityId(properties.getIdentityprovider().getEntityId());\n+\t\tbuilder.credentials((credentials) -> credentials.addAll(asCredentials(properties)));\n+\t\treturn builder.build();\n+\t}\n+\n+\tprivate List<Saml2X509Credential> asCredentials(Registration properties) {\n+\t\tList<Saml2X509Credential> credentials = new ArrayList<>();\n+\t\tproperties.getSigning().getCredentials().stream().map(this::asSigningCredential).forEach(credentials::add);\n+\t\tproperties.getIdentityprovider().getVerification().getCredentials().stream().map(this::asVerificationCredential)\n+\t\t\t\t.forEach(credentials::add);\n+\t\treturn credentials;\n+\t}\n+\n+\tprivate Saml2X509Credential asSigningCredential(Signing.Credential properties) {\n+\t\tRSAPrivateKey privateKey = readPrivateKey(properties.getPrivateKeyLocation());\n+\t\tX509Certificate certificate = readCertificate(properties.getCertificateLocation());\n+\t\treturn new Saml2X509Credential(privateKey, certificate, Saml2X509CredentialType.SIGNING,\n+\t\t\t\tSaml2X509CredentialType.DECRYPTION);\n+\t}\n+\n+\tprivate Saml2X509Credential asVerificationCredential(Verification.Credential properties) {\n+\t\tX509Certificate certificate = readCertificate(properties.getCertificateLocation());\n+\t\treturn new Saml2X509Credential(certificate, Saml2X509CredentialType.ENCRYPTION,\n+\t\t\t\tSaml2X509CredentialType.VERIFICATION);\n+\t}\n+\n+\tprivate RSAPrivateKey readPrivateKey(Resource location) {\n+\t\tAssert.state(location != null, "No private key location specified");\n+\t\tAssert.state(location.exists(), "Private key location \'" + location + "\' does not exist");\n+\t\ttry (InputStream inputStream = location.getInputStream()) {\n+\t\t\treturn RsaKeyConverters.pkcs8().convert(inputStream);\n+\t\t}\n+\t\tcatch (Exception ex) {\n+\t\t\tthrow new IllegalArgumentException(ex);\n+\t\t}\n+\t}\n+\n+\tprivate X509Certificate readCertificate(Resource location) {\n+\t\tAssert.state(location != null, "No certificate location specified");\n+\t\tAssert.state(location.exists(), "Certificate  location \'" + location + "\' does not exist");\n+\t\ttry (InputStream inputStream = location.getInputStream()) {\n+\t\t\treturn (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(inputStream);\n+\t\t}\n+\t\tcatch (Exception ex) {\n+\t\t\tthrow new IllegalArgumentException(ex);\n+\t\t}\n+\t}\n+\n+}\n', 'source_code': '/*\n * Copyright 2012-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security.saml2;\n\nimport java.io.InputStream;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Identityprovider.Verification;\nimport org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Registration;\nimport org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyProperties.Registration.Signing;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.Resource;\nimport org.springframework.security.converter.RsaKeyConverters;\nimport org.springframework.security.saml2.credentials.Saml2X509Credential;\nimport org.springframework.security.saml2.credentials.Saml2X509Credential.Saml2X509CredentialType;\nimport org.springframework.security.saml2.provider.service.registration.InMemoryRelyingPartyRegistrationRepository;\nimport org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistration;\nimport org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository;\nimport org.springframework.security.saml2.provider.service.servlet.filter.Saml2WebSsoAuthenticationFilter;\nimport org.springframework.util.Assert;\n\n/**\n * {@link Configuration @Configuration} used to map {@link Saml2RelyingPartyProperties} to\n * relying party registrations in a {@link RelyingPartyRegistrationRepository}.\n *\n * @author Madhura Bhave\n * @author Phillip Webb\n */\n@Configuration(proxyBeanMethods = false)\n@Conditional(RegistrationConfiguredCondition.class)\n@ConditionalOnMissingBean(RelyingPartyRegistrationRepository.class)\nclass Saml2RelyingPartyRegistrationConfiguration {\n\n\t@Bean\n\tRelyingPartyRegistrationRepository relyingPartyRegistrationRepository(Saml2RelyingPartyProperties properties) {\n\t\tList<RelyingPartyRegistration> registrations = properties.getRegistration().entrySet().stream()\n\t\t\t\t.map(this::asRegistration).collect(Collectors.toList());\n\t\treturn new InMemoryRelyingPartyRegistrationRepository(registrations);\n\t}\n\n\tprivate RelyingPartyRegistration asRegistration(Map.Entry<String, Registration> entry) {\n\t\treturn asRegistration(entry.getKey(), entry.getValue());\n\t}\n\n\tprivate RelyingPartyRegistration asRegistration(String id, Registration properties) {\n\t\tRelyingPartyRegistration.Builder builder = RelyingPartyRegistration.withRegistrationId(id);\n\t\tbuilder.assertionConsumerServiceUrlTemplate(\n\t\t\t\t"{baseUrl}" + Saml2WebSsoAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI);\n\t\tbuilder.idpWebSsoUrl(properties.getIdentityprovider().getSsoUrl());\n\t\tbuilder.remoteIdpEntityId(properties.getIdentityprovider().getEntityId());\n\t\tbuilder.credentials((credentials) -> credentials.addAll(asCredentials(properties)));\n\t\treturn builder.build();\n\t}\n\n\tprivate List<Saml2X509Credential> asCredentials(Registration properties) {\n\t\tList<Saml2X509Credential> credentials = new ArrayList<>();\n\t\tproperties.getSigning().getCredentials().stream().map(this::asSigningCredential).forEach(credentials::add);\n\t\tproperties.getIdentityprovider().getVerification().getCredentials().stream().map(this::asVerificationCredential)\n\t\t\t\t.forEach(credentials::add);\n\t\treturn credentials;\n\t}\n\n\tprivate Saml2X509Credential asSigningCredential(Signing.Credential properties) {\n\t\tRSAPrivateKey privateKey = readPrivateKey(properties.getPrivateKeyLocation());\n\t\tX509Certificate certificate = readCertificate(properties.getCertificateLocation());\n\t\treturn new Saml2X509Credential(privateKey, certificate, Saml2X509CredentialType.SIGNING,\n\t\t\t\tSaml2X509CredentialType.DECRYPTION);\n\t}\n\n\tprivate Saml2X509Credential asVerificationCredential(Verification.Credential properties) {\n\t\tX509Certificate certificate = readCertificate(properties.getCertificateLocation());\n\t\treturn new Saml2X509Credential(certificate, Saml2X509CredentialType.ENCRYPTION,\n\t\t\t\tSaml2X509CredentialType.VERIFICATION);\n\t}\n\n\tprivate RSAPrivateKey readPrivateKey(Resource location) {\n\t\tAssert.state(location != null, "No private key location specified");\n\t\tAssert.state(location.exists(), "Private key location \'" + location + "\' does not exist");\n\t\ttry (InputStream inputStream = location.getInputStream()) {\n\t\t\treturn RsaKeyConverters.pkcs8().convert(inputStream);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}\n\n\tprivate X509Certificate readCertificate(Resource location) {\n\t\tAssert.state(location != null, "No certificate location specified");\n\t\tAssert.state(location.exists(), "Certificate  location \'" + location + "\' does not exist");\n\t\ttry (InputStream inputStream = location.getInputStream()) {\n\t\t\treturn (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(inputStream);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(ex);\n\t\t}\n\t}\n\n}\n', 'source_code_before': None, '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
