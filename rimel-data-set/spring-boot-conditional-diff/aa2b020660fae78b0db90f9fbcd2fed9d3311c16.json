{"author_date": "2013-12-06 16:10:50+00:00", "msg": "Refactor metrics to expose richer feature set\n\nMain user-facing interface is still Counter/GaugeService but the\nback end behind that has more options. The Default*Services write\nmetrics to a MetricWriter and there are some variants of that, and\nalso variants of MetricReader (basic read-only actions).\n\nMetricRepository is now a combination of MetricReader, MetricWriter\nand some more methods that make it a bit more repository like.\n\nThere is also a MultiMetricReader and a MultiMetricRepository for\nthe common case where metrics are stored in related (often open\nended) groups. Examples would be complex metrics like histograms\nand \"rich\" metrics with averages and statistics attached (which\nare both closed) and \"field counters\" which count the occurrences\nof values of a particular named field or slot in an incoming message\n(e.g. counting Twitter hastags, open ended).\n\nIn memory and redis implementations are provided for the repositories.\nGenerally speaking the in memory repository should be used as a\nlocal buffer and then scheduled \"exports\" can be executed to copy\nmetric values accross to a remote repository for aggregation.\nThere is an Exporter interface to support this and a few implementations\ndealing with different strategies for storing the results (singly or\ngrouped).\n\nCodahale metrics are also supported through the MetricWriter interface.\nCurrently implemented through a naming convention (since Codahale has\na fixed object model this makes sense): metrics beginning with \"histogram\"\nare Histograms, \"timer\" for Timers, \"meter\" for Meters etc.\n\nSupport for message driven metric consumption and production are provided\nthrough a MetricWriterMessageHandler and a MessageChannelMetricWriter.\n\nNo support yet for pagination in the repositories, or for HATEOAS style\nHTTP endpoints."}