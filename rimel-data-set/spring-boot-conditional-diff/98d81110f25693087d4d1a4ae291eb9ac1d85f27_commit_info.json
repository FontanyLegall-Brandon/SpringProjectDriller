{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -24,6 +24,9 @@ import javax.servlet.Filter;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n+import org.apache.catalina.Valve;\n+import org.apache.catalina.valves.AccessLogValve;\n+\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.HierarchicalBeanFactory;\n@@ -43,6 +46,9 @@ import org.springframework.boot.autoconfigure.web.ServerProperties;\n import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n import org.springframework.boot.context.embedded.EmbeddedServletContainer;\n import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n+import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\n+import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\n+import org.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory;\n import org.springframework.boot.web.servlet.ErrorPage;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n@@ -106,6 +112,17 @@ public class EndpointWebMvcChildContextConfiguration {\n \t\treturn new ServerCustomization();\n \t}\n \n+\t@Bean\n+\tpublic UndertowAccessLogCustomizer undertowAccessLogCustomizer() {\n+\t\treturn new UndertowAccessLogCustomizer();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnClass(name = "org.apache.catalina.valves.AccessLogValve")\n+\tpublic TomcatAccessLogCustomizer tomcatAccessLogCustomizer() {\n+\t\treturn new TomcatAccessLogCustomizer();\n+\t}\n+\n \t/*\n \t * The error controller is present but not mapped as an endpoint in this context\n \t * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.\n@@ -321,4 +338,79 @@ public class EndpointWebMvcChildContextConfiguration {\n \n \t}\n \n+\tstatic abstract class AccessLogCustomizer<T extends EmbeddedServletContainerFactory>\n+\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n+\n+\t\tprivate final Class<T> factoryClass;\n+\n+\t\tAccessLogCustomizer(Class<T> factoryClass) {\n+\t\t\tthis.factoryClass = factoryClass;\n+\t\t}\n+\n+\t\tprotected String customizePrefix(String prefix) {\n+\t\t\treturn "management_" + prefix;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getOrder() {\n+\t\t\treturn 1;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n+\t\t\tif (this.factoryClass.isInstance(container)) {\n+\t\t\t\tcustomize(this.factoryClass.cast(container));\n+\t\t\t}\n+\t\t}\n+\n+\t\tabstract void customize(T container);\n+\t}\n+\n+\tstatic class TomcatAccessLogCustomizer\n+\t\t\textends AccessLogCustomizer<TomcatEmbeddedServletContainerFactory> {\n+\n+\t\tTomcatAccessLogCustomizer() {\n+\t\t\tsuper(TomcatEmbeddedServletContainerFactory.class);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getOrder() {\n+\t\t\treturn 1;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void customize(TomcatEmbeddedServletContainerFactory container) {\n+\t\t\tAccessLogValve accessLogValve = findAccessLogValve(container);\n+\t\t\tif (accessLogValve == null) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\taccessLogValve.setPrefix(customizePrefix(accessLogValve.getPrefix()));\n+\t\t}\n+\n+\t\tprivate AccessLogValve findAccessLogValve(\n+\t\t\t\tTomcatEmbeddedServletContainerFactory container) {\n+\t\t\tfor (Valve engineValve : container.getEngineValves()) {\n+\t\t\t\tif (engineValve instanceof AccessLogValve) {\n+\t\t\t\t\treturn (AccessLogValve) engineValve;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\tstatic class UndertowAccessLogCustomizer\n+\t\t\textends AccessLogCustomizer<UndertowEmbeddedServletContainerFactory> {\n+\n+\t\tUndertowAccessLogCustomizer() {\n+\t\t\tsuper(UndertowEmbeddedServletContainerFactory.class);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void customize(UndertowEmbeddedServletContainerFactory container) {\n+\t\t\tcontainer.setAccessLogPrefix(customizePrefix(container.getAccessLogPrefix()));\n+\t\t}\n+\n+\t}\n+\n }\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.catalina.Valve;\nimport org.apache.catalina.valves.AccessLogValve;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaHttpMessageConverterConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\nimport org.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory;\nimport org.springframework.boot.web.servlet.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.hateoas.LinkDiscoverer;\nimport org.springframework.hateoas.config.EnableHypermediaSupport;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.HandlerExecutionChain;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n * @author Eddú Meléndez\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\n@EnableWebMvc\n@Import(ManagementContextConfigurationsImportSelector.class)\npublic class EndpointWebMvcChildContextConfiguration {\n\n\t@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)\n\tpublic CompositeHandlerMapping compositeHandlerMapping() {\n\t\treturn new CompositeHandlerMapping();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)\n\tpublic CompositeHandlerAdapter compositeHandlerAdapter() {\n\t\treturn new CompositeHandlerAdapter();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)\n\tpublic CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {\n\t\treturn new CompositeHandlerExceptionResolver();\n\t}\n\n\t@Bean\n\tpublic ServerCustomization serverCustomization() {\n\t\treturn new ServerCustomization();\n\t}\n\n\t@Bean\n\tpublic UndertowAccessLogCustomizer undertowAccessLogCustomizer() {\n\t\treturn new UndertowAccessLogCustomizer();\n\t}\n\n\t@Bean\n\t@ConditionalOnClass(name = "org.apache.catalina.valves.AccessLogValve")\n\tpublic TomcatAccessLogCustomizer tomcatAccessLogCustomizer() {\n\t\treturn new TomcatAccessLogCustomizer();\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.\n\t * So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\t@ConditionalOnBean(ErrorAttributes.class)\n\tpublic ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(errorAttributes);\n\t}\n\n\t/**\n\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s.\n\t */\n\t@Configuration\n\tprotected static class EndpointHandlerMappingConfiguration {\n\n\t\t@Autowired\n\t\tpublic void handlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {\n\t\t\t// In a child context we definitely want to see the parent endpoints\n\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ LinkDiscoverer.class })\n\t@Import(HypermediaHttpMessageConverterConfiguration.class)\n\t@EnableHypermediaSupport(type = EnableHypermediaSupport.HypermediaType.HAL)\n\tstatic class HypermediaConfiguration {\n\n\t}\n\n\tstatic class ServerCustomization\n\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage>emptySet());\n\t\t\t// and the context path\n\t\t\tcontainer.setContextPath("");\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tif (this.managementServerProperties.getSsl() != null) {\n\t\t\t\tcontainer.setSsl(this.managementServerProperties.getSsl());\n\t\t\t}\n\t\t\tcontainer.setServerHeader(this.server.getServerHeader());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.server.getError().getPath()));\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerMapping implements HandlerMapping {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerMapping> mappings;\n\n\t\t@Override\n\t\tpublic HandlerExecutionChain getHandler(HttpServletRequest request)\n\t\t\t\tthrows Exception {\n\t\t\tif (this.mappings == null) {\n\t\t\t\tthis.mappings = extractMappings();\n\t\t\t}\n\t\t\tfor (HandlerMapping mapping : this.mappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate List<HandlerMapping> extractMappings() {\n\t\t\tList<HandlerMapping> list = new ArrayList<HandlerMapping>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerMapping.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerAdapter implements HandlerAdapter {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerAdapter> adapters;\n\n\t\tprivate List<HandlerAdapter> extractAdapters() {\n\t\t\tList<HandlerAdapter> list = new ArrayList<HandlerAdapter>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supports(Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView handle(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler) throws Exception {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.handle(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.getLastModified(request, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerExceptionResolver implements HandlerExceptionResolver {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerExceptionResolver> resolvers;\n\n\t\tprivate List<HandlerExceptionResolver> extractResolvers() {\n\t\t\tList<HandlerExceptionResolver> list = new ArrayList<HandlerExceptionResolver>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerExceptionResolver.class)\n\t\t\t\t\t.values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView resolveException(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler, Exception ex) {\n\t\t\tif (this.resolvers == null) {\n\t\t\t\tthis.resolvers = extractResolvers();\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver mapping : this.resolvers) {\n\t\t\t\tModelAndView mav = mapping.resolveException(request, response, handler,\n\t\t\t\t\t\tex);\n\t\t\t\tif (mav != null) {\n\t\t\t\t\treturn mav;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tstatic abstract class AccessLogCustomizer<T extends EmbeddedServletContainerFactory>\n\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n\n\t\tprivate final Class<T> factoryClass;\n\n\t\tAccessLogCustomizer(Class<T> factoryClass) {\n\t\t\tthis.factoryClass = factoryClass;\n\t\t}\n\n\t\tprotected String customizePrefix(String prefix) {\n\t\t\treturn "management_" + prefix;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 1;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.factoryClass.isInstance(container)) {\n\t\t\t\tcustomize(this.factoryClass.cast(container));\n\t\t\t}\n\t\t}\n\n\t\tabstract void customize(T container);\n\t}\n\n\tstatic class TomcatAccessLogCustomizer\n\t\t\textends AccessLogCustomizer<TomcatEmbeddedServletContainerFactory> {\n\n\t\tTomcatAccessLogCustomizer() {\n\t\t\tsuper(TomcatEmbeddedServletContainerFactory.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 1;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(TomcatEmbeddedServletContainerFactory container) {\n\t\t\tAccessLogValve accessLogValve = findAccessLogValve(container);\n\t\t\tif (accessLogValve == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taccessLogValve.setPrefix(customizePrefix(accessLogValve.getPrefix()));\n\t\t}\n\n\t\tprivate AccessLogValve findAccessLogValve(\n\t\t\t\tTomcatEmbeddedServletContainerFactory container) {\n\t\t\tfor (Valve engineValve : container.getEngineValves()) {\n\t\t\t\tif (engineValve instanceof AccessLogValve) {\n\t\t\t\t\treturn (AccessLogValve) engineValve;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tstatic class UndertowAccessLogCustomizer\n\t\t\textends AccessLogCustomizer<UndertowEmbeddedServletContainerFactory> {\n\n\t\tUndertowAccessLogCustomizer() {\n\t\t\tsuper(UndertowEmbeddedServletContainerFactory.class);\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(UndertowEmbeddedServletContainerFactory container) {\n\t\t\tcontainer.setAccessLogPrefix(customizePrefix(container.getAccessLogPrefix()));\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaHttpMessageConverterConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.web.servlet.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.hateoas.LinkDiscoverer;\nimport org.springframework.hateoas.config.EnableHypermediaSupport;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.HandlerExecutionChain;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n * @author Eddú Meléndez\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\n@EnableWebMvc\n@Import(ManagementContextConfigurationsImportSelector.class)\npublic class EndpointWebMvcChildContextConfiguration {\n\n\t@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)\n\tpublic CompositeHandlerMapping compositeHandlerMapping() {\n\t\treturn new CompositeHandlerMapping();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)\n\tpublic CompositeHandlerAdapter compositeHandlerAdapter() {\n\t\treturn new CompositeHandlerAdapter();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)\n\tpublic CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {\n\t\treturn new CompositeHandlerExceptionResolver();\n\t}\n\n\t@Bean\n\tpublic ServerCustomization serverCustomization() {\n\t\treturn new ServerCustomization();\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.\n\t * So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\t@ConditionalOnBean(ErrorAttributes.class)\n\tpublic ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(errorAttributes);\n\t}\n\n\t/**\n\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s.\n\t */\n\t@Configuration\n\tprotected static class EndpointHandlerMappingConfiguration {\n\n\t\t@Autowired\n\t\tpublic void handlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {\n\t\t\t// In a child context we definitely want to see the parent endpoints\n\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ LinkDiscoverer.class })\n\t@Import(HypermediaHttpMessageConverterConfiguration.class)\n\t@EnableHypermediaSupport(type = EnableHypermediaSupport.HypermediaType.HAL)\n\tstatic class HypermediaConfiguration {\n\n\t}\n\n\tstatic class ServerCustomization\n\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage>emptySet());\n\t\t\t// and the context path\n\t\t\tcontainer.setContextPath("");\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tif (this.managementServerProperties.getSsl() != null) {\n\t\t\t\tcontainer.setSsl(this.managementServerProperties.getSsl());\n\t\t\t}\n\t\t\tcontainer.setServerHeader(this.server.getServerHeader());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.server.getError().getPath()));\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerMapping implements HandlerMapping {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerMapping> mappings;\n\n\t\t@Override\n\t\tpublic HandlerExecutionChain getHandler(HttpServletRequest request)\n\t\t\t\tthrows Exception {\n\t\t\tif (this.mappings == null) {\n\t\t\t\tthis.mappings = extractMappings();\n\t\t\t}\n\t\t\tfor (HandlerMapping mapping : this.mappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate List<HandlerMapping> extractMappings() {\n\t\t\tList<HandlerMapping> list = new ArrayList<HandlerMapping>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerMapping.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerAdapter implements HandlerAdapter {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerAdapter> adapters;\n\n\t\tprivate List<HandlerAdapter> extractAdapters() {\n\t\t\tList<HandlerAdapter> list = new ArrayList<HandlerAdapter>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supports(Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView handle(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler) throws Exception {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.handle(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.getLastModified(request, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerExceptionResolver implements HandlerExceptionResolver {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerExceptionResolver> resolvers;\n\n\t\tprivate List<HandlerExceptionResolver> extractResolvers() {\n\t\t\tList<HandlerExceptionResolver> list = new ArrayList<HandlerExceptionResolver>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerExceptionResolver.class)\n\t\t\t\t\t.values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView resolveException(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler, Exception ex) {\n\t\t\tif (this.resolvers == null) {\n\t\t\t\tthis.resolvers = extractResolvers();\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver mapping : this.resolvers) {\n\t\t\t\tModelAndView mav = mapping.resolveException(request, response, handler,\n\t\t\t\t\t\tex);\n\t\t\t\tif (mav != null) {\n\t\t\t\t\treturn mav;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
