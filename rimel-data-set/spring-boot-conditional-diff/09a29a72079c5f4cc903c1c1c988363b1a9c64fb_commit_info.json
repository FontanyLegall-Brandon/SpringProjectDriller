{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/resource/ResourceServerTokenServicesConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/resource/ResourceServerTokenServicesConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -1,5 +1,5 @@\n /*\n- * Copyright 2013-2014 the original author or authors.\n+ * Copyright 2012-2015 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the "License");\n  * you may not use this file except in compliance with the License.\n@@ -13,6 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+\n package org.springframework.boot.autoconfigure.security.oauth2.resource;\n \n import java.io.IOException;\n@@ -31,11 +32,11 @@ import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\n import org.springframework.boot.autoconfigure.condition.SpringBootCondition;\n+import org.springframework.boot.bind.RelaxedPropertyResolver;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.ConditionContext;\n import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n-import org.springframework.core.OrderComparator;\n import org.springframework.core.annotation.AnnotationAwareOrderComparator;\n import org.springframework.core.env.Environment;\n import org.springframework.core.type.AnnotatedTypeMetadata;\n@@ -71,8 +72,10 @@ import org.springframework.web.client.ResourceAccessException;\n import org.springframework.web.client.RestTemplate;\n \n /**\n- * @author Dave Syer\n+ * Configuration for an OAuth2 resource server.\n  *\n+ * @author Dave Syer\n+ * @since 1.3.0\n  */\n @Configuration\n @ConditionalOnMissingBean(AuthorizationServerEndpointsConfiguration.class)\n@@ -88,10 +91,10 @@ public class ResourceServerTokenServicesConfiguration {\n \n \t\tstatic {\n \t\t\tDEFAULT_RESOURCE_DETAILS.setClientId("<N/A>");\n-\t\t\tDEFAULT_RESOURCE_DETAILS\n-\t\t\t\t\t.setUserAuthorizationUri("Not a URI because there is no client");\n-\t\t\tDEFAULT_RESOURCE_DETAILS\n-\t\t\t\t\t.setAccessTokenUri("Not a URI because there is no client");\n+\t\t\tDEFAULT_RESOURCE_DETAILS.setUserAuthorizationUri("Not a URI "\n+\t\t\t\t\t+ "because there is no client");\n+\t\t\tDEFAULT_RESOURCE_DETAILS.setAccessTokenUri("Not a URI "\n+\t\t\t\t\t+ "because there is no client");\n \t\t}\n \n \t\t@Autowired(required = false)\n@@ -106,52 +109,37 @@ public class ResourceServerTokenServicesConfiguration {\n \n \t\t@Bean(name = "userInfoRestTemplate")\n \t\tpublic OAuth2RestTemplate userInfoRestTemplate() {\n-\t\t\tOAuth2RestTemplate template;\n-\t\t\tif (details == null) {\n-\t\t\t\tdetails = DEFAULT_RESOURCE_DETAILS;\n-\t\t\t}\n-\t\t\tif (oauth2ClientContext == null) {\n-\t\t\t\ttemplate = new OAuth2RestTemplate(details);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\ttemplate = new OAuth2RestTemplate(details, oauth2ClientContext);\n+\t\t\tif (this.details == null) {\n+\t\t\t\tthis.details = DEFAULT_RESOURCE_DETAILS;\n \t\t\t}\n+\t\t\tOAuth2RestTemplate template = getTemplate();\n \t\t\ttemplate.setInterceptors(Arrays\n-\t\t\t\t\t.<ClientHttpRequestInterceptor> asList(new ClientHttpRequestInterceptor() {\n-\t\t\t\t\t\t@Override\n-\t\t\t\t\t\tpublic ClientHttpResponse intercept(HttpRequest request,\n-\t\t\t\t\t\t\t\tbyte[] body, ClientHttpRequestExecution execution)\n-\t\t\t\t\t\t\t\tthrows IOException {\n-\t\t\t\t\t\t\trequest.getHeaders().setAccept(\n-\t\t\t\t\t\t\t\t\tArrays.asList(MediaType.APPLICATION_JSON));\n-\t\t\t\t\t\t\treturn execution.execute(request, body);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}));\n+\t\t\t\t\t.<ClientHttpRequestInterceptor> asList(new AcceptJsonRequestInterceptor()));\n \t\t\tAuthorizationCodeAccessTokenProvider accessTokenProvider = new AuthorizationCodeAccessTokenProvider();\n-\t\t\taccessTokenProvider.setTokenRequestEnhancer(new RequestEnhancer() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void enhance(AccessTokenRequest request,\n-\t\t\t\t\t\tOAuth2ProtectedResourceDetails resource,\n-\t\t\t\t\t\tMultiValueMap<String, String> form, HttpHeaders headers) {\n-\t\t\t\t\theaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n-\t\t\t\t}\n-\t\t\t});\n+\t\t\taccessTokenProvider.setTokenRequestEnhancer(new AcceptJsonRequestEnhancer());\n \t\t\ttemplate.setAccessTokenProvider(accessTokenProvider);\n-\t\t\tOrderComparator.sort(customizers);\n-\t\t\tfor (UserInfoRestTemplateCustomizer customizer : customizers) {\n+\t\t\tAnnotationAwareOrderComparator.sort(this.customizers);\n+\t\t\tfor (UserInfoRestTemplateCustomizer customizer : this.customizers) {\n \t\t\t\tcustomizer.customize(template);\n \t\t\t}\n \t\t\treturn template;\n \t\t}\n \n+\t\tprivate OAuth2RestTemplate getTemplate() {\n+\t\t\tif (this.oauth2ClientContext == null) {\n+\t\t\t\treturn new OAuth2RestTemplate(this.details);\n+\t\t\t}\n+\t\t\treturn new OAuth2RestTemplate(this.details, this.oauth2ClientContext);\n+\t\t}\n+\n \t}\n \n \t@Configuration\n-\t@Conditional(NotJwtToken.class)\n+\t@Conditional(NotJwtTokenCondition.class)\n \tprotected static class RemoteTokenServicesConfiguration {\n \n \t\t@Configuration\n-\t\t@Conditional(TokenInfo.class)\n+\t\t@Conditional(TokenInfoCondition.class)\n \t\tprotected static class TokenInfoServicesConfiguration {\n \n \t\t\t@Autowired\n@@ -170,7 +158,7 @@ public class ResourceServerTokenServicesConfiguration {\n \n \t\t@Configuration\n \t\t@ConditionalOnClass(OAuth2ConnectionFactory.class)\n-\t\t@Conditional(NotTokenInfo.class)\n+\t\t@Conditional(NotTokenInfoCondition.class)\n \t\tprotected static class SocialTokenServicesConfiguration {\n \n \t\t\t@Autowired\n@@ -197,8 +185,8 @@ public class ResourceServerTokenServicesConfiguration {\n \t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n \t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n \t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n-\t\t\t\tservices.setTokenType(sso.getTokenType());\n-\t\t\t\tservices.setRestTemplate(restTemplate);\n+\t\t\t\tservices.setTokenType(this.sso.getTokenType());\n+\t\t\t\tservices.setRestTemplate(this.restTemplate);\n \t\t\t\treturn services;\n \t\t\t}\n \n@@ -206,7 +194,7 @@ public class ResourceServerTokenServicesConfiguration {\n \n \t\t@Configuration\n \t\t@ConditionalOnMissingClass("org.springframework.social.connect.support.OAuth2ConnectionFactory")\n-\t\t@Conditional(NotTokenInfo.class)\n+\t\t@Conditional(NotTokenInfoCondition.class)\n \t\tprotected static class UserInfoTokenServicesConfiguration {\n \n \t\t\t@Autowired\n@@ -221,8 +209,8 @@ public class ResourceServerTokenServicesConfiguration {\n \t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n \t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n \t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n-\t\t\t\tservices.setRestTemplate(restTemplate);\n-\t\t\t\tservices.setTokenType(sso.getTokenType());\n+\t\t\t\tservices.setRestTemplate(this.restTemplate);\n+\t\t\t\tservices.setTokenType(this.sso.getTokenType());\n \t\t\t\treturn services;\n \t\t\t}\n \n@@ -231,7 +219,7 @@ public class ResourceServerTokenServicesConfiguration {\n \t}\n \n \t@Configuration\n-\t@Conditional(JwtToken.class)\n+\t@Conditional(JwtTokenCondition.class)\n \tprotected static class JwtTokenServicesConfiguration {\n \n \t\tprivate RestTemplate keyUriRestTemplate = new RestTemplate();\n@@ -262,22 +250,11 @@ public class ResourceServerTokenServicesConfiguration {\n \t\t\tString keyValue = this.resource.getJwt().getKeyValue();\n \t\t\tif (!StringUtils.hasText(keyValue)) {\n \t\t\t\ttry {\n-\t\t\t\t\tHttpHeaders headers = new HttpHeaders();\n-\t\t\t\t\tif (resource.getClientId() != null\n-\t\t\t\t\t\t\t&& resource.getClientSecret() != null) {\n-\t\t\t\t\t\tbyte[] token = Base64\n-\t\t\t\t\t\t\t\t.encode((resource.getClientId() + ":" + resource\n-\t\t\t\t\t\t\t\t\t\t.getClientSecret()).getBytes());\n-\t\t\t\t\t\theaders.add("Authorization", "Basic " + new String(token));\n-\t\t\t\t\t}\n-\t\t\t\t\tHttpEntity<Void> requestEntity = new HttpEntity<Void>(headers);\n-\t\t\t\t\tkeyValue = (String) keyUriRestTemplate\n-\t\t\t\t\t\t\t.exchange(resource.getJwt().getKeyUri(), HttpMethod.GET,\n-\t\t\t\t\t\t\t\t\trequestEntity, Map.class).getBody().get("value");\n+\t\t\t\t\tkeyValue = getKeyFromServer();\n \t\t\t\t}\n-\t\t\t\tcatch (ResourceAccessException e) {\n-\t\t\t\t\t// ignore\n-\t\t\t\t\tlogger.warn("Failed to fetch token key (you may need to refresh when the auth server is back)");\n+\t\t\t\tcatch (ResourceAccessException ex) {\n+\t\t\t\t\tlogger.warn("Failed to fetch token key (you may need to refresh "\n+\t\t\t\t\t\t\t+ "when the auth server is back)");\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (StringUtils.hasText(keyValue) && !keyValue.startsWith("-----BEGIN")) {\n@@ -286,52 +263,68 @@ public class ResourceServerTokenServicesConfiguration {\n \t\t\tif (keyValue != null) {\n \t\t\t\tconverter.setVerifierKey(keyValue);\n \t\t\t}\n-\t\t\tAnnotationAwareOrderComparator.sort(configurers);\n-\t\t\tfor (JwtAccessTokenConverterConfigurer configurer : configurers) {\n+\t\t\tAnnotationAwareOrderComparator.sort(this.configurers);\n+\t\t\tfor (JwtAccessTokenConverterConfigurer configurer : this.configurers) {\n \t\t\t\tconfigurer.configure(converter);\n \t\t\t}\n \t\t\treturn converter;\n \t\t}\n \n+\t\tprivate String getKeyFromServer() {\n+\t\t\tHttpHeaders headers = new HttpHeaders();\n+\t\t\tString username = this.resource.getClientId();\n+\t\t\tString password = this.resource.getClientSecret();\n+\t\t\tif (username != null && password != null) {\n+\t\t\t\tbyte[] token = Base64.encode((username + ":" + password).getBytes());\n+\t\t\t\theaders.add("Authorization", "Basic " + new String(token));\n+\t\t\t}\n+\t\t\tHttpEntity<Void> request = new HttpEntity<Void>(headers);\n+\t\t\tString url = this.resource.getJwt().getKeyUri();\n+\t\t\treturn (String) this.keyUriRestTemplate\n+\t\t\t\t\t.exchange(url, HttpMethod.GET, request, Map.class).getBody()\n+\t\t\t\t\t.get("value");\n+\t\t}\n+\n \t}\n \n-\tprivate static class TokenInfo extends SpringBootCondition {\n+\tprivate static class TokenInfoCondition extends SpringBootCondition {\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n \t\t\t\tAnnotatedTypeMetadata metadata) {\n \t\t\tEnvironment environment = context.getEnvironment();\n-\t\t\tboolean preferTokenInfo = environment\n-\t\t\t\t\t.resolvePlaceholders(\n-\t\t\t\t\t\t\t"${spring.oauth2.resource.preferTokenInfo:${OAUTH2_RESOURCE_PREFERTOKENINFO:true}}")\n-\t\t\t\t\t.equals("true");\n-\t\t\tboolean hasTokenInfo = !environment.resolvePlaceholders(\n-\t\t\t\t\t"${spring.oauth2.resource.tokenInfoUri:}").equals("");\n-\t\t\tboolean hasUserInfo = !environment.resolvePlaceholders(\n-\t\t\t\t\t"${spring.oauth2.resource.userInfoUri:}").equals("");\n-\t\t\tif (!hasUserInfo) {\n+\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n+\t\t\t\t\t"spring.oauth2.resource.");\n+\t\t\tBoolean preferTokenInfo = resolver.getProperty("prefer-token-info",\n+\t\t\t\t\tBoolean.class);\n+\t\t\tif (preferTokenInfo == null) {\n+\t\t\t\tpreferTokenInfo = environment.resolvePlaceholders(\n+\t\t\t\t\t\t"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true");\n+\t\t\t}\n+\t\t\tString tokenInfoUri = resolver.getProperty("token-info-uri");\n+\t\t\tString userInfoUri = resolver.getProperty("user-info-uri");\n+\t\t\tif (!StringUtils.hasLength(userInfoUri)) {\n \t\t\t\treturn ConditionOutcome.match("No user info provided");\n \t\t\t}\n-\t\t\tif (hasTokenInfo) {\n-\t\t\t\tif (preferTokenInfo) {\n-\t\t\t\t\treturn ConditionOutcome\n-\t\t\t\t\t\t\t.match("Token info endpoint is preferred and user info provided");\n-\t\t\t\t}\n+\t\t\tif (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) {\n+\t\t\t\treturn ConditionOutcome.match("Token info endpoint "\n+\t\t\t\t\t\t+ "is preferred and user info provided");\n \t\t\t}\n \t\t\treturn ConditionOutcome.noMatch("Token info endpoint is not provided");\n \t\t}\n \n \t}\n \n-\tprivate static class JwtToken extends SpringBootCondition {\n+\tprivate static class JwtTokenCondition extends SpringBootCondition {\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n \t\t\t\tAnnotatedTypeMetadata metadata) {\n-\t\t\tif (StringUtils.hasText(context.getEnvironment().getProperty(\n-\t\t\t\t\t"spring.oauth2.resource.jwt.keyValue"))\n-\t\t\t\t\t|| StringUtils.hasText(context.getEnvironment().getProperty(\n-\t\t\t\t\t\t\t"spring.oauth2.resource.jwt.keyUri"))) {\n+\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(\n+\t\t\t\t\tcontext.getEnvironment(), "spring.oauth2.resource.jwt.");\n+\t\t\tString keyValue = resolver.getProperty("key-value");\n+\t\t\tString keyUri = resolver.getProperty("key-uri");\n+\t\t\tif (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) {\n \t\t\t\treturn ConditionOutcome.match("public key is provided");\n \t\t\t}\n \t\t\treturn ConditionOutcome.noMatch("public key is not provided");\n@@ -339,35 +332,53 @@ public class ResourceServerTokenServicesConfiguration {\n \n \t}\n \n-\tprivate static class NotTokenInfo extends SpringBootCondition {\n+\tprivate static class NotTokenInfoCondition extends SpringBootCondition {\n \n-\t\tprivate TokenInfo opposite = new TokenInfo();\n+\t\tprivate TokenInfoCondition tokenInfoCondition = new TokenInfoCondition();\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n \t\t\t\tAnnotatedTypeMetadata metadata) {\n-\t\t\tConditionOutcome outcome = this.opposite.getMatchOutcome(context, metadata);\n-\t\t\tif (outcome.isMatch()) {\n-\t\t\t\treturn ConditionOutcome.noMatch(outcome.getMessage());\n-\t\t\t}\n-\t\t\treturn ConditionOutcome.match(outcome.getMessage());\n+\t\t\treturn ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome(\n+\t\t\t\t\tcontext, metadata));\n \t\t}\n \n \t}\n \n-\tprivate static class NotJwtToken extends SpringBootCondition {\n+\tprivate static class NotJwtTokenCondition extends SpringBootCondition {\n \n-\t\tprivate JwtToken opposite = new JwtToken();\n+\t\tprivate JwtTokenCondition jwtTokenCondition = new JwtTokenCondition();\n \n \t\t@Override\n \t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n \t\t\t\tAnnotatedTypeMetadata metadata) {\n-\t\t\tConditionOutcome outcome = this.opposite.getMatchOutcome(context, metadata);\n-\t\t\tif (outcome.isMatch()) {\n-\t\t\t\treturn ConditionOutcome.noMatch(outcome.getMessage());\n-\t\t\t}\n-\t\t\treturn ConditionOutcome.match(outcome.getMessage());\n+\t\t\treturn ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome(\n+\t\t\t\t\tcontext, metadata));\n+\t\t}\n+\n+\t}\n+\n+\tprivate static class AcceptJsonRequestInterceptor implements\n+\t\t\tClientHttpRequestInterceptor {\n+\n+\t\t@Override\n+\t\tpublic ClientHttpResponse intercept(HttpRequest request, byte[] body,\n+\t\t\t\tClientHttpRequestExecution execution) throws IOException {\n+\t\t\trequest.getHeaders().setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n+\t\t\treturn execution.execute(request, body);\n \t\t}\n \n \t}\n+\n+\tprivate static class AcceptJsonRequestEnhancer implements RequestEnhancer {\n+\n+\t\t@Override\n+\t\tpublic void enhance(AccessTokenRequest request,\n+\t\t\t\tOAuth2ProtectedResourceDetails resource,\n+\t\t\t\tMultiValueMap<String, String> form, HttpHeaders headers) {\n+\t\t\theaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n+\t\t}\n+\n+\t}\n+\n }\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security.oauth2.resource;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpRequest;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.ClientHttpRequestExecution;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.ClientHttpResponse;\nimport org.springframework.security.crypto.codec.Base64;\nimport org.springframework.security.oauth2.client.OAuth2ClientContext;\nimport org.springframework.security.oauth2.client.OAuth2RestOperations;\nimport org.springframework.security.oauth2.client.OAuth2RestTemplate;\nimport org.springframework.security.oauth2.client.resource.OAuth2ProtectedResourceDetails;\nimport org.springframework.security.oauth2.client.token.AccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.RequestEnhancer;\nimport org.springframework.security.oauth2.client.token.grant.code.AuthorizationCodeAccessTokenProvider;\nimport org.springframework.security.oauth2.client.token.grant.code.AuthorizationCodeResourceDetails;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerEndpointsConfiguration;\nimport org.springframework.security.oauth2.provider.token.DefaultTokenServices;\nimport org.springframework.security.oauth2.provider.token.RemoteTokenServices;\nimport org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\nimport org.springframework.social.connect.ConnectionFactoryLocator;\nimport org.springframework.social.connect.support.OAuth2ConnectionFactory;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.client.ResourceAccessException;\nimport org.springframework.web.client.RestTemplate;\n\n/**\n * Configuration for an OAuth2 resource server.\n *\n * @author Dave Syer\n * @since 1.3.0\n */\n@Configuration\n@ConditionalOnMissingBean(AuthorizationServerEndpointsConfiguration.class)\npublic class ResourceServerTokenServicesConfiguration {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(ResourceServerTokenServicesConfiguration.class);\n\n\t@Configuration\n\tprotected static class UserInfoRestTemplateConfiguration {\n\n\t\tprivate static final AuthorizationCodeResourceDetails DEFAULT_RESOURCE_DETAILS = new AuthorizationCodeResourceDetails();\n\n\t\tstatic {\n\t\t\tDEFAULT_RESOURCE_DETAILS.setClientId("<N/A>");\n\t\t\tDEFAULT_RESOURCE_DETAILS.setUserAuthorizationUri("Not a URI "\n\t\t\t\t\t+ "because there is no client");\n\t\t\tDEFAULT_RESOURCE_DETAILS.setAccessTokenUri("Not a URI "\n\t\t\t\t\t+ "because there is no client");\n\t\t}\n\n\t\t@Autowired(required = false)\n\t\tprivate List<UserInfoRestTemplateCustomizer> customizers = Collections\n\t\t\t\t.emptyList();\n\n\t\t@Autowired(required = false)\n\t\tprivate OAuth2ProtectedResourceDetails details;\n\n\t\t@Autowired(required = false)\n\t\tprivate OAuth2ClientContext oauth2ClientContext;\n\n\t\t@Bean(name = "userInfoRestTemplate")\n\t\tpublic OAuth2RestTemplate userInfoRestTemplate() {\n\t\t\tif (this.details == null) {\n\t\t\t\tthis.details = DEFAULT_RESOURCE_DETAILS;\n\t\t\t}\n\t\t\tOAuth2RestTemplate template = getTemplate();\n\t\t\ttemplate.setInterceptors(Arrays\n\t\t\t\t\t.<ClientHttpRequestInterceptor> asList(new AcceptJsonRequestInterceptor()));\n\t\t\tAuthorizationCodeAccessTokenProvider accessTokenProvider = new AuthorizationCodeAccessTokenProvider();\n\t\t\taccessTokenProvider.setTokenRequestEnhancer(new AcceptJsonRequestEnhancer());\n\t\t\ttemplate.setAccessTokenProvider(accessTokenProvider);\n\t\t\tAnnotationAwareOrderComparator.sort(this.customizers);\n\t\t\tfor (UserInfoRestTemplateCustomizer customizer : this.customizers) {\n\t\t\t\tcustomizer.customize(template);\n\t\t\t}\n\t\t\treturn template;\n\t\t}\n\n\t\tprivate OAuth2RestTemplate getTemplate() {\n\t\t\tif (this.oauth2ClientContext == null) {\n\t\t\t\treturn new OAuth2RestTemplate(this.details);\n\t\t\t}\n\t\t\treturn new OAuth2RestTemplate(this.details, this.oauth2ClientContext);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(NotJwtTokenCondition.class)\n\tprotected static class RemoteTokenServicesConfiguration {\n\n\t\t@Configuration\n\t\t@Conditional(TokenInfoCondition.class)\n\t\tprotected static class TokenInfoServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties resource;\n\n\t\t\t@Bean\n\t\t\tpublic ResourceServerTokenServices remoteTokenServices() {\n\t\t\t\tRemoteTokenServices services = new RemoteTokenServices();\n\t\t\t\tservices.setCheckTokenEndpointUrl(this.resource.getTokenInfoUri());\n\t\t\t\tservices.setClientId(this.resource.getClientId());\n\t\t\t\tservices.setClientSecret(this.resource.getClientSecret());\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t\t@Configuration\n\t\t@ConditionalOnClass(OAuth2ConnectionFactory.class)\n\t\t@Conditional(NotTokenInfoCondition.class)\n\t\tprotected static class SocialTokenServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties sso;\n\n\t\t\t@Autowired(required = false)\n\t\t\tprivate OAuth2ConnectionFactory<?> connectionFactory;\n\n\t\t\t@Autowired(required = false)\n\t\t\t@Qualifier("userInfoRestTemplate")\n\t\t\tprivate OAuth2RestOperations restTemplate;\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnBean(ConnectionFactoryLocator.class)\n\t\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\t\tpublic SpringSocialTokenServices socialTokenServices() {\n\t\t\t\treturn new SpringSocialTokenServices(this.connectionFactory,\n\t\t\t\t\t\tthis.sso.getClientId());\n\t\t\t}\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnMissingBean({ ConnectionFactoryLocator.class,\n\t\t\t\t\tResourceServerTokenServices.class })\n\t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n\t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n\t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n\t\t\t\tservices.setTokenType(this.sso.getTokenType());\n\t\t\t\tservices.setRestTemplate(this.restTemplate);\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t\t@Configuration\n\t\t@ConditionalOnMissingClass("org.springframework.social.connect.support.OAuth2ConnectionFactory")\n\t\t@Conditional(NotTokenInfoCondition.class)\n\t\tprotected static class UserInfoTokenServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties sso;\n\n\t\t\t@Autowired(required = false)\n\t\t\t@Qualifier("userInfoRestTemplate")\n\t\t\tprivate OAuth2RestOperations restTemplate;\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n\t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n\t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n\t\t\t\tservices.setRestTemplate(this.restTemplate);\n\t\t\t\tservices.setTokenType(this.sso.getTokenType());\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(JwtTokenCondition.class)\n\tprotected static class JwtTokenServicesConfiguration {\n\n\t\tprivate RestTemplate keyUriRestTemplate = new RestTemplate();\n\n\t\t@Autowired\n\t\tprivate ResourceServerProperties resource;\n\n\t\t@Autowired(required = false)\n\t\tprivate List<JwtAccessTokenConverterConfigurer> configurers = Collections\n\t\t\t\t.emptyList();\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\tpublic ResourceServerTokenServices jwtTokenServices() {\n\t\t\tDefaultTokenServices services = new DefaultTokenServices();\n\t\t\tservices.setTokenStore(jwtTokenStore());\n\t\t\treturn services;\n\t\t}\n\n\t\t@Bean\n\t\tpublic TokenStore jwtTokenStore() {\n\t\t\treturn new JwtTokenStore(jwtTokenEnhancer());\n\t\t}\n\n\t\t@Bean\n\t\tpublic JwtAccessTokenConverter jwtTokenEnhancer() {\n\t\t\tJwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n\t\t\tString keyValue = this.resource.getJwt().getKeyValue();\n\t\t\tif (!StringUtils.hasText(keyValue)) {\n\t\t\t\ttry {\n\t\t\t\t\tkeyValue = getKeyFromServer();\n\t\t\t\t}\n\t\t\t\tcatch (ResourceAccessException ex) {\n\t\t\t\t\tlogger.warn("Failed to fetch token key (you may need to refresh "\n\t\t\t\t\t\t\t+ "when the auth server is back)");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(keyValue) && !keyValue.startsWith("-----BEGIN")) {\n\t\t\t\tconverter.setSigningKey(keyValue);\n\t\t\t}\n\t\t\tif (keyValue != null) {\n\t\t\t\tconverter.setVerifierKey(keyValue);\n\t\t\t}\n\t\t\tAnnotationAwareOrderComparator.sort(this.configurers);\n\t\t\tfor (JwtAccessTokenConverterConfigurer configurer : this.configurers) {\n\t\t\t\tconfigurer.configure(converter);\n\t\t\t}\n\t\t\treturn converter;\n\t\t}\n\n\t\tprivate String getKeyFromServer() {\n\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\tString username = this.resource.getClientId();\n\t\t\tString password = this.resource.getClientSecret();\n\t\t\tif (username != null && password != null) {\n\t\t\t\tbyte[] token = Base64.encode((username + ":" + password).getBytes());\n\t\t\t\theaders.add("Authorization", "Basic " + new String(token));\n\t\t\t}\n\t\t\tHttpEntity<Void> request = new HttpEntity<Void>(headers);\n\t\t\tString url = this.resource.getJwt().getKeyUri();\n\t\t\treturn (String) this.keyUriRestTemplate\n\t\t\t\t\t.exchange(url, HttpMethod.GET, request, Map.class).getBody()\n\t\t\t\t\t.get("value");\n\t\t}\n\n\t}\n\n\tprivate static class TokenInfoCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tEnvironment environment = context.getEnvironment();\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment,\n\t\t\t\t\t"spring.oauth2.resource.");\n\t\t\tBoolean preferTokenInfo = resolver.getProperty("prefer-token-info",\n\t\t\t\t\tBoolean.class);\n\t\t\tif (preferTokenInfo == null) {\n\t\t\t\tpreferTokenInfo = environment.resolvePlaceholders(\n\t\t\t\t\t\t"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true");\n\t\t\t}\n\t\t\tString tokenInfoUri = resolver.getProperty("token-info-uri");\n\t\t\tString userInfoUri = resolver.getProperty("user-info-uri");\n\t\t\tif (!StringUtils.hasLength(userInfoUri)) {\n\t\t\t\treturn ConditionOutcome.match("No user info provided");\n\t\t\t}\n\t\t\tif (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) {\n\t\t\t\treturn ConditionOutcome.match("Token info endpoint "\n\t\t\t\t\t\t+ "is preferred and user info provided");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("Token info endpoint is not provided");\n\t\t}\n\n\t}\n\n\tprivate static class JwtTokenCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(\n\t\t\t\t\tcontext.getEnvironment(), "spring.oauth2.resource.jwt.");\n\t\t\tString keyValue = resolver.getProperty("key-value");\n\t\t\tString keyUri = resolver.getProperty("key-uri");\n\t\t\tif (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) {\n\t\t\t\treturn ConditionOutcome.match("public key is provided");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("public key is not provided");\n\t\t}\n\n\t}\n\n\tprivate static class NotTokenInfoCondition extends SpringBootCondition {\n\n\t\tprivate TokenInfoCondition tokenInfoCondition = new TokenInfoCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\treturn ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome(\n\t\t\t\t\tcontext, metadata));\n\t\t}\n\n\t}\n\n\tprivate static class NotJwtTokenCondition extends SpringBootCondition {\n\n\t\tprivate JwtTokenCondition jwtTokenCondition = new JwtTokenCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\treturn ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome(\n\t\t\t\t\tcontext, metadata));\n\t\t}\n\n\t}\n\n\tprivate static class AcceptJsonRequestInterceptor implements\n\t\t\tClientHttpRequestInterceptor {\n\n\t\t@Override\n\t\tpublic ClientHttpResponse intercept(HttpRequest request, byte[] body,\n\t\t\t\tClientHttpRequestExecution execution) throws IOException {\n\t\t\trequest.getHeaders().setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n\t\t\treturn execution.execute(request, body);\n\t\t}\n\n\t}\n\n\tprivate static class AcceptJsonRequestEnhancer implements RequestEnhancer {\n\n\t\t@Override\n\t\tpublic void enhance(AccessTokenRequest request,\n\t\t\t\tOAuth2ProtectedResourceDetails resource,\n\t\t\t\tMultiValueMap<String, String> form, HttpHeaders headers) {\n\t\t\theaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.boot.autoconfigure.security.oauth2.resource;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.OrderComparator;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpRequest;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.client.ClientHttpRequestExecution;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.ClientHttpResponse;\nimport org.springframework.security.crypto.codec.Base64;\nimport org.springframework.security.oauth2.client.OAuth2ClientContext;\nimport org.springframework.security.oauth2.client.OAuth2RestOperations;\nimport org.springframework.security.oauth2.client.OAuth2RestTemplate;\nimport org.springframework.security.oauth2.client.resource.OAuth2ProtectedResourceDetails;\nimport org.springframework.security.oauth2.client.token.AccessTokenRequest;\nimport org.springframework.security.oauth2.client.token.RequestEnhancer;\nimport org.springframework.security.oauth2.client.token.grant.code.AuthorizationCodeAccessTokenProvider;\nimport org.springframework.security.oauth2.client.token.grant.code.AuthorizationCodeResourceDetails;\nimport org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerEndpointsConfiguration;\nimport org.springframework.security.oauth2.provider.token.DefaultTokenServices;\nimport org.springframework.security.oauth2.provider.token.RemoteTokenServices;\nimport org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;\nimport org.springframework.security.oauth2.provider.token.store.JwtTokenStore;\nimport org.springframework.social.connect.ConnectionFactoryLocator;\nimport org.springframework.social.connect.support.OAuth2ConnectionFactory;\nimport org.springframework.util.MultiValueMap;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.client.ResourceAccessException;\nimport org.springframework.web.client.RestTemplate;\n\n/**\n * @author Dave Syer\n *\n */\n@Configuration\n@ConditionalOnMissingBean(AuthorizationServerEndpointsConfiguration.class)\npublic class ResourceServerTokenServicesConfiguration {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(ResourceServerTokenServicesConfiguration.class);\n\n\t@Configuration\n\tprotected static class UserInfoRestTemplateConfiguration {\n\n\t\tprivate static final AuthorizationCodeResourceDetails DEFAULT_RESOURCE_DETAILS = new AuthorizationCodeResourceDetails();\n\n\t\tstatic {\n\t\t\tDEFAULT_RESOURCE_DETAILS.setClientId("<N/A>");\n\t\t\tDEFAULT_RESOURCE_DETAILS\n\t\t\t\t\t.setUserAuthorizationUri("Not a URI because there is no client");\n\t\t\tDEFAULT_RESOURCE_DETAILS\n\t\t\t\t\t.setAccessTokenUri("Not a URI because there is no client");\n\t\t}\n\n\t\t@Autowired(required = false)\n\t\tprivate List<UserInfoRestTemplateCustomizer> customizers = Collections\n\t\t\t\t.emptyList();\n\n\t\t@Autowired(required = false)\n\t\tprivate OAuth2ProtectedResourceDetails details;\n\n\t\t@Autowired(required = false)\n\t\tprivate OAuth2ClientContext oauth2ClientContext;\n\n\t\t@Bean(name = "userInfoRestTemplate")\n\t\tpublic OAuth2RestTemplate userInfoRestTemplate() {\n\t\t\tOAuth2RestTemplate template;\n\t\t\tif (details == null) {\n\t\t\t\tdetails = DEFAULT_RESOURCE_DETAILS;\n\t\t\t}\n\t\t\tif (oauth2ClientContext == null) {\n\t\t\t\ttemplate = new OAuth2RestTemplate(details);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttemplate = new OAuth2RestTemplate(details, oauth2ClientContext);\n\t\t\t}\n\t\t\ttemplate.setInterceptors(Arrays\n\t\t\t\t\t.<ClientHttpRequestInterceptor> asList(new ClientHttpRequestInterceptor() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic ClientHttpResponse intercept(HttpRequest request,\n\t\t\t\t\t\t\t\tbyte[] body, ClientHttpRequestExecution execution)\n\t\t\t\t\t\t\t\tthrows IOException {\n\t\t\t\t\t\t\trequest.getHeaders().setAccept(\n\t\t\t\t\t\t\t\t\tArrays.asList(MediaType.APPLICATION_JSON));\n\t\t\t\t\t\t\treturn execution.execute(request, body);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\tAuthorizationCodeAccessTokenProvider accessTokenProvider = new AuthorizationCodeAccessTokenProvider();\n\t\t\taccessTokenProvider.setTokenRequestEnhancer(new RequestEnhancer() {\n\t\t\t\t@Override\n\t\t\t\tpublic void enhance(AccessTokenRequest request,\n\t\t\t\t\t\tOAuth2ProtectedResourceDetails resource,\n\t\t\t\t\t\tMultiValueMap<String, String> form, HttpHeaders headers) {\n\t\t\t\t\theaders.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));\n\t\t\t\t}\n\t\t\t});\n\t\t\ttemplate.setAccessTokenProvider(accessTokenProvider);\n\t\t\tOrderComparator.sort(customizers);\n\t\t\tfor (UserInfoRestTemplateCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(template);\n\t\t\t}\n\t\t\treturn template;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(NotJwtToken.class)\n\tprotected static class RemoteTokenServicesConfiguration {\n\n\t\t@Configuration\n\t\t@Conditional(TokenInfo.class)\n\t\tprotected static class TokenInfoServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties resource;\n\n\t\t\t@Bean\n\t\t\tpublic ResourceServerTokenServices remoteTokenServices() {\n\t\t\t\tRemoteTokenServices services = new RemoteTokenServices();\n\t\t\t\tservices.setCheckTokenEndpointUrl(this.resource.getTokenInfoUri());\n\t\t\t\tservices.setClientId(this.resource.getClientId());\n\t\t\t\tservices.setClientSecret(this.resource.getClientSecret());\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t\t@Configuration\n\t\t@ConditionalOnClass(OAuth2ConnectionFactory.class)\n\t\t@Conditional(NotTokenInfo.class)\n\t\tprotected static class SocialTokenServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties sso;\n\n\t\t\t@Autowired(required = false)\n\t\t\tprivate OAuth2ConnectionFactory<?> connectionFactory;\n\n\t\t\t@Autowired(required = false)\n\t\t\t@Qualifier("userInfoRestTemplate")\n\t\t\tprivate OAuth2RestOperations restTemplate;\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnBean(ConnectionFactoryLocator.class)\n\t\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\t\tpublic SpringSocialTokenServices socialTokenServices() {\n\t\t\t\treturn new SpringSocialTokenServices(this.connectionFactory,\n\t\t\t\t\t\tthis.sso.getClientId());\n\t\t\t}\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnMissingBean({ ConnectionFactoryLocator.class,\n\t\t\t\t\tResourceServerTokenServices.class })\n\t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n\t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n\t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n\t\t\t\tservices.setTokenType(sso.getTokenType());\n\t\t\t\tservices.setRestTemplate(restTemplate);\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t\t@Configuration\n\t\t@ConditionalOnMissingClass("org.springframework.social.connect.support.OAuth2ConnectionFactory")\n\t\t@Conditional(NotTokenInfo.class)\n\t\tprotected static class UserInfoTokenServicesConfiguration {\n\n\t\t\t@Autowired\n\t\t\tprivate ResourceServerProperties sso;\n\n\t\t\t@Autowired(required = false)\n\t\t\t@Qualifier("userInfoRestTemplate")\n\t\t\tprivate OAuth2RestOperations restTemplate;\n\n\t\t\t@Bean\n\t\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\t\tpublic ResourceServerTokenServices userInfoTokenServices() {\n\t\t\t\tUserInfoTokenServices services = new UserInfoTokenServices(\n\t\t\t\t\t\tthis.sso.getUserInfoUri(), this.sso.getClientId());\n\t\t\t\tservices.setRestTemplate(restTemplate);\n\t\t\t\tservices.setTokenType(sso.getTokenType());\n\t\t\t\treturn services;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@Conditional(JwtToken.class)\n\tprotected static class JwtTokenServicesConfiguration {\n\n\t\tprivate RestTemplate keyUriRestTemplate = new RestTemplate();\n\n\t\t@Autowired\n\t\tprivate ResourceServerProperties resource;\n\n\t\t@Autowired(required = false)\n\t\tprivate List<JwtAccessTokenConverterConfigurer> configurers = Collections\n\t\t\t\t.emptyList();\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(ResourceServerTokenServices.class)\n\t\tpublic ResourceServerTokenServices jwtTokenServices() {\n\t\t\tDefaultTokenServices services = new DefaultTokenServices();\n\t\t\tservices.setTokenStore(jwtTokenStore());\n\t\t\treturn services;\n\t\t}\n\n\t\t@Bean\n\t\tpublic TokenStore jwtTokenStore() {\n\t\t\treturn new JwtTokenStore(jwtTokenEnhancer());\n\t\t}\n\n\t\t@Bean\n\t\tpublic JwtAccessTokenConverter jwtTokenEnhancer() {\n\t\t\tJwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n\t\t\tString keyValue = this.resource.getJwt().getKeyValue();\n\t\t\tif (!StringUtils.hasText(keyValue)) {\n\t\t\t\ttry {\n\t\t\t\t\tHttpHeaders headers = new HttpHeaders();\n\t\t\t\t\tif (resource.getClientId() != null\n\t\t\t\t\t\t\t&& resource.getClientSecret() != null) {\n\t\t\t\t\t\tbyte[] token = Base64\n\t\t\t\t\t\t\t\t.encode((resource.getClientId() + ":" + resource\n\t\t\t\t\t\t\t\t\t\t.getClientSecret()).getBytes());\n\t\t\t\t\t\theaders.add("Authorization", "Basic " + new String(token));\n\t\t\t\t\t}\n\t\t\t\t\tHttpEntity<Void> requestEntity = new HttpEntity<Void>(headers);\n\t\t\t\t\tkeyValue = (String) keyUriRestTemplate\n\t\t\t\t\t\t\t.exchange(resource.getJwt().getKeyUri(), HttpMethod.GET,\n\t\t\t\t\t\t\t\t\trequestEntity, Map.class).getBody().get("value");\n\t\t\t\t}\n\t\t\t\tcatch (ResourceAccessException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t\tlogger.warn("Failed to fetch token key (you may need to refresh when the auth server is back)");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (StringUtils.hasText(keyValue) && !keyValue.startsWith("-----BEGIN")) {\n\t\t\t\tconverter.setSigningKey(keyValue);\n\t\t\t}\n\t\t\tif (keyValue != null) {\n\t\t\t\tconverter.setVerifierKey(keyValue);\n\t\t\t}\n\t\t\tAnnotationAwareOrderComparator.sort(configurers);\n\t\t\tfor (JwtAccessTokenConverterConfigurer configurer : configurers) {\n\t\t\t\tconfigurer.configure(converter);\n\t\t\t}\n\t\t\treturn converter;\n\t\t}\n\n\t}\n\n\tprivate static class TokenInfo extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tEnvironment environment = context.getEnvironment();\n\t\t\tboolean preferTokenInfo = environment\n\t\t\t\t\t.resolvePlaceholders(\n\t\t\t\t\t\t\t"${spring.oauth2.resource.preferTokenInfo:${OAUTH2_RESOURCE_PREFERTOKENINFO:true}}")\n\t\t\t\t\t.equals("true");\n\t\t\tboolean hasTokenInfo = !environment.resolvePlaceholders(\n\t\t\t\t\t"${spring.oauth2.resource.tokenInfoUri:}").equals("");\n\t\t\tboolean hasUserInfo = !environment.resolvePlaceholders(\n\t\t\t\t\t"${spring.oauth2.resource.userInfoUri:}").equals("");\n\t\t\tif (!hasUserInfo) {\n\t\t\t\treturn ConditionOutcome.match("No user info provided");\n\t\t\t}\n\t\t\tif (hasTokenInfo) {\n\t\t\t\tif (preferTokenInfo) {\n\t\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t\t.match("Token info endpoint is preferred and user info provided");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("Token info endpoint is not provided");\n\t\t}\n\n\t}\n\n\tprivate static class JwtToken extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (StringUtils.hasText(context.getEnvironment().getProperty(\n\t\t\t\t\t"spring.oauth2.resource.jwt.keyValue"))\n\t\t\t\t\t|| StringUtils.hasText(context.getEnvironment().getProperty(\n\t\t\t\t\t\t\t"spring.oauth2.resource.jwt.keyUri"))) {\n\t\t\t\treturn ConditionOutcome.match("public key is provided");\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch("public key is not provided");\n\t\t}\n\n\t}\n\n\tprivate static class NotTokenInfo extends SpringBootCondition {\n\n\t\tprivate TokenInfo opposite = new TokenInfo();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tConditionOutcome outcome = this.opposite.getMatchOutcome(context, metadata);\n\t\t\tif (outcome.isMatch()) {\n\t\t\t\treturn ConditionOutcome.noMatch(outcome.getMessage());\n\t\t\t}\n\t\t\treturn ConditionOutcome.match(outcome.getMessage());\n\t\t}\n\n\t}\n\n\tprivate static class NotJwtToken extends SpringBootCondition {\n\n\t\tprivate JwtToken opposite = new JwtToken();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tConditionOutcome outcome = this.opposite.getMatchOutcome(context, metadata);\n\t\t\tif (outcome.isMatch()) {\n\t\t\t\treturn ConditionOutcome.noMatch(outcome.getMessage());\n\t\t\t}\n\t\t\treturn ConditionOutcome.match(outcome.getMessage());\n\t\t}\n\n\t}\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
