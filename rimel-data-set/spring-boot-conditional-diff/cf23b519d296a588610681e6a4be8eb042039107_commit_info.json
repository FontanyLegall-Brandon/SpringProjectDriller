{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -64,7 +64,7 @@ import org.springframework.util.StringUtils;\n  * @author Phillip Webb\n  */\n @Configuration\n-@ConditionalOnClass(EmbeddedDatabaseType.class /* Spring JDBC */)\n+@ConditionalOnClass(EmbeddedDatabaseType.class)\n public class DataSourceAutoConfiguration implements EnvironmentAware {\n \n \tprivate static Log logger = LogFactory.getLog(DataSourceAutoConfiguration.class);\n@@ -77,26 +77,27 @@ public class DataSourceAutoConfiguration implements EnvironmentAware {\n \t@Autowired\n \tprivate ApplicationContext applicationContext;\n \n-\tprivate RelaxedPropertyResolver environment;\n+\tprivate RelaxedPropertyResolver datasourceProperties;\n \n \t@Override\n \tpublic void setEnvironment(Environment environment) {\n-\t\tthis.environment = new RelaxedPropertyResolver(environment, CONFIGURATION_PREFIX\n-\t\t\t\t+ ".");\n+\t\tthis.datasourceProperties = new RelaxedPropertyResolver(environment,\n+\t\t\t\tCONFIGURATION_PREFIX + ".");\n \t}\n \n \t@PostConstruct\n \tprotected void initialize() throws Exception {\n-\t\tif (this.dataSource == null\n-\t\t\t\t|| !this.environment.getProperty("initialize", Boolean.class, true)) {\n+\t\tboolean initialize = this.datasourceProperties.getProperty("initialize",\n+\t\t\t\tBoolean.class, true);\n+\t\tif (this.dataSource == null || !initialize) {\n \t\t\tlogger.debug("No DataSource found so not initializing");\n \t\t\treturn;\n \t\t}\n \n-\t\tString schema = this.environment.getProperty("schema");\n+\t\tString schema = this.datasourceProperties.getProperty("schema");\n \t\tif (schema == null) {\n \t\t\tschema = "classpath*:schema-"\n-\t\t\t\t\t+ this.environment.getProperty("platform", "all")\n+\t\t\t\t\t+ this.datasourceProperties.getProperty("platform", "all")\n \t\t\t\t\t+ ".sql,classpath*:schema.sql,classpath*:data.sql";\n \t\t}\n \n@@ -106,8 +107,8 @@ public class DataSourceAutoConfiguration implements EnvironmentAware {\n \t\t\t\t\t.getResources(schemaLocation)));\n \t\t}\n \n-\t\tboolean continueOnError = this.environment.getProperty("continueOnError",\n-\t\t\t\tBoolean.class, false);\n+\t\tboolean continueOnError = this.datasourceProperties.getProperty(\n+\t\t\t\t"continueOnError", Boolean.class, false);\n \t\tboolean exists = false;\n \t\tResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n \t\tfor (Resource resource : resources) {\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jdbc;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.annotation.PostConstruct;\nimport javax.sql.DataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.EnvironmentAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\nimport org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\nimport org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for {@link DataSource}.\n * \n * @author Dave Syer\n * @author Phillip Webb\n */\n@Configuration\n@ConditionalOnClass(EmbeddedDatabaseType.class)\npublic class DataSourceAutoConfiguration implements EnvironmentAware {\n\n\tprivate static Log logger = LogFactory.getLog(DataSourceAutoConfiguration.class);\n\n\tpublic static final String CONFIGURATION_PREFIX = "spring.datasource";\n\n\t@Autowired(required = false)\n\tprivate DataSource dataSource;\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\tprivate RelaxedPropertyResolver datasourceProperties;\n\n\t@Override\n\tpublic void setEnvironment(Environment environment) {\n\t\tthis.datasourceProperties = new RelaxedPropertyResolver(environment,\n\t\t\t\tCONFIGURATION_PREFIX + ".");\n\t}\n\n\t@PostConstruct\n\tprotected void initialize() throws Exception {\n\t\tboolean initialize = this.datasourceProperties.getProperty("initialize",\n\t\t\t\tBoolean.class, true);\n\t\tif (this.dataSource == null || !initialize) {\n\t\t\tlogger.debug("No DataSource found so not initializing");\n\t\t\treturn;\n\t\t}\n\n\t\tString schema = this.datasourceProperties.getProperty("schema");\n\t\tif (schema == null) {\n\t\t\tschema = "classpath*:schema-"\n\t\t\t\t\t+ this.datasourceProperties.getProperty("platform", "all")\n\t\t\t\t\t+ ".sql,classpath*:schema.sql,classpath*:data.sql";\n\t\t}\n\n\t\tList<Resource> resources = new ArrayList<Resource>();\n\t\tfor (String schemaLocation : StringUtils.commaDelimitedListToStringArray(schema)) {\n\t\t\tresources.addAll(Arrays.asList(this.applicationContext\n\t\t\t\t\t.getResources(schemaLocation)));\n\t\t}\n\n\t\tboolean continueOnError = this.datasourceProperties.getProperty(\n\t\t\t\t"continueOnError", Boolean.class, false);\n\t\tboolean exists = false;\n\t\tResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n\t\tfor (Resource resource : resources) {\n\t\t\tif (resource.exists()) {\n\t\t\t\texists = true;\n\t\t\t\tpopulator.addScript(resource);\n\t\t\t\tpopulator.setContinueOnError(continueOnError);\n\t\t\t}\n\t\t}\n\n\t\tif (exists) {\n\t\t\tDatabasePopulatorUtils.execute(populator, this.dataSource);\n\t\t}\n\t}\n\n\t/**\n\t * Determines if the {@code dataSource} being used by Spring was created from\n\t * {@link EmbeddedDataSourceConfiguration}.\n\t * @return true if the data source was auto-configured.\n\t */\n\tpublic static boolean containsAutoConfiguredDataSource(\n\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\ttry {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition("dataSource");\n\t\t\treturn EmbeddedDataSourceConfiguration.class.getName().equals(\n\t\t\t\t\tbeanDefinition.getFactoryBeanName());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedConfiguration {\n\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.TomcatDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(TomcatDataSourceConfiguration.class)\n\tprotected static class TomcatConfiguration {\n\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.BasicDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(CommonsDataSourceConfiguration.class)\n\tprotected static class DbcpConfiguration {\n\n\t}\n\n\t@Configuration\n\t@Conditional(DataSourceAutoConfiguration.DatabaseCondition.class)\n\tprotected static class JdbcTemplateConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate DataSource dataSource;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(JdbcOperations.class)\n\t\tpublic JdbcTemplate jdbcTemplate() {\n\t\t\treturn new JdbcTemplate(this.dataSource);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\n\t\tpublic NamedParameterJdbcOperations namedParameterJdbcTemplate() {\n\t\t\treturn new NamedParameterJdbcTemplate(this.dataSource);\n\t\t}\n\n\t}\n\n\t/**\n\t * Base {@link Condition} for non-embedded database checks.\n\t */\n\tstatic abstract class NonEmbeddedDatabaseCondition extends SpringBootCondition {\n\n\t\tprotected abstract String getDataSourceClassName();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\n\t\t\tif (!ClassUtils.isPresent(getDataSourceClassName(), context.getClassLoader())) {\n\t\t\t\treturn ConditionOutcome.noMatch(getDataSourceClassName()\n\t\t\t\t\t\t+ " DataSource class not found");\n\t\t\t}\n\n\t\t\tString driverClassName = getDriverClassName(context.getEnvironment(),\n\t\t\t\t\tgetDataSourceClassLoader(context));\n\t\t\tif (driverClassName == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no database driver");\n\t\t\t}\n\n\t\t\tString url = getUrl(context.getEnvironment(), context.getClassLoader());\n\t\t\tif (url == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no database URL");\n\t\t\t}\n\n\t\t\tif (ClassUtils.isPresent(driverClassName, context.getClassLoader())) {\n\t\t\t\treturn ConditionOutcome.match("found database driver " + driverClassName);\n\t\t\t}\n\n\t\t\treturn ConditionOutcome.noMatch("missing database driver " + driverClassName);\n\t\t}\n\n\t\t/**\n\t\t * Returns the class loader for the {@link DataSource} class. Used to ensure that\n\t\t * the driver class can actually be loaded by the data source.\n\t\t */\n\t\tprivate ClassLoader getDataSourceClassLoader(ConditionContext context) {\n\t\t\ttry {\n\t\t\t\tClass<?> dataSourceClass = ClassUtils.forName(getDataSourceClassName(),\n\t\t\t\t\t\tcontext.getClassLoader());\n\t\t\t\treturn dataSourceClass.getClassLoader();\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate String getDriverClassName(Environment environment, ClassLoader classLoader) {\n\t\t\tString driverClassName = environment == null ? null : environment\n\t\t\t\t\t.getProperty(CONFIGURATION_PREFIX + ".driverClassName");\n\t\t\tif (driverClassName == null) {\n\t\t\t\tdriverClassName = EmbeddedDatabaseConnection.get(classLoader)\n\t\t\t\t\t\t.getDriverClassName();\n\t\t\t}\n\t\t\treturn driverClassName;\n\t\t}\n\n\t\tprivate String getUrl(Environment environment, ClassLoader classLoader) {\n\t\t\tString url = (environment == null ? null : environment\n\t\t\t\t\t.getProperty(CONFIGURATION_PREFIX + ".url"));\n\t\t\tif (url == null) {\n\t\t\t\turl = EmbeddedDatabaseConnection.get(classLoader).getUrl();\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a commons-dbcp {@code BasicDataSource} backed\n\t * database is used.\n\t */\n\tstatic class BasicDatabaseCondition extends NonEmbeddedDatabaseCondition {\n\n\t\tprivate final Condition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\t@Override\n\t\tprotected String getDataSourceClassName() {\n\t\t\treturn "org.apache.commons.dbcp.BasicDataSource";\n\t\t}\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (matches(context, metadata, this.tomcatCondition)) {\n\t\t\t\treturn ConditionOutcome.noMatch("Tomcat DataSource");\n\t\t\t}\n\t\t\treturn super.getMatchOutcome(context, metadata);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a Tomcat DataSource backed database is used.\n\t */\n\tstatic class TomcatDatabaseCondition extends NonEmbeddedDatabaseCondition {\n\n\t\t@Override\n\t\tprotected String getDataSourceClassName() {\n\t\t\treturn "org.apache.tomcat.jdbc.pool.DataSource";\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when an embedded database is used.\n\t */\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\tprivate final SpringBootCondition dbcpCondition = new BasicDatabaseCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (anyMatches(context, metadata, this.tomcatCondition, this.dbcpCondition)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch("existing non-embedded database detected");\n\t\t\t}\n\t\t\tEmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(\n\t\t\t\t\tcontext.getClassLoader()).getType();\n\t\t\tif (type == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no embedded database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.match("embedded database " + type + " detected");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a database is configured.\n\t */\n\tstatic class DatabaseCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\tprivate final SpringBootCondition dbcpCondition = new BasicDatabaseCondition();\n\n\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDatabaseCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\n\t\t\tif (anyMatches(context, metadata, this.tomcatCondition, this.dbcpCondition,\n\t\t\t\t\tthis.embeddedCondition)) {\n\t\t\t\treturn ConditionOutcome.match("existing auto database detected");\n\t\t\t}\n\n\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tcontext.getBeanFactory(), DataSource.class, true, false).length > 0) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.match("Existing bean configured database detected");\n\t\t\t}\n\n\t\t\treturn ConditionOutcome.noMatch("no existing bean configured database");\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jdbc;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.annotation.PostConstruct;\nimport javax.sql.DataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.EnvironmentAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Condition;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;\nimport org.springframework.jdbc.datasource.init.DatabasePopulatorUtils;\nimport org.springframework.jdbc.datasource.init.ResourceDatabasePopulator;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for {@link DataSource}.\n * \n * @author Dave Syer\n * @author Phillip Webb\n */\n@Configuration\n@ConditionalOnClass(EmbeddedDatabaseType.class /* Spring JDBC */)\npublic class DataSourceAutoConfiguration implements EnvironmentAware {\n\n\tprivate static Log logger = LogFactory.getLog(DataSourceAutoConfiguration.class);\n\n\tpublic static final String CONFIGURATION_PREFIX = "spring.datasource";\n\n\t@Autowired(required = false)\n\tprivate DataSource dataSource;\n\n\t@Autowired\n\tprivate ApplicationContext applicationContext;\n\n\tprivate RelaxedPropertyResolver environment;\n\n\t@Override\n\tpublic void setEnvironment(Environment environment) {\n\t\tthis.environment = new RelaxedPropertyResolver(environment, CONFIGURATION_PREFIX\n\t\t\t\t+ ".");\n\t}\n\n\t@PostConstruct\n\tprotected void initialize() throws Exception {\n\t\tif (this.dataSource == null\n\t\t\t\t|| !this.environment.getProperty("initialize", Boolean.class, true)) {\n\t\t\tlogger.debug("No DataSource found so not initializing");\n\t\t\treturn;\n\t\t}\n\n\t\tString schema = this.environment.getProperty("schema");\n\t\tif (schema == null) {\n\t\t\tschema = "classpath*:schema-"\n\t\t\t\t\t+ this.environment.getProperty("platform", "all")\n\t\t\t\t\t+ ".sql,classpath*:schema.sql,classpath*:data.sql";\n\t\t}\n\n\t\tList<Resource> resources = new ArrayList<Resource>();\n\t\tfor (String schemaLocation : StringUtils.commaDelimitedListToStringArray(schema)) {\n\t\t\tresources.addAll(Arrays.asList(this.applicationContext\n\t\t\t\t\t.getResources(schemaLocation)));\n\t\t}\n\n\t\tboolean continueOnError = this.environment.getProperty("continueOnError",\n\t\t\t\tBoolean.class, false);\n\t\tboolean exists = false;\n\t\tResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n\t\tfor (Resource resource : resources) {\n\t\t\tif (resource.exists()) {\n\t\t\t\texists = true;\n\t\t\t\tpopulator.addScript(resource);\n\t\t\t\tpopulator.setContinueOnError(continueOnError);\n\t\t\t}\n\t\t}\n\n\t\tif (exists) {\n\t\t\tDatabasePopulatorUtils.execute(populator, this.dataSource);\n\t\t}\n\t}\n\n\t/**\n\t * Determines if the {@code dataSource} being used by Spring was created from\n\t * {@link EmbeddedDataSourceConfiguration}.\n\t * @return true if the data source was auto-configured.\n\t */\n\tpublic static boolean containsAutoConfiguredDataSource(\n\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\ttry {\n\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition("dataSource");\n\t\t\treturn EmbeddedDataSourceConfiguration.class.getName().equals(\n\t\t\t\t\tbeanDefinition.getFactoryBeanName());\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.EmbeddedDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(EmbeddedDataSourceConfiguration.class)\n\tprotected static class EmbeddedConfiguration {\n\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.TomcatDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(TomcatDataSourceConfiguration.class)\n\tprotected static class TomcatConfiguration {\n\n\t}\n\n\t@Conditional(DataSourceAutoConfiguration.BasicDatabaseCondition.class)\n\t@ConditionalOnMissingBean(DataSource.class)\n\t@Import(CommonsDataSourceConfiguration.class)\n\tprotected static class DbcpConfiguration {\n\n\t}\n\n\t@Configuration\n\t@Conditional(DataSourceAutoConfiguration.DatabaseCondition.class)\n\tprotected static class JdbcTemplateConfiguration {\n\n\t\t@Autowired(required = false)\n\t\tprivate DataSource dataSource;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(JdbcOperations.class)\n\t\tpublic JdbcTemplate jdbcTemplate() {\n\t\t\treturn new JdbcTemplate(this.dataSource);\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)\n\t\tpublic NamedParameterJdbcOperations namedParameterJdbcTemplate() {\n\t\t\treturn new NamedParameterJdbcTemplate(this.dataSource);\n\t\t}\n\n\t}\n\n\t/**\n\t * Base {@link Condition} for non-embedded database checks.\n\t */\n\tstatic abstract class NonEmbeddedDatabaseCondition extends SpringBootCondition {\n\n\t\tprotected abstract String getDataSourceClassName();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\n\t\t\tif (!ClassUtils.isPresent(getDataSourceClassName(), context.getClassLoader())) {\n\t\t\t\treturn ConditionOutcome.noMatch(getDataSourceClassName()\n\t\t\t\t\t\t+ " DataSource class not found");\n\t\t\t}\n\n\t\t\tString driverClassName = getDriverClassName(context.getEnvironment(),\n\t\t\t\t\tgetDataSourceClassLoader(context));\n\t\t\tif (driverClassName == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no database driver");\n\t\t\t}\n\n\t\t\tString url = getUrl(context.getEnvironment(), context.getClassLoader());\n\t\t\tif (url == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no database URL");\n\t\t\t}\n\n\t\t\tif (ClassUtils.isPresent(driverClassName, context.getClassLoader())) {\n\t\t\t\treturn ConditionOutcome.match("found database driver " + driverClassName);\n\t\t\t}\n\n\t\t\treturn ConditionOutcome.noMatch("missing database driver " + driverClassName);\n\t\t}\n\n\t\t/**\n\t\t * Returns the class loader for the {@link DataSource} class. Used to ensure that\n\t\t * the driver class can actually be loaded by the data source.\n\t\t */\n\t\tprivate ClassLoader getDataSourceClassLoader(ConditionContext context) {\n\t\t\ttry {\n\t\t\t\tClass<?> dataSourceClass = ClassUtils.forName(getDataSourceClassName(),\n\t\t\t\t\t\tcontext.getClassLoader());\n\t\t\t\treturn dataSourceClass.getClassLoader();\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate String getDriverClassName(Environment environment, ClassLoader classLoader) {\n\t\t\tString driverClassName = environment == null ? null : environment\n\t\t\t\t\t.getProperty(CONFIGURATION_PREFIX + ".driverClassName");\n\t\t\tif (driverClassName == null) {\n\t\t\t\tdriverClassName = EmbeddedDatabaseConnection.get(classLoader)\n\t\t\t\t\t\t.getDriverClassName();\n\t\t\t}\n\t\t\treturn driverClassName;\n\t\t}\n\n\t\tprivate String getUrl(Environment environment, ClassLoader classLoader) {\n\t\t\tString url = (environment == null ? null : environment\n\t\t\t\t\t.getProperty(CONFIGURATION_PREFIX + ".url"));\n\t\t\tif (url == null) {\n\t\t\t\turl = EmbeddedDatabaseConnection.get(classLoader).getUrl();\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a commons-dbcp {@code BasicDataSource} backed\n\t * database is used.\n\t */\n\tstatic class BasicDatabaseCondition extends NonEmbeddedDatabaseCondition {\n\n\t\tprivate final Condition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\t@Override\n\t\tprotected String getDataSourceClassName() {\n\t\t\treturn "org.apache.commons.dbcp.BasicDataSource";\n\t\t}\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (matches(context, metadata, this.tomcatCondition)) {\n\t\t\t\treturn ConditionOutcome.noMatch("Tomcat DataSource");\n\t\t\t}\n\t\t\treturn super.getMatchOutcome(context, metadata);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a Tomcat DataSource backed database is used.\n\t */\n\tstatic class TomcatDatabaseCondition extends NonEmbeddedDatabaseCondition {\n\n\t\t@Override\n\t\tprotected String getDataSourceClassName() {\n\t\t\treturn "org.apache.tomcat.jdbc.pool.DataSource";\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when an embedded database is used.\n\t */\n\tstatic class EmbeddedDatabaseCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\tprivate final SpringBootCondition dbcpCondition = new BasicDatabaseCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tif (anyMatches(context, metadata, this.tomcatCondition, this.dbcpCondition)) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.noMatch("existing non-embedded database detected");\n\t\t\t}\n\t\t\tEmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(\n\t\t\t\t\tcontext.getClassLoader()).getType();\n\t\t\tif (type == null) {\n\t\t\t\treturn ConditionOutcome.noMatch("no embedded database detected");\n\t\t\t}\n\t\t\treturn ConditionOutcome.match("embedded database " + type + " detected");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link Condition} to detect when a database is configured.\n\t */\n\tstatic class DatabaseCondition extends SpringBootCondition {\n\n\t\tprivate final SpringBootCondition tomcatCondition = new TomcatDatabaseCondition();\n\n\t\tprivate final SpringBootCondition dbcpCondition = new BasicDatabaseCondition();\n\n\t\tprivate final SpringBootCondition embeddedCondition = new EmbeddedDatabaseCondition();\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\n\t\t\tif (anyMatches(context, metadata, this.tomcatCondition, this.dbcpCondition,\n\t\t\t\t\tthis.embeddedCondition)) {\n\t\t\t\treturn ConditionOutcome.match("existing auto database detected");\n\t\t\t}\n\n\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n\t\t\t\t\tcontext.getBeanFactory(), DataSource.class, true, false).length > 0) {\n\t\t\t\treturn ConditionOutcome\n\t\t\t\t\t\t.match("Existing bean configured database detected");\n\t\t\t}\n\n\t\t\treturn ConditionOutcome.noMatch("no existing bean configured database");\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
