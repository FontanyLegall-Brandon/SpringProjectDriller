{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -45,6 +45,7 @@ import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\n import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\n@@ -147,18 +148,21 @@ public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n \n \t@Bean\n \t@ConditionalOnBean(EnvironmentEndpoint.class)\n+\t@ConditionalOnExpression("${endpoints.env.enabled:true}")\n \tpublic EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {\n \t\treturn new EnvironmentMvcEndpoint(delegate);\n \t}\n \n \t@Bean\n \t@ConditionalOnBean(MetricsEndpoint.class)\n+\t@ConditionalOnExpression("${endpoints.metrics.enabled:true}")\n \tpublic MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {\n \t\treturn new MetricsMvcEndpoint(delegate);\n \t}\n \n \t@Bean\n \t@ConditionalOnBean(ShutdownEndpoint.class)\n+\t@ConditionalOnExpression("${endpoints.shutdown.enabled:false}")\n \tpublic ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {\n \t\treturn new ShutdownMvcEndpoint(delegate);\n \t}\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;\nimport org.springframework.boot.actuate.endpoint.MetricsEndpoint;\nimport org.springframework.boot.actuate.endpoint.ShutdownEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;\nimport org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n * \n * @author Dave Syer\n * @author Phillip Webb\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tEmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tManagementServerPropertiesAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n\t\tApplicationListener<ContextRefreshedEvent> {\n\n\tprivate static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\t@Autowired\n\tprivate ManagementServerProperties managementServerProperties;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic EndpointHandlerMapping endpointHandlerMapping() {\n\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(mvcEndpoints()\n\t\t\t\t.getEndpoints());\n\t\tboolean disabled = ManagementServerPort.get(this.applicationContext) != ManagementServerPort.SAME;\n\t\tmapping.setDisabled(disabled);\n\t\tif (!disabled) {\n\t\t\tmapping.setPrefix(this.managementServerProperties.getContextPath());\n\t\t}\n\t\treturn mapping;\n\t}\n\n\t@Override\n\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tif (ManagementServerPort.get(this.applicationContext) == ManagementServerPort.DIFFERENT\n\t\t\t\t\t&& this.applicationContext instanceof WebApplicationContext) {\n\t\t\t\tcreateChildManagementContext();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\tprotected static class ApplicationContextFilterConfiguration {\n\t\t@Bean\n\t\tpublic Filter applicationContextIdFilter(ApplicationContext context) {\n\t\t\tfinal String id = context.getId();\n\t\t\treturn new OncePerRequestFilter() {\n\t\t\t\t@Override\n\t\t\t\tprotected void doFilterInternal(HttpServletRequest request,\n\t\t\t\t\t\tHttpServletResponse response, FilterChain filterChain)\n\t\t\t\t\t\tthrows ServletException, IOException {\n\t\t\t\t\tresponse.addHeader("X-Application-Context", id);\n\t\t\t\t\tfilterChain.doFilter(request, response);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic MvcEndpoints mvcEndpoints() {\n\t\treturn new MvcEndpoints();\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(EnvironmentEndpoint.class)\n\t@ConditionalOnExpression("${endpoints.env.enabled:true}")\n\tpublic EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {\n\t\treturn new EnvironmentMvcEndpoint(delegate);\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(MetricsEndpoint.class)\n\t@ConditionalOnExpression("${endpoints.metrics.enabled:true}")\n\tpublic MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {\n\t\treturn new MetricsMvcEndpoint(delegate);\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(ShutdownEndpoint.class)\n\t@ConditionalOnExpression("${endpoints.shutdown.enabled:false}")\n\tpublic ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {\n\t\treturn new ShutdownMvcEndpoint(delegate);\n\t}\n\n\tprivate void createChildManagementContext() {\n\n\t\tfinal AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\n\t\t// Register the ManagementServerChildContextConfiguration first followed\n\t\t// by various specific AutoConfiguration classes. NOTE: The child context\n\t\t// is intentionally not completely auto-configured.\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tEmbeddedServletContainerAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\n\t\t// Ensure close on the parent also closes the child\n\t\tif (this.applicationContext instanceof ConfigurableApplicationContext) {\n\t\t\t((ConfigurableApplicationContext) this.applicationContext)\n\t\t\t\t\t.addApplicationListener(new ApplicationListener<ContextClosedEvent>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\t\t\t\t\t\tif (event.getApplicationContext() == EndpointWebMvcAutoConfiguration.this.applicationContext) {\n\t\t\t\t\t\t\t\tchildContext.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\ttry {\n\t\t\tchildContext.refresh();\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\t// No support currently for deploying a war with management.port=<different>,\n\t\t\t// and this is the signature of that happening\n\t\t\tif (e instanceof EmbeddedServletContainerException\n\t\t\t\t\t|| e.getCause() instanceof EmbeddedServletContainerException) {\n\t\t\t\tlogger.warn("Could not start embedded container (management endpoints are still available through JMX)");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected static enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(BeanFactory beanFactory) {\n\n\t\t\tServerProperties serverProperties;\n\t\t\ttry {\n\t\t\t\tserverProperties = beanFactory.getBean(ServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tserverProperties = new ServerProperties();\n\t\t\t}\n\n\t\t\tManagementServerProperties managementServerProperties;\n\t\t\ttry {\n\t\t\t\tmanagementServerProperties = beanFactory\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tmanagementServerProperties = new ManagementServerProperties();\n\t\t\t}\n\n\t\t\tInteger port = managementServerProperties.getPort();\n\t\t\tif (port != null && port < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\tif (!(beanFactory instanceof WebApplicationContext)) {\n\t\t\t\t// Current context is not a webapp\n\t\t\t\treturn DIFFERENT;\n\t\t\t}\n\t\t\treturn ((port == null)\n\t\t\t\t\t|| (serverProperties.getPort() == null && port.equals(8080))\n\t\t\t\t\t|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME\n\t\t\t\t\t: DIFFERENT);\n\t\t}\n\t};\n}\n', 'source_code_before': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.Servlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;\nimport org.springframework.boot.actuate.endpoint.MetricsEndpoint;\nimport org.springframework.boot.actuate.endpoint.ShutdownEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;\nimport org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.ContextClosedEvent;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport org.springframework.web.servlet.DispatcherServlet;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} to enable Spring MVC to handle\n * {@link Endpoint} requests. If the {@link ManagementServerProperties} specifies a\n * different port to {@link ServerProperties} a new child context is created, otherwise it\n * is assumed that endpoint requests will be mapped and handled via an already registered\n * {@link DispatcherServlet}.\n * \n * @author Dave Syer\n * @author Phillip Webb\n */\n@Configuration\n@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication\n@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,\n\t\tEmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,\n\t\tManagementServerPropertiesAutoConfiguration.class })\npublic class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,\n\t\tApplicationListener<ContextRefreshedEvent> {\n\n\tprivate static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);\n\n\tprivate ApplicationContext applicationContext;\n\n\t@Autowired\n\tprivate ManagementServerProperties managementServerProperties;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext)\n\t\t\tthrows BeansException {\n\t\tthis.applicationContext = applicationContext;\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic EndpointHandlerMapping endpointHandlerMapping() {\n\t\tEndpointHandlerMapping mapping = new EndpointHandlerMapping(mvcEndpoints()\n\t\t\t\t.getEndpoints());\n\t\tboolean disabled = ManagementServerPort.get(this.applicationContext) != ManagementServerPort.SAME;\n\t\tmapping.setDisabled(disabled);\n\t\tif (!disabled) {\n\t\t\tmapping.setPrefix(this.managementServerProperties.getContextPath());\n\t\t}\n\t\treturn mapping;\n\t}\n\n\t@Override\n\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\tif (event.getApplicationContext() == this.applicationContext) {\n\t\t\tif (ManagementServerPort.get(this.applicationContext) == ManagementServerPort.DIFFERENT\n\t\t\t\t\t&& this.applicationContext instanceof WebApplicationContext) {\n\t\t\t\tcreateChildManagementContext();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Put Servlets and Filters in their own nested class so they don\'t force early\n\t// instantiation of ManagementServerProperties.\n\t@Configuration\n\tprotected static class ApplicationContextFilterConfiguration {\n\t\t@Bean\n\t\tpublic Filter applicationContextIdFilter(ApplicationContext context) {\n\t\t\tfinal String id = context.getId();\n\t\t\treturn new OncePerRequestFilter() {\n\t\t\t\t@Override\n\t\t\t\tprotected void doFilterInternal(HttpServletRequest request,\n\t\t\t\t\t\tHttpServletResponse response, FilterChain filterChain)\n\t\t\t\t\t\tthrows ServletException, IOException {\n\t\t\t\t\tresponse.addHeader("X-Application-Context", id);\n\t\t\t\t\tfilterChain.doFilter(request, response);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic MvcEndpoints mvcEndpoints() {\n\t\treturn new MvcEndpoints();\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(EnvironmentEndpoint.class)\n\tpublic EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {\n\t\treturn new EnvironmentMvcEndpoint(delegate);\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(MetricsEndpoint.class)\n\tpublic MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {\n\t\treturn new MetricsMvcEndpoint(delegate);\n\t}\n\n\t@Bean\n\t@ConditionalOnBean(ShutdownEndpoint.class)\n\tpublic ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {\n\t\treturn new ShutdownMvcEndpoint(delegate);\n\t}\n\n\tprivate void createChildManagementContext() {\n\n\t\tfinal AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tchildContext.setParent(this.applicationContext);\n\t\tchildContext.setId(this.applicationContext.getId() + ":management");\n\n\t\t// Register the ManagementServerChildContextConfiguration first followed\n\t\t// by various specific AutoConfiguration classes. NOTE: The child context\n\t\t// is intentionally not completely auto-configured.\n\t\tchildContext.register(EndpointWebMvcChildContextConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class,\n\t\t\t\tEmbeddedServletContainerAutoConfiguration.class,\n\t\t\t\tDispatcherServletAutoConfiguration.class);\n\n\t\t// Ensure close on the parent also closes the child\n\t\tif (this.applicationContext instanceof ConfigurableApplicationContext) {\n\t\t\t((ConfigurableApplicationContext) this.applicationContext)\n\t\t\t\t\t.addApplicationListener(new ApplicationListener<ContextClosedEvent>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onApplicationEvent(ContextClosedEvent event) {\n\t\t\t\t\t\t\tif (event.getApplicationContext() == EndpointWebMvcAutoConfiguration.this.applicationContext) {\n\t\t\t\t\t\t\t\tchildContext.close();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t\ttry {\n\t\t\tchildContext.refresh();\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\t// No support currently for deploying a war with management.port=<different>,\n\t\t\t// and this is the signature of that happening\n\t\t\tif (e instanceof EmbeddedServletContainerException\n\t\t\t\t\t|| e.getCause() instanceof EmbeddedServletContainerException) {\n\t\t\t\tlogger.warn("Could not start embedded container (management endpoints are still available through JMX)");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected static enum ManagementServerPort {\n\n\t\tDISABLE, SAME, DIFFERENT;\n\n\t\tpublic static ManagementServerPort get(BeanFactory beanFactory) {\n\n\t\t\tServerProperties serverProperties;\n\t\t\ttry {\n\t\t\t\tserverProperties = beanFactory.getBean(ServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tserverProperties = new ServerProperties();\n\t\t\t}\n\n\t\t\tManagementServerProperties managementServerProperties;\n\t\t\ttry {\n\t\t\t\tmanagementServerProperties = beanFactory\n\t\t\t\t\t\t.getBean(ManagementServerProperties.class);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\tmanagementServerProperties = new ManagementServerProperties();\n\t\t\t}\n\n\t\t\tInteger port = managementServerProperties.getPort();\n\t\t\tif (port != null && port < 0) {\n\t\t\t\treturn DISABLE;\n\t\t\t}\n\t\t\tif (!(beanFactory instanceof WebApplicationContext)) {\n\t\t\t\t// Current context is not a webapp\n\t\t\t\treturn DIFFERENT;\n\t\t\t}\n\t\t\treturn ((port == null)\n\t\t\t\t\t|| (serverProperties.getPort() == null && port.equals(8080))\n\t\t\t\t\t|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME\n\t\t\t\t\t: DIFFERENT);\n\t\t}\n\t};\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
