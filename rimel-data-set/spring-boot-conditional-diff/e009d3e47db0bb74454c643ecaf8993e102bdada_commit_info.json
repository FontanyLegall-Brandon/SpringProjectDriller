{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/CrshAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/CrshAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -45,7 +45,7 @@ import org.crsh.vfs.spi.FSDriver;\n import org.springframework.beans.factory.ListableBeanFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.actuate.properties.ShellProperties;\n-import org.springframework.boot.actuate.properties.ShellProperties.AuthenticationProperties;\n+import org.springframework.boot.actuate.properties.ShellProperties.CrshShellProperties;\n import org.springframework.boot.actuate.properties.ShellProperties.JaasAuthenticationProperties;\n import org.springframework.boot.actuate.properties.ShellProperties.KeyAuthenticationProperties;\n import org.springframework.boot.actuate.properties.ShellProperties.SimpleAuthenticationProperties;\n@@ -110,29 +110,25 @@ public class CrshAutoConfiguration {\n \n \t@Bean\n \t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'jaas\'")\n-\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n-\tpublic AuthenticationProperties jaasAuthenticationProperties() {\n+\tpublic CrshShellProperties jaasAuthenticationProperties() {\n \t\treturn new JaasAuthenticationProperties();\n \t}\n \n \t@Bean\n \t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'key\'")\n-\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n-\tpublic AuthenticationProperties keyAuthenticationProperties() {\n+\tpublic CrshShellProperties keyAuthenticationProperties() {\n \t\treturn new KeyAuthenticationProperties();\n \t}\n \n \t@Bean\n \t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'simple\'")\n-\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n-\tpublic AuthenticationProperties simpleAuthenticationProperties() {\n+\tpublic CrshShellProperties simpleAuthenticationProperties() {\n \t\treturn new SimpleAuthenticationProperties();\n \t}\n \n \t@Bean\n \t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'spring\'")\n-\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n-\tpublic AuthenticationProperties SpringAuthenticationProperties() {\n+\tpublic CrshShellProperties SpringAuthenticationProperties() {\n \t\treturn new SpringAuthenticationProperties();\n \t}\n \n@@ -140,7 +136,7 @@ public class CrshAutoConfiguration {\n \t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n \tpublic PluginLifeCycle shellBootstrap() {\n \t\tCrshBootstrapBean bootstrapBean = new CrshBootstrapBean();\n-\t\tbootstrapBean.setConfig(this.properties.asCrashShellConfig());\n+\t\tbootstrapBean.setConfig(this.properties.asCrshShellConfig());\n \t\treturn bootstrapBean;\n \t}\n \n@@ -244,7 +240,7 @@ public class CrshAutoConfiguration {\n \t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username,\n \t\t\t\t\tpassword);\n \t\t\ttry {\n-\t\t\t\t// Authenticate first to make credentials are valid\n+\t\t\t\t// Authenticate first to make sure credentials are valid\n \t\t\t\ttoken = this.authenticationManager.authenticate(token);\n \t\t\t}\n \t\t\tcatch (AuthenticationException ex) {\n@@ -321,7 +317,7 @@ public class CrshAutoConfiguration {\n \t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n \n \t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n-\t\t\t\tif (!shouldFilter(p)) {\n+\t\t\t\tif (isEnabled(p)) {\n \t\t\t\t\tplugins.add(p);\n \t\t\t\t}\n \t\t\t}\n@@ -329,7 +325,7 @@ public class CrshAutoConfiguration {\n \t\t\tCollection<CRaSHPlugin> pluginBeans = this.beanFactory.getBeansOfType(\n \t\t\t\t\tCRaSHPlugin.class).values();\n \t\t\tfor (CRaSHPlugin<?> pluginBean : pluginBeans) {\n-\t\t\t\tif (!shouldFilter(pluginBean)) {\n+\t\t\t\tif (isEnabled(pluginBean)) {\n \t\t\t\t\tplugins.add(pluginBean);\n \t\t\t\t}\n \t\t\t}\n@@ -338,33 +334,33 @@ public class CrshAutoConfiguration {\n \t\t}\n \n \t\t@SuppressWarnings("rawtypes")\n-\t\tprotected boolean shouldFilter(CRaSHPlugin<?> plugin) {\n-\t\t\tAssert.notNull(plugin);\n+\t\tprotected boolean isEnabled(CRaSHPlugin<?> plugin) {\n+\t\t\tAssert.notNull(plugin, "Plugin must not be null");\n \n \t\t\tif (ObjectUtils.isEmpty(this.disabledPlugins)) {\n-\t\t\t\treturn false;\n+\t\t\t\treturn true;\n \t\t\t}\n \n \t\t\tSet<Class> pluginClasses = ClassUtils.getAllInterfacesAsSet(plugin);\n \t\t\tpluginClasses.add(plugin.getClass());\n \n \t\t\tfor (Class<?> pluginClass : pluginClasses) {\n-\t\t\t\tif (isDisabled(pluginClass)) {\n+\t\t\t\tif (isEnabled(pluginClass)) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn false;\n \t\t}\n \n-\t\tprivate boolean isDisabled(Class<?> pluginClass) {\n+\t\tprivate boolean isEnabled(Class<?> pluginClass) {\n \t\t\tfor (String disabledPlugin : this.disabledPlugins) {\n \t\t\t\tif (ClassUtils.getShortName(pluginClass).equalsIgnoreCase(disabledPlugin)\n \t\t\t\t\t\t|| ClassUtils.getQualifiedName(pluginClass).equalsIgnoreCase(\n \t\t\t\t\t\t\t\tdisabledPlugin)) {\n-\t\t\t\t\treturn true;\n+\t\t\t\t\treturn false;\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn false;\n+\t\t\treturn true;\n \t\t}\n \t}\n \n', 'source_code': '/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\nimport org.crsh.auth.AuthenticationPlugin;\nimport org.crsh.plugin.CRaSHPlugin;\nimport org.crsh.plugin.PluginContext;\nimport org.crsh.plugin.PluginDiscovery;\nimport org.crsh.plugin.PluginLifeCycle;\nimport org.crsh.plugin.PropertyDescriptor;\nimport org.crsh.plugin.ServiceLoaderDiscovery;\nimport org.crsh.vfs.FS;\nimport org.crsh.vfs.spi.AbstractFSDriver;\nimport org.crsh.vfs.spi.FSDriver;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.properties.ShellProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.CrshShellProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.JaasAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.KeyAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.SimpleAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.SpringAuthenticationProperties;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.SpringVersion;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.security.access.AccessDecisionManager;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell\n * into a Spring Boot enabled application. By default a SSH daemon is started on port 2000\n * with a default username <code>user</code> and password (default password is logged\n * during application startup).\n * \n * <p>\n * This configuration will auto detect the existence of a Spring Security\n * {@link AuthenticationManager} and will delegate authentication requests for shell\n * access to this detected instance.\n * \n * <p>\n * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in\n * the application context. Those beans will get auto detected during startup and\n * registered with the underlying shell infrastructure.\n * \n * <p>\n * Additional shell commands can be implemented using the guide and documentation at <a\n * href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands\n * using the following classpath scanning pattern <code>classpath*:/commands/**</code>. To\n * add different locations or override the default use\n * <code>shell.command_path_patterns</code> in your application configuration.\n * \n * @author Christian Dupuis\n */\n@Configuration\n@ConditionalOnClass({ PluginLifeCycle.class })\n@EnableConfigurationProperties({ ShellProperties.class })\n@AutoConfigureAfter(SecurityAutoConfiguration.class)\npublic class CrshAutoConfiguration {\n\n\t@Autowired\n\tprivate ShellProperties properties;\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'jaas\'")\n\tpublic CrshShellProperties jaasAuthenticationProperties() {\n\t\treturn new JaasAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'key\'")\n\tpublic CrshShellProperties keyAuthenticationProperties() {\n\t\treturn new KeyAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'simple\'")\n\tpublic CrshShellProperties simpleAuthenticationProperties() {\n\t\treturn new SimpleAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'spring\'")\n\tpublic CrshShellProperties SpringAuthenticationProperties() {\n\t\treturn new SpringAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n\tpublic PluginLifeCycle shellBootstrap() {\n\t\tCrshBootstrapBean bootstrapBean = new CrshBootstrapBean();\n\t\tbootstrapBean.setConfig(this.properties.asCrshShellConfig());\n\t\treturn bootstrapBean;\n\t}\n\n\t@Configuration\n\t@ConditionalOnBean({ AuthenticationManager.class })\n\tpublic static class ShellAuthenticationManager {\n\n\t\t@Bean\n\t\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n\t\t\treturn new AuthenticationManagerAdapter();\n\t\t}\n\n\t}\n\n\t/**\n\t * Spring Bean used to bootstrap the CRaSH shell.\n\t */\n\tpublic static class CrshBootstrapBean extends PluginLifeCycle {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t@Autowired\n\t\tprivate ShellProperties properties;\n\n\t\t@Autowired\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\t@PreDestroy\n\t\tpublic void destroy() {\n\t\t\tstop();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() throws Exception {\n\t\t\tFS commandFileSystem = createFileSystem(this.properties\n\t\t\t\t\t.getCommandPathPatterns());\n\t\t\tFS configurationFileSystem = createFileSystem(this.properties\n\t\t\t\t\t.getConfigPathPatterns());\n\n\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(\n\t\t\t\t\tthis.resourceLoader.getClassLoader(), this.beanFactory,\n\t\t\t\t\tthis.properties.getDisabledPlugins());\n\n\t\t\tPluginContext context = new PluginContext(discovery,\n\t\t\t\t\tcreatePluginContextAttributes(), commandFileSystem,\n\t\t\t\t\tconfigurationFileSystem, this.resourceLoader.getClassLoader());\n\n\t\t\tcontext.refresh();\n\t\t\tstart(context);\n\t\t}\n\n\t\tprotected FS createFileSystem(String[] pathPatterns) throws IOException,\n\t\t\t\tURISyntaxException {\n\t\t\tAssert.notNull(pathPatterns, "PathPatterns must not be null");\n\t\t\tFS fileSystem = new FS();\n\t\t\tfor (String pathPattern : pathPatterns) {\n\t\t\t\tfileSystem.mount(new SimpleFileSystemDriver(new DirectoryHandle(\n\t\t\t\t\t\tpathPattern, this.resourceLoader)));\n\t\t\t}\n\t\t\treturn fileSystem;\n\t\t}\n\n\t\tprotected Map<String, Object> createPluginContextAttributes() {\n\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage()\n\t\t\t\t\t.getImplementationVersion();\n\t\t\tif (bootVersion != null) {\n\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n\t\t\t}\n\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tattributes.put("spring.beanfactory", this.beanFactory);\n\t\t\t}\n\t\t\treturn attributes;\n\t\t}\n\n\t}\n\n\t/**\n\t * Adapts a Spring Security {@link AuthenticationManager} for use with CRaSH.\n\t */\n\t@SuppressWarnings("rawtypes")\n\tprivate static class AuthenticationManagerAdapter extends\n\t\t\tCRaSHPlugin<AuthenticationPlugin> implements AuthenticationPlugin<String> {\n\n\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor\n\t\t\t\t.create("auth.spring.roles", "ADMIN",\n\t\t\t\t\t\t"Comma separated list of roles required to access the shell");\n\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\n\t\t@Autowired(required = false)\n\t\tprivate AccessDecisionManager accessDecisionManager;\n\n\t\tprivate String[] roles = new String[] { "ROLE_ADMIN" };\n\n\t\t@Override\n\t\tpublic boolean authenticate(String username, String password) throws Exception {\n\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username,\n\t\t\t\t\tpassword);\n\t\t\ttry {\n\t\t\t\t// Authenticate first to make sure credentials are valid\n\t\t\t\ttoken = this.authenticationManager.authenticate(token);\n\t\t\t}\n\t\t\tcatch (AuthenticationException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n\t\t\tif (this.accessDecisionManager != null && token.isAuthenticated()\n\t\t\t\t\t&& this.roles != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.accessDecisionManager.decide(token, this,\n\t\t\t\t\t\t\tSecurityConfig.createList(this.roles));\n\t\t\t\t}\n\t\t\t\tcatch (AccessDeniedException ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn token.isAuthenticated();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<String> getCredentialType() {\n\t\t\treturn String.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic AuthenticationPlugin<String> getImplementation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn "spring";\n\t\t}\n\n\t\t@Override\n\t\tpublic void init() {\n\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n\t\t\tif (rolesPropertyValue != null) {\n\t\t\t\tthis.roles = StringUtils\n\t\t\t\t\t\t.commaDelimitedListToStringArray(rolesPropertyValue);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n\t\t\treturn Arrays.<PropertyDescriptor<?>> asList(ROLES);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ServiceLoaderDiscovery} to expose {@link CRaSHPlugin} Beans from Spring and\n\t * deal with filtering disabled plugins.\n\t */\n\tprivate static class BeanFactoryFilteringPluginDiscovery extends\n\t\t\tServiceLoaderDiscovery {\n\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate String[] disabledPlugins;\n\n\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader,\n\t\t\t\tListableBeanFactory beanFactory, String[] disabledPlugins)\n\t\t\t\tthrows NullPointerException {\n\t\t\tsuper(classLoader);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.disabledPlugins = disabledPlugins;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings("rawtypes")\n\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n\n\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n\t\t\t\tif (isEnabled(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollection<CRaSHPlugin> pluginBeans = this.beanFactory.getBeansOfType(\n\t\t\t\t\tCRaSHPlugin.class).values();\n\t\t\tfor (CRaSHPlugin<?> pluginBean : pluginBeans) {\n\t\t\t\tif (isEnabled(pluginBean)) {\n\t\t\t\t\tplugins.add(pluginBean);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn plugins;\n\t\t}\n\n\t\t@SuppressWarnings("rawtypes")\n\t\tprotected boolean isEnabled(CRaSHPlugin<?> plugin) {\n\t\t\tAssert.notNull(plugin, "Plugin must not be null");\n\n\t\t\tif (ObjectUtils.isEmpty(this.disabledPlugins)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tSet<Class> pluginClasses = ClassUtils.getAllInterfacesAsSet(plugin);\n\t\t\tpluginClasses.add(plugin.getClass());\n\n\t\t\tfor (Class<?> pluginClass : pluginClasses) {\n\t\t\t\tif (isEnabled(pluginClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean isEnabled(Class<?> pluginClass) {\n\t\t\tfor (String disabledPlugin : this.disabledPlugins) {\n\t\t\t\tif (ClassUtils.getShortName(pluginClass).equalsIgnoreCase(disabledPlugin)\n\t\t\t\t\t\t|| ClassUtils.getQualifiedName(pluginClass).equalsIgnoreCase(\n\t\t\t\t\t\t\t\tdisabledPlugin)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * {@link FSDriver} to expose Spring {@link Resource}s to CRaSH.\n\t */\n\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n\n\t\tprivate ResourceHandle root;\n\n\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n\t\t\tthis.root = handle;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle)\n\t\t\t\tthrows IOException {\n\t\t\tif (handle instanceof DirectoryHandle) {\n\t\t\t\treturn ((DirectoryHandle) handle).members();\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn ((FileHandle) handle).getLastModified();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n\t\t\treturn handle instanceof DirectoryHandle;\n\t\t}\n\n\t\t@Override\n\t\tpublic String name(ResourceHandle handle) throws IOException {\n\t\t\treturn handle.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream())\n\t\t\t\t\t\t.iterator();\n\t\t\t}\n\t\t\treturn Collections.<InputStream> emptyList().iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceHandle root() throws IOException {\n\t\t\treturn this.root;\n\t\t}\n\n\t}\n\n\t/**\n\t * Base for handles to Spring {@link Resource}s.\n\t */\n\tprivate abstract static class ResourceHandle {\n\n\t\tprivate String name;\n\n\t\tpublic ResourceHandle(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a directory.\n\t */\n\tprivate static class DirectoryHandle extends ResourceHandle {\n\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader) {\n\t\t\tsuper(name);\n\t\t\tthis.resourceLoader = resourceLoader;\n\t\t}\n\n\t\tpublic List<ResourceHandle> members() throws IOException {\n\t\t\tResource[] resources = this.resourceLoader.getResources(getName());\n\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (!resource.getURL().getPath().endsWith("/")) {\n\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn files;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a file.\n\t */\n\tprivate static class FileHandle extends ResourceHandle {\n\n\t\tprivate Resource resource;\n\n\t\tpublic FileHandle(String name, Resource resource) {\n\t\t\tsuper(name);\n\t\t\tthis.resource = resource;\n\t\t}\n\n\t\tpublic InputStream openStream() throws IOException {\n\t\t\treturn this.resource.getInputStream();\n\t\t}\n\n\t\tpublic long getLastModified() {\n\t\t\ttry {\n\t\t\t\treturn this.resource.lastModified();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\nimport org.crsh.auth.AuthenticationPlugin;\nimport org.crsh.plugin.CRaSHPlugin;\nimport org.crsh.plugin.PluginContext;\nimport org.crsh.plugin.PluginDiscovery;\nimport org.crsh.plugin.PluginLifeCycle;\nimport org.crsh.plugin.PropertyDescriptor;\nimport org.crsh.plugin.ServiceLoaderDiscovery;\nimport org.crsh.vfs.FS;\nimport org.crsh.vfs.spi.AbstractFSDriver;\nimport org.crsh.vfs.spi.FSDriver;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.properties.ShellProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.AuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.JaasAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.KeyAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.SimpleAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.ShellProperties.SpringAuthenticationProperties;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.SpringVersion;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.security.access.AccessDecisionManager;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell\n * into a Spring Boot enabled application. By default a SSH daemon is started on port 2000\n * with a default username <code>user</code> and password (default password is logged\n * during application startup).\n * \n * <p>\n * This configuration will auto detect the existence of a Spring Security\n * {@link AuthenticationManager} and will delegate authentication requests for shell\n * access to this detected instance.\n * \n * <p>\n * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in\n * the application context. Those beans will get auto detected during startup and\n * registered with the underlying shell infrastructure.\n * \n * <p>\n * Additional shell commands can be implemented using the guide and documentation at <a\n * href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands\n * using the following classpath scanning pattern <code>classpath*:/commands/**</code>. To\n * add different locations or override the default use\n * <code>shell.command_path_patterns</code> in your application configuration.\n * \n * @author Christian Dupuis\n */\n@Configuration\n@ConditionalOnClass({ PluginLifeCycle.class })\n@EnableConfigurationProperties({ ShellProperties.class })\n@AutoConfigureAfter(SecurityAutoConfiguration.class)\npublic class CrshAutoConfiguration {\n\n\t@Autowired\n\tprivate ShellProperties properties;\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'jaas\'")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties jaasAuthenticationProperties() {\n\t\treturn new JaasAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'key\'")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties keyAuthenticationProperties() {\n\t\treturn new KeyAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'simple\'")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties simpleAuthenticationProperties() {\n\t\treturn new SimpleAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("\'${shell.auth:simple}\' == \'spring\'")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties SpringAuthenticationProperties() {\n\t\treturn new SpringAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n\tpublic PluginLifeCycle shellBootstrap() {\n\t\tCrshBootstrapBean bootstrapBean = new CrshBootstrapBean();\n\t\tbootstrapBean.setConfig(this.properties.asCrashShellConfig());\n\t\treturn bootstrapBean;\n\t}\n\n\t@Configuration\n\t@ConditionalOnBean({ AuthenticationManager.class })\n\tpublic static class ShellAuthenticationManager {\n\n\t\t@Bean\n\t\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n\t\t\treturn new AuthenticationManagerAdapter();\n\t\t}\n\n\t}\n\n\t/**\n\t * Spring Bean used to bootstrap the CRaSH shell.\n\t */\n\tpublic static class CrshBootstrapBean extends PluginLifeCycle {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t@Autowired\n\t\tprivate ShellProperties properties;\n\n\t\t@Autowired\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\t@PreDestroy\n\t\tpublic void destroy() {\n\t\t\tstop();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() throws Exception {\n\t\t\tFS commandFileSystem = createFileSystem(this.properties\n\t\t\t\t\t.getCommandPathPatterns());\n\t\t\tFS configurationFileSystem = createFileSystem(this.properties\n\t\t\t\t\t.getConfigPathPatterns());\n\n\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(\n\t\t\t\t\tthis.resourceLoader.getClassLoader(), this.beanFactory,\n\t\t\t\t\tthis.properties.getDisabledPlugins());\n\n\t\t\tPluginContext context = new PluginContext(discovery,\n\t\t\t\t\tcreatePluginContextAttributes(), commandFileSystem,\n\t\t\t\t\tconfigurationFileSystem, this.resourceLoader.getClassLoader());\n\n\t\t\tcontext.refresh();\n\t\t\tstart(context);\n\t\t}\n\n\t\tprotected FS createFileSystem(String[] pathPatterns) throws IOException,\n\t\t\t\tURISyntaxException {\n\t\t\tAssert.notNull(pathPatterns, "PathPatterns must not be null");\n\t\t\tFS fileSystem = new FS();\n\t\t\tfor (String pathPattern : pathPatterns) {\n\t\t\t\tfileSystem.mount(new SimpleFileSystemDriver(new DirectoryHandle(\n\t\t\t\t\t\tpathPattern, this.resourceLoader)));\n\t\t\t}\n\t\t\treturn fileSystem;\n\t\t}\n\n\t\tprotected Map<String, Object> createPluginContextAttributes() {\n\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage()\n\t\t\t\t\t.getImplementationVersion();\n\t\t\tif (bootVersion != null) {\n\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n\t\t\t}\n\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n\t\t\tif (this.beanFactory != null) {\n\t\t\t\tattributes.put("spring.beanfactory", this.beanFactory);\n\t\t\t}\n\t\t\treturn attributes;\n\t\t}\n\n\t}\n\n\t/**\n\t * Adapts a Spring Security {@link AuthenticationManager} for use with CRaSH.\n\t */\n\t@SuppressWarnings("rawtypes")\n\tprivate static class AuthenticationManagerAdapter extends\n\t\t\tCRaSHPlugin<AuthenticationPlugin> implements AuthenticationPlugin<String> {\n\n\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor\n\t\t\t\t.create("auth.spring.roles", "ADMIN",\n\t\t\t\t\t\t"Comma separated list of roles required to access the shell");\n\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\n\t\t@Autowired(required = false)\n\t\tprivate AccessDecisionManager accessDecisionManager;\n\n\t\tprivate String[] roles = new String[] { "ROLE_ADMIN" };\n\n\t\t@Override\n\t\tpublic boolean authenticate(String username, String password) throws Exception {\n\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username,\n\t\t\t\t\tpassword);\n\t\t\ttry {\n\t\t\t\t// Authenticate first to make credentials are valid\n\t\t\t\ttoken = this.authenticationManager.authenticate(token);\n\t\t\t}\n\t\t\tcatch (AuthenticationException ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n\t\t\tif (this.accessDecisionManager != null && token.isAuthenticated()\n\t\t\t\t\t&& this.roles != null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.accessDecisionManager.decide(token, this,\n\t\t\t\t\t\t\tSecurityConfig.createList(this.roles));\n\t\t\t\t}\n\t\t\t\tcatch (AccessDeniedException ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn token.isAuthenticated();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<String> getCredentialType() {\n\t\t\treturn String.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic AuthenticationPlugin<String> getImplementation() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn "spring";\n\t\t}\n\n\t\t@Override\n\t\tpublic void init() {\n\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n\t\t\tif (rolesPropertyValue != null) {\n\t\t\t\tthis.roles = StringUtils\n\t\t\t\t\t\t.commaDelimitedListToStringArray(rolesPropertyValue);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n\t\t\treturn Arrays.<PropertyDescriptor<?>> asList(ROLES);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ServiceLoaderDiscovery} to expose {@link CRaSHPlugin} Beans from Spring and\n\t * deal with filtering disabled plugins.\n\t */\n\tprivate static class BeanFactoryFilteringPluginDiscovery extends\n\t\t\tServiceLoaderDiscovery {\n\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate String[] disabledPlugins;\n\n\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader,\n\t\t\t\tListableBeanFactory beanFactory, String[] disabledPlugins)\n\t\t\t\tthrows NullPointerException {\n\t\t\tsuper(classLoader);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.disabledPlugins = disabledPlugins;\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings("rawtypes")\n\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n\n\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n\t\t\t\tif (!shouldFilter(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollection<CRaSHPlugin> pluginBeans = this.beanFactory.getBeansOfType(\n\t\t\t\t\tCRaSHPlugin.class).values();\n\t\t\tfor (CRaSHPlugin<?> pluginBean : pluginBeans) {\n\t\t\t\tif (!shouldFilter(pluginBean)) {\n\t\t\t\t\tplugins.add(pluginBean);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn plugins;\n\t\t}\n\n\t\t@SuppressWarnings("rawtypes")\n\t\tprotected boolean shouldFilter(CRaSHPlugin<?> plugin) {\n\t\t\tAssert.notNull(plugin);\n\n\t\t\tif (ObjectUtils.isEmpty(this.disabledPlugins)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSet<Class> pluginClasses = ClassUtils.getAllInterfacesAsSet(plugin);\n\t\t\tpluginClasses.add(plugin.getClass());\n\n\t\t\tfor (Class<?> pluginClass : pluginClasses) {\n\t\t\t\tif (isDisabled(pluginClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate boolean isDisabled(Class<?> pluginClass) {\n\t\t\tfor (String disabledPlugin : this.disabledPlugins) {\n\t\t\t\tif (ClassUtils.getShortName(pluginClass).equalsIgnoreCase(disabledPlugin)\n\t\t\t\t\t\t|| ClassUtils.getQualifiedName(pluginClass).equalsIgnoreCase(\n\t\t\t\t\t\t\t\tdisabledPlugin)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * {@link FSDriver} to expose Spring {@link Resource}s to CRaSH.\n\t */\n\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n\n\t\tprivate ResourceHandle root;\n\n\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n\t\t\tthis.root = handle;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle)\n\t\t\t\tthrows IOException {\n\t\t\tif (handle instanceof DirectoryHandle) {\n\t\t\t\treturn ((DirectoryHandle) handle).members();\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn ((FileHandle) handle).getLastModified();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n\t\t\treturn handle instanceof DirectoryHandle;\n\t\t}\n\n\t\t@Override\n\t\tpublic String name(ResourceHandle handle) throws IOException {\n\t\t\treturn handle.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream())\n\t\t\t\t\t\t.iterator();\n\t\t\t}\n\t\t\treturn Collections.<InputStream> emptyList().iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceHandle root() throws IOException {\n\t\t\treturn this.root;\n\t\t}\n\n\t}\n\n\t/**\n\t * Base for handles to Spring {@link Resource}s.\n\t */\n\tprivate abstract static class ResourceHandle {\n\n\t\tprivate String name;\n\n\t\tpublic ResourceHandle(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn this.name;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a directory.\n\t */\n\tprivate static class DirectoryHandle extends ResourceHandle {\n\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader) {\n\t\t\tsuper(name);\n\t\t\tthis.resourceLoader = resourceLoader;\n\t\t}\n\n\t\tpublic List<ResourceHandle> members() throws IOException {\n\t\t\tResource[] resources = this.resourceLoader.getResources(getName());\n\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (!resource.getURL().getPath().endsWith("/")) {\n\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn files;\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ResourceHandle} for a file.\n\t */\n\tprivate static class FileHandle extends ResourceHandle {\n\n\t\tprivate Resource resource;\n\n\t\tpublic FileHandle(String name, Resource resource) {\n\t\t\tsuper(name);\n\t\t\tthis.resource = resource;\n\t\t}\n\n\t\tpublic InputStream openStream() throws IOException {\n\t\t\treturn this.resource.getInputStream();\n\t\t}\n\n\t\tpublic long getLastModified() {\n\t\t\ttry {\n\t\t\t\treturn this.resource.lastModified();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
