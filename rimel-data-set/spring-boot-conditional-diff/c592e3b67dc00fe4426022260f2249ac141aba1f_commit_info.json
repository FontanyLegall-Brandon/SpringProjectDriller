{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/AuthenticationManagerConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/AuthenticationManagerConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -16,7 +16,6 @@\n \n package org.springframework.boot.autoconfigure.security;\n \n-import java.lang.reflect.Field;\n import java.util.UUID;\n \n import org.apache.commons.logging.Log;\n@@ -31,30 +30,21 @@ import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationListener;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n-import org.springframework.context.annotation.Primary;\n-import org.springframework.core.Ordered;\n import org.springframework.core.annotation.Order;\n import org.springframework.security.authentication.AuthenticationEventPublisher;\n import org.springframework.security.authentication.AuthenticationManager;\n import org.springframework.security.authentication.AuthenticationProvider;\n import org.springframework.security.authentication.ProviderManager;\n import org.springframework.security.config.annotation.ObjectPostProcessor;\n-import org.springframework.security.config.annotation.SecurityConfigurer;\n-import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n-import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\n-import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\n-import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;\n+import org.springframework.security.core.userdetails.User;\n import org.springframework.security.core.userdetails.UserDetailsService;\n-import org.springframework.util.ReflectionUtils;\n+import org.springframework.security.provisioning.InMemoryUserDetailsManager;\n \n /**\n- * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be\n- * disabled by providing a bean of type {@link AuthenticationManager},\n- * {@link AuthenticationProvider} or {@link UserDetailsService}. The value provided by\n- * this configuration will become the "global" authentication manager (from Spring\n- * Security), or the parent of the global instance. Thus it acts as a fallback when no\n- * others are provided, is used by method security if enabled, and as a parent\n- * authentication manager for "local" authentication managers in individual filter chains.\n+ * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Adds an\n+ * {@link InMemoryUserDetailsManager} with a default user and generated password.\n+ * This can be disabled by providing a bean of type {@link AuthenticationManager},\n+ * {@link AuthenticationProvider} or {@link UserDetailsService}.\n  *\n  * @author Dave Syer\n  * @author Rob Winch\n@@ -62,8 +52,6 @@ import org.springframework.util.ReflectionUtils;\n  */\n @Configuration\n @ConditionalOnBean(ObjectPostProcessor.class)\n-@ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class,\n-\t\tUserDetailsService.class })\n @Order(0)\n public class AuthenticationManagerConfiguration {\n \n@@ -71,15 +59,13 @@ public class AuthenticationManagerConfiguration {\n \t\t\t.getLog(AuthenticationManagerConfiguration.class);\n \n \t@Bean\n-\t@Primary\n-\tpublic AuthenticationManager authenticationManager(\n-\t\t\tAuthenticationConfiguration configuration) throws Exception {\n-\t\treturn configuration.getAuthenticationManager();\n-\t}\n-\n-\t@Bean\n-\tpublic static SpringBootAuthenticationConfigurerAdapter springBootAuthenticationConfigurerAdapter() {\n-\t\treturn new SpringBootAuthenticationConfigurerAdapter();\n+\t@ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class,\n+\t\t\tUserDetailsService.class })\n+\tpublic InMemoryUserDetailsManager inMemoryUserDetailsManager() throws Exception {\n+\t\tString password = UUID.randomUUID().toString();\n+\t\tlogger.info(\n+\t\t\t\tString.format("%n%nUsing default security password: %s%n", password));\n+\t\treturn new InMemoryUserDetailsManager(User.withUsername("user").password(password).roles().build());\n \t}\n \n \t@Bean\n@@ -87,91 +73,6 @@ public class AuthenticationManagerConfiguration {\n \t\treturn new AuthenticationManagerConfigurationListener();\n \t}\n \n-\t/**\n-\t * {@link GlobalAuthenticationConfigurerAdapter} to apply\n-\t * {@link DefaultInMemoryUserDetailsManagerConfigurer}. We must apply\n-\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} in the init phase of the last\n-\t * {@link GlobalAuthenticationConfigurerAdapter}. The reason is that the typical flow\n-\t * is something like:\n-\t *\n-\t * <ul>\n-\t * <li>A\n-\t * {@link GlobalAuthenticationConfigurerAdapter#init(AuthenticationManagerBuilder)}\n-\t * exists that adds a {@link SecurityConfigurer} to the\n-\t * {@link AuthenticationManagerBuilder}.</li>\n-\t * <li>{@link AuthenticationManagerConfiguration} adds\n-\t * {@link SpringBootAuthenticationConfigurerAdapter} so it is after the\n-\t * {@link SecurityConfigurer} in the first step.</li>\n-\t * <li>We then can default an {@link AuthenticationProvider} if necessary. Note we can\n-\t * only invoke the\n-\t * {@link AuthenticationManagerBuilder#authenticationProvider(AuthenticationProvider)}\n-\t * method since all other methods add a {@link SecurityConfigurer} which is not\n-\t * allowed in the configure stage. It is not allowed because we guarantee all init\n-\t * methods are invoked before configure, which cannot be guaranteed at this point.\n-\t * </li>\n-\t * </ul>\n-\t */\n-\t@Order(Ordered.LOWEST_PRECEDENCE - 100)\n-\tprivate static class SpringBootAuthenticationConfigurerAdapter\n-\t\t\textends GlobalAuthenticationConfigurerAdapter {\n-\n-\t\t@Override\n-\t\tpublic void init(AuthenticationManagerBuilder auth) throws Exception {\n-\t\t\tauth.apply(new DefaultInMemoryUserDetailsManagerConfigurer());\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * {@link InMemoryUserDetailsManagerConfigurer} to add user details from\n-\t * {@link SecurityProperties}. This is necessary to delay adding the default user.\n-\t *\n-\t * <ul>\n-\t * <li>A {@link GlobalAuthenticationConfigurerAdapter} will initialize the\n-\t * {@link AuthenticationManagerBuilder} with a Configurer which will be after any\n-\t * {@link GlobalAuthenticationConfigurerAdapter}.</li>\n-\t * <li>{@link SpringBootAuthenticationConfigurerAdapter} will be invoked after all\n-\t * {@link GlobalAuthenticationConfigurerAdapter}, but before the Configurers that were\n-\t * added by other {@link GlobalAuthenticationConfigurerAdapter} instances.</li>\n-\t * <li>A {@link SpringBootAuthenticationConfigurerAdapter} will add\n-\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} after all Configurer instances.\n-\t * </li>\n-\t * <li>All init methods will be invoked.</li>\n-\t * <li>All configure methods will be invoked which is where the\n-\t * {@link AuthenticationProvider} instances are setup.</li>\n-\t * <li>If no AuthenticationProviders were provided,\n-\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} will default the value.</li>\n-\t * </ul>\n-\t */\n-\tprivate static class DefaultInMemoryUserDetailsManagerConfigurer\n-\t\t\textends InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> {\n-\n-\t\t@Override\n-\t\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n-\t\t\tif (auth.isConfigured()) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tString password = UUID.randomUUID().toString();\n-\t\t\tlogger.info(\n-\t\t\t\t\tString.format("%n%nUsing default security password: %s%n", password));\n-\t\t\twithUser("user").password(password).roles();\n-\t\t\tsetField(auth, "defaultUserDetailsService", getUserDetailsService());\n-\t\t\tsuper.configure(auth);\n-\t\t}\n-\n-\t\tprivate void setField(Object target, String name, Object value) {\n-\t\t\ttry {\n-\t\t\t\tField field = ReflectionUtils.findField(target.getClass(), name);\n-\t\t\t\tReflectionUtils.makeAccessible(field);\n-\t\t\t\tReflectionUtils.setField(field, target, value);\n-\t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\tlogger.info("Could not set " + name);\n-\t\t\t}\n-\t\t}\n-\n-\t}\n-\n \t/**\n \t * {@link ApplicationListener} to autowire the {@link AuthenticationEventPublisher}\n \t * into the {@link AuthenticationManager}.\n', 'source_code': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security;\n\nimport java.util.UUID;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.ObjectPostProcessor;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.provisioning.InMemoryUserDetailsManager;\n\n/**\n * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Adds an\n * {@link InMemoryUserDetailsManager} with a default user and generated password.\n * This can be disabled by providing a bean of type {@link AuthenticationManager},\n * {@link AuthenticationProvider} or {@link UserDetailsService}.\n *\n * @author Dave Syer\n * @author Rob Winch\n * @author Madhura Bhave\n */\n@Configuration\n@ConditionalOnBean(ObjectPostProcessor.class)\n@Order(0)\npublic class AuthenticationManagerConfiguration {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t@Bean\n\t@ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class,\n\t\t\tUserDetailsService.class })\n\tpublic InMemoryUserDetailsManager inMemoryUserDetailsManager() throws Exception {\n\t\tString password = UUID.randomUUID().toString();\n\t\tlogger.info(\n\t\t\t\tString.format("%n%nUsing default security password: %s%n", password));\n\t\treturn new InMemoryUserDetailsManager(User.withUsername("user").password(password).roles().build());\n\t}\n\n\t@Bean\n\tpublic AuthenticationManagerConfigurationListener authenticationManagerConfigurationListener() {\n\t\treturn new AuthenticationManagerConfigurationListener();\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to autowire the {@link AuthenticationEventPublisher}\n\t * into the {@link AuthenticationManager}.\n\t */\n\tprotected static class AuthenticationManagerConfigurationListener\n\t\t\timplements SmartInitializingSingleton {\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher eventPublisher;\n\n\t\t@Autowired\n\t\tprivate ApplicationContext context;\n\n\t\t@Override\n\t\tpublic void afterSingletonsInstantiated() {\n\t\t\ttry {\n\t\t\t\tconfigureAuthenticationManager(\n\t\t\t\t\t\tthis.context.getBean(AuthenticationManager.class));\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureAuthenticationManager(AuthenticationManager manager) {\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.eventPublisher);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security;\n\nimport java.lang.reflect.Field;\nimport java.util.UUID;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.NoSuchBeanDefinitionException;\nimport org.springframework.beans.factory.SmartInitializingSingleton;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.ObjectPostProcessor;\nimport org.springframework.security.config.annotation.SecurityConfigurer;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be\n * disabled by providing a bean of type {@link AuthenticationManager},\n * {@link AuthenticationProvider} or {@link UserDetailsService}. The value provided by\n * this configuration will become the "global" authentication manager (from Spring\n * Security), or the parent of the global instance. Thus it acts as a fallback when no\n * others are provided, is used by method security if enabled, and as a parent\n * authentication manager for "local" authentication managers in individual filter chains.\n *\n * @author Dave Syer\n * @author Rob Winch\n * @author Madhura Bhave\n */\n@Configuration\n@ConditionalOnBean(ObjectPostProcessor.class)\n@ConditionalOnMissingBean({ AuthenticationManager.class, AuthenticationProvider.class,\n\t\tUserDetailsService.class })\n@Order(0)\npublic class AuthenticationManagerConfiguration {\n\n\tprivate static final Log logger = LogFactory\n\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t@Bean\n\t@Primary\n\tpublic AuthenticationManager authenticationManager(\n\t\t\tAuthenticationConfiguration configuration) throws Exception {\n\t\treturn configuration.getAuthenticationManager();\n\t}\n\n\t@Bean\n\tpublic static SpringBootAuthenticationConfigurerAdapter springBootAuthenticationConfigurerAdapter() {\n\t\treturn new SpringBootAuthenticationConfigurerAdapter();\n\t}\n\n\t@Bean\n\tpublic AuthenticationManagerConfigurationListener authenticationManagerConfigurationListener() {\n\t\treturn new AuthenticationManagerConfigurationListener();\n\t}\n\n\t/**\n\t * {@link GlobalAuthenticationConfigurerAdapter} to apply\n\t * {@link DefaultInMemoryUserDetailsManagerConfigurer}. We must apply\n\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} in the init phase of the last\n\t * {@link GlobalAuthenticationConfigurerAdapter}. The reason is that the typical flow\n\t * is something like:\n\t *\n\t * <ul>\n\t * <li>A\n\t * {@link GlobalAuthenticationConfigurerAdapter#init(AuthenticationManagerBuilder)}\n\t * exists that adds a {@link SecurityConfigurer} to the\n\t * {@link AuthenticationManagerBuilder}.</li>\n\t * <li>{@link AuthenticationManagerConfiguration} adds\n\t * {@link SpringBootAuthenticationConfigurerAdapter} so it is after the\n\t * {@link SecurityConfigurer} in the first step.</li>\n\t * <li>We then can default an {@link AuthenticationProvider} if necessary. Note we can\n\t * only invoke the\n\t * {@link AuthenticationManagerBuilder#authenticationProvider(AuthenticationProvider)}\n\t * method since all other methods add a {@link SecurityConfigurer} which is not\n\t * allowed in the configure stage. It is not allowed because we guarantee all init\n\t * methods are invoked before configure, which cannot be guaranteed at this point.\n\t * </li>\n\t * </ul>\n\t */\n\t@Order(Ordered.LOWEST_PRECEDENCE - 100)\n\tprivate static class SpringBootAuthenticationConfigurerAdapter\n\t\t\textends GlobalAuthenticationConfigurerAdapter {\n\n\t\t@Override\n\t\tpublic void init(AuthenticationManagerBuilder auth) throws Exception {\n\t\t\tauth.apply(new DefaultInMemoryUserDetailsManagerConfigurer());\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link InMemoryUserDetailsManagerConfigurer} to add user details from\n\t * {@link SecurityProperties}. This is necessary to delay adding the default user.\n\t *\n\t * <ul>\n\t * <li>A {@link GlobalAuthenticationConfigurerAdapter} will initialize the\n\t * {@link AuthenticationManagerBuilder} with a Configurer which will be after any\n\t * {@link GlobalAuthenticationConfigurerAdapter}.</li>\n\t * <li>{@link SpringBootAuthenticationConfigurerAdapter} will be invoked after all\n\t * {@link GlobalAuthenticationConfigurerAdapter}, but before the Configurers that were\n\t * added by other {@link GlobalAuthenticationConfigurerAdapter} instances.</li>\n\t * <li>A {@link SpringBootAuthenticationConfigurerAdapter} will add\n\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} after all Configurer instances.\n\t * </li>\n\t * <li>All init methods will be invoked.</li>\n\t * <li>All configure methods will be invoked which is where the\n\t * {@link AuthenticationProvider} instances are setup.</li>\n\t * <li>If no AuthenticationProviders were provided,\n\t * {@link DefaultInMemoryUserDetailsManagerConfigurer} will default the value.</li>\n\t * </ul>\n\t */\n\tprivate static class DefaultInMemoryUserDetailsManagerConfigurer\n\t\t\textends InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> {\n\n\t\t@Override\n\t\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n\t\t\tif (auth.isConfigured()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tString password = UUID.randomUUID().toString();\n\t\t\tlogger.info(\n\t\t\t\t\tString.format("%n%nUsing default security password: %s%n", password));\n\t\t\twithUser("user").password(password).roles();\n\t\t\tsetField(auth, "defaultUserDetailsService", getUserDetailsService());\n\t\t\tsuper.configure(auth);\n\t\t}\n\n\t\tprivate void setField(Object target, String name, Object value) {\n\t\t\ttry {\n\t\t\t\tField field = ReflectionUtils.findField(target.getClass(), name);\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tReflectionUtils.setField(field, target, value);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlogger.info("Could not set " + name);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ApplicationListener} to autowire the {@link AuthenticationEventPublisher}\n\t * into the {@link AuthenticationManager}.\n\t */\n\tprotected static class AuthenticationManagerConfigurationListener\n\t\t\timplements SmartInitializingSingleton {\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher eventPublisher;\n\n\t\t@Autowired\n\t\tprivate ApplicationContext context;\n\n\t\t@Override\n\t\tpublic void afterSingletonsInstantiated() {\n\t\t\ttry {\n\t\t\t\tconfigureAuthenticationManager(\n\t\t\t\t\t\tthis.context.getBean(AuthenticationManager.class));\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tprivate void configureAuthenticationManager(AuthenticationManager manager) {\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.eventPublisher);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
