{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/HazelcastInstanceConfiguration.java'), '_new_path': None, 'change_type': <ModificationType.DELETE: 4>, 'diff': '@@ -1,135 +0,0 @@\n-/*\n- * Copyright 2012-2016 the original author or authors.\n- *\n- * Licensed under the Apache License, Version 2.0 (the "License");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an "AS IS" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.springframework.boot.autoconfigure.cache;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-\n-import com.hazelcast.core.Hazelcast;\n-import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.spring.cache.HazelcastCacheManager;\n-\n-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n-import org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;\n-import org.springframework.boot.autoconfigure.hazelcast.HazelcastConfigResourceCondition;\n-import org.springframework.boot.autoconfigure.hazelcast.HazelcastInstanceFactory;\n-import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.Conditional;\n-import org.springframework.context.annotation.Configuration;\n-import org.springframework.core.io.Resource;\n-\n-/**\n- * Actual {@link HazelcastInstance} configurations imported by\n- * {@link HazelcastCacheConfiguration}.\n- *\n- * @author Stephane Nicoll\n- */\n-abstract class HazelcastInstanceConfiguration {\n-\n-\t@Configuration\n-\t@ConditionalOnSingleCandidate(HazelcastInstance.class)\n-\tstatic class Existing {\n-\n-\t\tprivate final CacheProperties cacheProperties;\n-\n-\t\tprivate final CacheManagerCustomizers customizers;\n-\n-\t\tExisting(CacheProperties cacheProperties, CacheManagerCustomizers customizers) {\n-\t\t\tthis.cacheProperties = cacheProperties;\n-\t\t\tthis.customizers = customizers;\n-\t\t}\n-\n-\t\t@Bean\n-\t\tpublic HazelcastCacheManager cacheManager(\n-\t\t\t\tHazelcastInstance existingHazelcastInstance) throws IOException {\n-\t\t\tResource config = this.cacheProperties.getHazelcast().getConfig();\n-\t\t\tResource location = this.cacheProperties.resolveConfigLocation(config);\n-\t\t\tif (location != null) {\n-\t\t\t\tHazelcastInstance cacheHazelcastInstance = new HazelcastInstanceFactory(\n-\t\t\t\t\t\tlocation).getHazelcastInstance();\n-\t\t\t\treturn new CloseableHazelcastCacheManager(cacheHazelcastInstance);\n-\t\t\t}\n-\t\t\tHazelcastCacheManager cacheManager = new HazelcastCacheManager(\n-\t\t\t\t\texistingHazelcastInstance);\n-\t\t\treturn this.customizers.customize(cacheManager);\n-\t\t}\n-\n-\t}\n-\n-\t@Configuration\n-\t@ConditionalOnMissingBean(HazelcastInstance.class)\n-\t@Conditional(ConfigAvailableCondition.class)\n-\tstatic class Specific {\n-\n-\t\tprivate final CacheProperties cacheProperties;\n-\n-\t\tprivate final CacheManagerCustomizers customizers;\n-\n-\t\tSpecific(CacheProperties cacheProperties, CacheManagerCustomizers customizers) {\n-\t\t\tthis.cacheProperties = cacheProperties;\n-\t\t\tthis.customizers = customizers;\n-\t\t}\n-\n-\t\t@Bean\n-\t\tpublic HazelcastInstance hazelcastInstance() throws IOException {\n-\t\t\tResource config = this.cacheProperties.getHazelcast().getConfig();\n-\t\t\tResource location = this.cacheProperties.resolveConfigLocation(config);\n-\t\t\tif (location != null) {\n-\t\t\t\treturn new HazelcastInstanceFactory(location).getHazelcastInstance();\n-\t\t\t}\n-\t\t\treturn Hazelcast.newHazelcastInstance();\n-\t\t}\n-\n-\t\t@Bean\n-\t\tpublic HazelcastCacheManager cacheManager() throws IOException {\n-\t\t\tHazelcastCacheManager cacheManager = new HazelcastCacheManager(\n-\t\t\t\t\thazelcastInstance());\n-\t\t\treturn this.customizers.customize(cacheManager);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * {@link HazelcastConfigResourceCondition} that checks if the\n-\t * {@code spring.cache.hazelcast.config} configuration key is defined.\n-\t */\n-\tstatic class ConfigAvailableCondition extends HazelcastConfigResourceCondition {\n-\n-\t\tConfigAvailableCondition() {\n-\t\t\tsuper("spring.cache.hazelcast", "config");\n-\t\t}\n-\n-\t}\n-\n-\tprivate static class CloseableHazelcastCacheManager extends HazelcastCacheManager\n-\t\t\timplements Closeable {\n-\n-\t\tprivate final HazelcastInstance hazelcastInstance;\n-\n-\t\tCloseableHazelcastCacheManager(HazelcastInstance hazelcastInstance) {\n-\t\t\tsuper(hazelcastInstance);\n-\t\t\tthis.hazelcastInstance = hazelcastInstance;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void close() throws IOException {\n-\t\t\tthis.hazelcastInstance.shutdown();\n-\t\t}\n-\n-\t}\n-\n-}\n', 'source_code': None, 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.cache;\n\nimport java.io.Closeable;\nimport java.io.IOException;\n\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.spring.cache.HazelcastCacheManager;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;\nimport org.springframework.boot.autoconfigure.hazelcast.HazelcastConfigResourceCondition;\nimport org.springframework.boot.autoconfigure.hazelcast.HazelcastInstanceFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.Resource;\n\n/**\n * Actual {@link HazelcastInstance} configurations imported by\n * {@link HazelcastCacheConfiguration}.\n *\n * @author Stephane Nicoll\n */\nabstract class HazelcastInstanceConfiguration {\n\n\t@Configuration\n\t@ConditionalOnSingleCandidate(HazelcastInstance.class)\n\tstatic class Existing {\n\n\t\tprivate final CacheProperties cacheProperties;\n\n\t\tprivate final CacheManagerCustomizers customizers;\n\n\t\tExisting(CacheProperties cacheProperties, CacheManagerCustomizers customizers) {\n\t\t\tthis.cacheProperties = cacheProperties;\n\t\t\tthis.customizers = customizers;\n\t\t}\n\n\t\t@Bean\n\t\tpublic HazelcastCacheManager cacheManager(\n\t\t\t\tHazelcastInstance existingHazelcastInstance) throws IOException {\n\t\t\tResource config = this.cacheProperties.getHazelcast().getConfig();\n\t\t\tResource location = this.cacheProperties.resolveConfigLocation(config);\n\t\t\tif (location != null) {\n\t\t\t\tHazelcastInstance cacheHazelcastInstance = new HazelcastInstanceFactory(\n\t\t\t\t\t\tlocation).getHazelcastInstance();\n\t\t\t\treturn new CloseableHazelcastCacheManager(cacheHazelcastInstance);\n\t\t\t}\n\t\t\tHazelcastCacheManager cacheManager = new HazelcastCacheManager(\n\t\t\t\t\texistingHazelcastInstance);\n\t\t\treturn this.customizers.customize(cacheManager);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(HazelcastInstance.class)\n\t@Conditional(ConfigAvailableCondition.class)\n\tstatic class Specific {\n\n\t\tprivate final CacheProperties cacheProperties;\n\n\t\tprivate final CacheManagerCustomizers customizers;\n\n\t\tSpecific(CacheProperties cacheProperties, CacheManagerCustomizers customizers) {\n\t\t\tthis.cacheProperties = cacheProperties;\n\t\t\tthis.customizers = customizers;\n\t\t}\n\n\t\t@Bean\n\t\tpublic HazelcastInstance hazelcastInstance() throws IOException {\n\t\t\tResource config = this.cacheProperties.getHazelcast().getConfig();\n\t\t\tResource location = this.cacheProperties.resolveConfigLocation(config);\n\t\t\tif (location != null) {\n\t\t\t\treturn new HazelcastInstanceFactory(location).getHazelcastInstance();\n\t\t\t}\n\t\t\treturn Hazelcast.newHazelcastInstance();\n\t\t}\n\n\t\t@Bean\n\t\tpublic HazelcastCacheManager cacheManager() throws IOException {\n\t\t\tHazelcastCacheManager cacheManager = new HazelcastCacheManager(\n\t\t\t\t\thazelcastInstance());\n\t\t\treturn this.customizers.customize(cacheManager);\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link HazelcastConfigResourceCondition} that checks if the\n\t * {@code spring.cache.hazelcast.config} configuration key is defined.\n\t */\n\tstatic class ConfigAvailableCondition extends HazelcastConfigResourceCondition {\n\n\t\tConfigAvailableCondition() {\n\t\t\tsuper("spring.cache.hazelcast", "config");\n\t\t}\n\n\t}\n\n\tprivate static class CloseableHazelcastCacheManager extends HazelcastCacheManager\n\t\t\timplements Closeable {\n\n\t\tprivate final HazelcastInstance hazelcastInstance;\n\n\t\tCloseableHazelcastCacheManager(HazelcastInstance hazelcastInstance) {\n\t\t\tsuper(hazelcastInstance);\n\t\t\tthis.hazelcastInstance = hazelcastInstance;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() throws IOException {\n\t\t\tthis.hazelcastInstance.shutdown();\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
