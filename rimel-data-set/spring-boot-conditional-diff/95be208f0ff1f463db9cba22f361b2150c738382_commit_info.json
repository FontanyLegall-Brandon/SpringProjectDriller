{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/ManagementWebSecurityAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/ManagementWebSecurityAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -26,7 +26,6 @@ import javax.annotation.PostConstruct;\n import javax.servlet.http.HttpServletRequest;\n \n import org.springframework.beans.factory.ObjectProvider;\n-import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.actuate.endpoint.Endpoint;\n import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\n import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\n@@ -42,11 +41,11 @@ import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplicat\n import org.springframework.boot.autoconfigure.condition.SpringBootCondition;\n import org.springframework.boot.autoconfigure.security.AuthenticationManagerConfiguration;\n import org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration;\n+import org.springframework.boot.autoconfigure.security.IgnoredRequestCustomizer;\n import org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;\n import org.springframework.boot.autoconfigure.security.SecurityPrerequisite;\n import org.springframework.boot.autoconfigure.security.SecurityProperties;\n import org.springframework.boot.autoconfigure.security.SpringBootWebSecurityConfiguration;\n-import org.springframework.boot.autoconfigure.web.ErrorController;\n import org.springframework.boot.autoconfigure.web.ServerProperties;\n import org.springframework.boot.context.properties.EnableConfigurationProperties;\n import org.springframework.context.ApplicationContext;\n@@ -56,9 +55,7 @@ import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.core.annotation.Order;\n import org.springframework.core.type.AnnotatedTypeMetadata;\n-import org.springframework.security.config.annotation.web.WebSecurityConfigurer;\n import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n-import org.springframework.security.config.annotation.web.builders.WebSecurity;\n import org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\n import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;\n@@ -72,7 +69,6 @@ import org.springframework.security.web.util.matcher.AnyRequestMatcher;\n import org.springframework.security.web.util.matcher.NegatedRequestMatcher;\n import org.springframework.security.web.util.matcher.OrRequestMatcher;\n import org.springframework.security.web.util.matcher.RequestMatcher;\n-import org.springframework.util.ObjectUtils;\n import org.springframework.util.StringUtils;\n \n /**\n@@ -102,9 +98,34 @@ public class ManagementWebSecurityAutoConfiguration {\n \t\t\tAnyRequestMatcher.INSTANCE);\n \n \t@Bean\n-\t@ConditionalOnMissingBean({ IgnoredPathsWebSecurityConfigurerAdapter.class })\n-\tpublic IgnoredPathsWebSecurityConfigurerAdapter ignoredPathsWebSecurityConfigurerAdapter() {\n-\t\treturn new IgnoredPathsWebSecurityConfigurerAdapter();\n+\tpublic IgnoredRequestCustomizer managementIgnoredRequestCustomizer(\n+\t\t\tManagementServerProperties management,\n+\t\t\tObjectProvider<ManagementContextResolver> contextResolverProvider) {\n+\t\treturn new ManagementIgnoredRequestCustomizer(management,\n+\t\t\t\tcontextResolverProvider.getIfAvailable());\n+\t}\n+\n+\tprivate class ManagementIgnoredRequestCustomizer implements IgnoredRequestCustomizer {\n+\n+\t\tprivate final ManagementServerProperties management;\n+\n+\t\tprivate final ManagementContextResolver contextResolver;\n+\n+\t\tManagementIgnoredRequestCustomizer(ManagementServerProperties management,\n+\t\t\t\tManagementContextResolver contextResolver) {\n+\t\t\tthis.management = management;\n+\t\t\tthis.contextResolver = contextResolver;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void customize(IgnoredRequestConfigurer configurer) {\n+\t\t\tif (!this.management.getSecurity().isEnabled()) {\n+\t\t\t\tRequestMatcher requestMatcher = LazyEndpointPathRequestMatcher\n+\t\t\t\t\t\t.getRequestMatcher(this.contextResolver);\n+\t\t\t\tconfigurer.requestMatchers(requestMatcher);\n+\t\t\t}\n+\n+\t\t}\n \t}\n \n \t@Configuration\n@@ -132,80 +153,6 @@ public class ManagementWebSecurityAutoConfiguration {\n \n \t}\n \n-\t// Get the ignored paths in early\n-\t@Order(SecurityProperties.IGNORED_ORDER + 1)\n-\tprivate static class IgnoredPathsWebSecurityConfigurerAdapter\n-\t\t\timplements WebSecurityConfigurer<WebSecurity> {\n-\n-\t\t@Autowired(required = false)\n-\t\tprivate ErrorController errorController;\n-\n-\t\t@Autowired\n-\t\tprivate SecurityProperties security;\n-\n-\t\t@Autowired\n-\t\tprivate ManagementServerProperties management;\n-\n-\t\t@Autowired(required = false)\n-\t\tprivate ManagementContextResolver contextResolver;\n-\n-\t\t@Autowired(required = false)\n-\t\tprivate ServerProperties server;\n-\n-\t\t@Override\n-\t\tpublic void configure(WebSecurity builder) throws Exception {\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void init(WebSecurity builder) throws Exception {\n-\t\t\tif (this.server == null) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n-\t\t\t// The ignores are not cumulative, so to prevent overwriting the defaults\n-\t\t\t// we add them back.\n-\t\t\tSet<String> ignored = new LinkedHashSet<String>(\n-\t\t\t\t\tSpringBootWebSecurityConfiguration.getIgnored(this.security));\n-\t\t\tif (ignored.contains("none")) {\n-\t\t\t\tignored.remove("none");\n-\t\t\t}\n-\t\t\tif (this.errorController != null) {\n-\t\t\t\tignored.add(normalizePath(this.errorController.getErrorPath()));\n-\t\t\t}\n-\t\t\tRequestMatcher requestMatcher = getRequestMatcher();\n-\t\t\tString[] paths = this.server.getPathsArray(ignored);\n-\t\t\tif (!ObjectUtils.isEmpty(paths)) {\n-\t\t\t\tList<RequestMatcher> matchers = new ArrayList<RequestMatcher>();\n-\t\t\t\tfor (String pattern : paths) {\n-\t\t\t\t\tmatchers.add(new AntPathRequestMatcher(pattern, null));\n-\t\t\t\t}\n-\t\t\t\tif (requestMatcher != null) {\n-\t\t\t\t\tmatchers.add(requestMatcher);\n-\t\t\t\t}\n-\t\t\t\trequestMatcher = new OrRequestMatcher(matchers);\n-\t\t\t}\n-\t\t\tif (requestMatcher != null) {\n-\t\t\t\tignoring.requestMatchers(requestMatcher);\n-\t\t\t}\n-\t\t}\n-\n-\t\tprivate RequestMatcher getRequestMatcher() {\n-\t\t\tif (this.management.getSecurity().isEnabled()) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\treturn LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver);\n-\t\t}\n-\n-\t\tprivate String normalizePath(String errorPath) {\n-\t\t\tString result = StringUtils.cleanPath(errorPath);\n-\t\t\tif (!result.startsWith("/")) {\n-\t\t\t\tresult = "/" + result;\n-\t\t\t}\n-\t\t\treturn result;\n-\t\t}\n-\n-\t}\n-\n \t@Configuration\n \t@ConditionalOnMissingBean(WebSecurityConfiguration.class)\n \t@Conditional(WebSecurityEnablerCondition.class)\n@@ -310,9 +257,7 @@ public class ManagementWebSecurityAutoConfiguration {\n \t\t\t// Permit access to the non-sensitive endpoints\n \t\t\trequests.requestMatchers(new LazyEndpointPathRequestMatcher(\n \t\t\t\t\tthis.contextResolver, EndpointPaths.NON_SENSITIVE)).permitAll();\n-\t\t\t// Restrict the rest to the configured roles\n-\t\t\tList<String> roles = this.management.getSecurity().getRoles();\n-\t\t\trequests.anyRequest().hasAnyRole(roles.toArray(new String[roles.size()]));\n+\t\t\trequests.anyRequest().authenticated();\n \t\t}\n \n \t}\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.security.AuthenticationManagerConfiguration;\nimport org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration;\nimport org.springframework.boot.autoconfigure.security.IgnoredRequestCustomizer;\nimport org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;\nimport org.springframework.boot.autoconfigure.security.SecurityPrerequisite;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.boot.autoconfigure.security.SpringBootWebSecurityConfiguration;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\nimport org.springframework.security.web.util.matcher.AnyRequestMatcher;\nimport org.springframework.security.web.util.matcher.NegatedRequestMatcher;\nimport org.springframework.security.web.util.matcher.OrRequestMatcher;\nimport org.springframework.security.web.util.matcher.RequestMatcher;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for security of framework endpoints.\n * Many aspects of the behavior can be controller with {@link ManagementServerProperties}\n * via externalized application properties (or via an bean definition of that type to set\n * the defaults).\n * <p>\n * The framework {@link Endpoint}s (used to expose application information to operations)\n * include a {@link Endpoint#isSensitive() sensitive} configuration option which will be\n * used as a security hint by the filter created here.\n *\n * @author Dave Syer\n * @author Andy Wilkinson\n */\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({ EnableWebSecurity.class })\n@AutoConfigureAfter(SecurityAutoConfiguration.class)\n@AutoConfigureBefore(FallbackWebSecurityAutoConfiguration.class)\n@EnableConfigurationProperties\npublic class ManagementWebSecurityAutoConfiguration {\n\n\tprivate static final String[] NO_PATHS = new String[0];\n\n\tprivate static final RequestMatcher MATCH_NONE = new NegatedRequestMatcher(\n\t\t\tAnyRequestMatcher.INSTANCE);\n\n\t@Bean\n\tpublic IgnoredRequestCustomizer managementIgnoredRequestCustomizer(\n\t\t\tManagementServerProperties management,\n\t\t\tObjectProvider<ManagementContextResolver> contextResolverProvider) {\n\t\treturn new ManagementIgnoredRequestCustomizer(management,\n\t\t\t\tcontextResolverProvider.getIfAvailable());\n\t}\n\n\tprivate class ManagementIgnoredRequestCustomizer implements IgnoredRequestCustomizer {\n\n\t\tprivate final ManagementServerProperties management;\n\n\t\tprivate final ManagementContextResolver contextResolver;\n\n\t\tManagementIgnoredRequestCustomizer(ManagementServerProperties management,\n\t\t\t\tManagementContextResolver contextResolver) {\n\t\t\tthis.management = management;\n\t\t\tthis.contextResolver = contextResolver;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(IgnoredRequestConfigurer configurer) {\n\t\t\tif (!this.management.getSecurity().isEnabled()) {\n\t\t\t\tRequestMatcher requestMatcher = LazyEndpointPathRequestMatcher\n\t\t\t\t\t\t.getRequestMatcher(this.contextResolver);\n\t\t\t\tconfigurer.requestMatchers(requestMatcher);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t@Configuration\n\tprotected static class ManagementSecurityPropertiesConfiguration\n\t\t\timplements SecurityPrerequisite {\n\n\t\tprivate final SecurityProperties security;\n\n\t\tprivate final ManagementServerProperties management;\n\n\t\tpublic ManagementSecurityPropertiesConfiguration(\n\t\t\t\tObjectProvider<SecurityProperties> securityProvider,\n\t\t\t\tObjectProvider<ManagementServerProperties> managementProvider) {\n\t\t\tthis.security = securityProvider.getIfAvailable();\n\t\t\tthis.management = managementProvider.getIfAvailable();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() {\n\t\t\tif (this.management != null && this.security != null) {\n\t\t\t\tthis.security.getUser().getRole()\n\t\t\t\t\t\t.addAll(this.management.getSecurity().getRoles());\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(WebSecurityConfiguration.class)\n\t@Conditional(WebSecurityEnablerCondition.class)\n\t@EnableWebSecurity\n\tprotected static class WebSecurityEnabler extends AuthenticationManagerConfiguration {\n\t}\n\n\t/**\n\t * WebSecurityEnabler condition.\n\t */\n\tstatic class WebSecurityEnablerCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tString managementEnabled = context.getEnvironment()\n\t\t\t\t\t.getProperty("management.security.enabled", "true");\n\t\t\tString basicEnabled = context.getEnvironment()\n\t\t\t\t\t.getProperty("security.basic.enabled", "true");\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("WebSecurityEnabled");\n\t\t\tif ("true".equalsIgnoreCase(managementEnabled)\n\t\t\t\t\t&& !"true".equalsIgnoreCase(basicEnabled)) {\n\t\t\t\treturn ConditionOutcome.match(message.because("security enabled"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.because("security disabled"));\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })\n\t@ConditionalOnProperty(prefix = "management.security", name = "enabled", matchIfMissing = true)\n\t@Order(ManagementServerProperties.BASIC_AUTH_ORDER)\n\tprotected static class ManagementWebSecurityConfigurerAdapter\n\t\t\textends WebSecurityConfigurerAdapter {\n\n\t\tprivate final SecurityProperties security;\n\n\t\tprivate final ManagementServerProperties management;\n\n\t\tprivate final ManagementContextResolver contextResolver;\n\n\t\tpublic ManagementWebSecurityConfigurerAdapter(SecurityProperties security,\n\t\t\t\tManagementServerProperties management,\n\t\t\t\tObjectProvider<ManagementContextResolver> contextResolverProvider) {\n\t\t\tthis.security = security;\n\t\t\tthis.management = management;\n\t\t\tthis.contextResolver = contextResolverProvider.getIfAvailable();\n\t\t}\n\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\t\t\t// secure endpoints\n\t\t\tRequestMatcher matcher = getRequestMatcher();\n\t\t\tif (matcher != null) {\n\t\t\t\t// Always protect them if present\n\t\t\t\tif (this.security.isRequireSsl()) {\n\t\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n\t\t\t\t}\n\t\t\t\tAuthenticationEntryPoint entryPoint = entryPoint();\n\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint);\n\t\t\t\t// Match all the requests for actuator endpoints ...\n\t\t\t\thttp.requestMatcher(matcher);\n\t\t\t\t// ... but permitAll() for the non-sensitive ones\n\t\t\t\tconfigurePermittedRequests(http.authorizeRequests());\n\t\t\t\thttp.httpBasic().authenticationEntryPoint(entryPoint);\n\t\t\t\t// No cookies for management endpoints by default\n\t\t\t\thttp.csrf().disable();\n\t\t\t\thttp.sessionManagement()\n\t\t\t\t\t\t.sessionCreationPolicy(asSpringSecuritySessionCreationPolicy(\n\t\t\t\t\t\t\t\tthis.management.getSecurity().getSessions()));\n\t\t\t\tSpringBootWebSecurityConfiguration.configureHeaders(http.headers(),\n\t\t\t\t\t\tthis.security.getHeaders());\n\t\t\t}\n\t\t}\n\n\t\tprivate SessionCreationPolicy asSpringSecuritySessionCreationPolicy(\n\t\t\t\tEnum<?> value) {\n\t\t\tif (value == null) {\n\t\t\t\treturn SessionCreationPolicy.STATELESS;\n\t\t\t}\n\t\t\treturn SessionCreationPolicy.valueOf(value.name());\n\t\t}\n\n\t\tprivate RequestMatcher getRequestMatcher() {\n\t\t\tif (this.management.getSecurity().isEnabled()) {\n\t\t\t\treturn LazyEndpointPathRequestMatcher\n\t\t\t\t\t\t.getRequestMatcher(this.contextResolver);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate AuthenticationEntryPoint entryPoint() {\n\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n\t\t\treturn entryPoint;\n\t\t}\n\n\t\tprivate void configurePermittedRequests(\n\t\t\t\tExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) {\n\t\t\t// Permit access to the non-sensitive endpoints\n\t\t\trequests.requestMatchers(new LazyEndpointPathRequestMatcher(\n\t\t\t\t\tthis.contextResolver, EndpointPaths.NON_SENSITIVE)).permitAll();\n\t\t\trequests.anyRequest().authenticated();\n\t\t}\n\n\t}\n\n\tprivate enum EndpointPaths {\n\n\t\tALL,\n\n\t\tNON_SENSITIVE {\n\n\t\t\t@Override\n\t\t\tprotected boolean isIncluded(MvcEndpoint endpoint) {\n\t\t\t\treturn !endpoint.isSensitive();\n\t\t\t}\n\n\t\t};\n\n\t\tpublic String[] getPaths(EndpointHandlerMapping endpointHandlerMapping) {\n\t\t\tif (endpointHandlerMapping == null) {\n\t\t\t\treturn NO_PATHS;\n\t\t\t}\n\t\t\tSet<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints();\n\t\t\tSet<String> paths = new LinkedHashSet<String>(endpoints.size());\n\t\t\tfor (MvcEndpoint endpoint : endpoints) {\n\t\t\t\tif (isIncluded(endpoint)) {\n\t\t\t\t\tString path = endpointHandlerMapping.getPath(endpoint.getPath());\n\t\t\t\t\tpaths.add(path);\n\t\t\t\t\tif (!path.equals("")) {\n\t\t\t\t\t\tif (endpoint.isSensitive()) {\n\t\t\t\t\t\t\t// Ensure that nested paths are secured\n\t\t\t\t\t\t\tpaths.add(path + "/**");\n\t\t\t\t\t\t\t// Add Spring MVC-generated additional paths\n\t\t\t\t\t\t\tpaths.add(path + ".*");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpaths.add(path + "/");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paths.toArray(new String[paths.size()]);\n\t\t}\n\n\t\tprotected boolean isIncluded(MvcEndpoint endpoint) {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tprivate static class LazyEndpointPathRequestMatcher implements RequestMatcher {\n\n\t\tprivate final EndpointPaths endpointPaths;\n\n\t\tprivate final ManagementContextResolver contextResolver;\n\n\t\tprivate RequestMatcher delegate;\n\n\t\tpublic static RequestMatcher getRequestMatcher(\n\t\t\t\tManagementContextResolver contextResolver) {\n\t\t\tif (contextResolver == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tManagementServerProperties management = contextResolver\n\t\t\t\t\t.getApplicationContext().getBean(ManagementServerProperties.class);\n\t\t\tServerProperties server = contextResolver.getApplicationContext()\n\t\t\t\t\t.getBean(ServerProperties.class);\n\t\t\tString path = management.getContextPath();\n\t\t\tif (StringUtils.hasText(path)) {\n\t\t\t\tAntPathRequestMatcher matcher = new AntPathRequestMatcher(\n\t\t\t\t\t\tserver.getPath(path) + "/**");\n\t\t\t\treturn matcher;\n\t\t\t}\n\t\t\t// Match everything, including the sensitive and non-sensitive paths\n\t\t\treturn new LazyEndpointPathRequestMatcher(contextResolver, EndpointPaths.ALL);\n\t\t}\n\n\t\tLazyEndpointPathRequestMatcher(ManagementContextResolver contextResolver,\n\t\t\t\tEndpointPaths endpointPaths) {\n\t\t\tthis.contextResolver = contextResolver;\n\t\t\tthis.endpointPaths = endpointPaths;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(HttpServletRequest request) {\n\t\t\tif (this.delegate == null) {\n\t\t\t\tthis.delegate = createDelegate();\n\t\t\t}\n\t\t\treturn this.delegate.matches(request);\n\t\t}\n\n\t\tprivate RequestMatcher createDelegate() {\n\t\t\tServerProperties server = this.contextResolver.getApplicationContext()\n\t\t\t\t\t.getBean(ServerProperties.class);\n\t\t\tList<RequestMatcher> matchers = new ArrayList<RequestMatcher>();\n\t\t\tEndpointHandlerMapping endpointHandlerMapping = getRequiredEndpointHandlerMapping();\n\t\t\tfor (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) {\n\t\t\t\tmatchers.add(new AntPathRequestMatcher(server.getPath(path)));\n\t\t\t}\n\t\t\treturn (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers));\n\t\t}\n\n\t\tprivate EndpointHandlerMapping getRequiredEndpointHandlerMapping() {\n\t\t\tEndpointHandlerMapping endpointHandlerMapping = null;\n\t\t\tApplicationContext context = this.contextResolver.getApplicationContext();\n\t\t\tif (context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) {\n\t\t\t\tendpointHandlerMapping = context.getBean(EndpointHandlerMapping.class);\n\t\t\t}\n\t\t\tif (endpointHandlerMapping == null) {\n\t\t\t\t// Maybe there are actually no endpoints (e.g. management.port=-1)\n\t\t\t\tendpointHandlerMapping = new EndpointHandlerMapping(\n\t\t\t\t\t\tCollections.<MvcEndpoint>emptySet());\n\t\t\t}\n\t\t\treturn endpointHandlerMapping;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.beans.factory.ObjectProvider;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.Endpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.security.AuthenticationManagerConfiguration;\nimport org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration;\nimport org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;\nimport org.springframework.boot.autoconfigure.security.SecurityPrerequisite;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.boot.autoconfigure.security.SpringBootWebSecurityConfiguration;\nimport org.springframework.boot.autoconfigure.web.ErrorController;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.security.config.annotation.web.WebSecurityConfigurer;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity;\nimport org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.web.AuthenticationEntryPoint;\nimport org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\nimport org.springframework.security.web.util.matcher.AnyRequestMatcher;\nimport org.springframework.security.web.util.matcher.NegatedRequestMatcher;\nimport org.springframework.security.web.util.matcher.OrRequestMatcher;\nimport org.springframework.security.web.util.matcher.RequestMatcher;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for security of framework endpoints.\n * Many aspects of the behavior can be controller with {@link ManagementServerProperties}\n * via externalized application properties (or via an bean definition of that type to set\n * the defaults).\n * <p>\n * The framework {@link Endpoint}s (used to expose application information to operations)\n * include a {@link Endpoint#isSensitive() sensitive} configuration option which will be\n * used as a security hint by the filter created here.\n *\n * @author Dave Syer\n * @author Andy Wilkinson\n */\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass({ EnableWebSecurity.class })\n@AutoConfigureAfter(SecurityAutoConfiguration.class)\n@AutoConfigureBefore(FallbackWebSecurityAutoConfiguration.class)\n@EnableConfigurationProperties\npublic class ManagementWebSecurityAutoConfiguration {\n\n\tprivate static final String[] NO_PATHS = new String[0];\n\n\tprivate static final RequestMatcher MATCH_NONE = new NegatedRequestMatcher(\n\t\t\tAnyRequestMatcher.INSTANCE);\n\n\t@Bean\n\t@ConditionalOnMissingBean({ IgnoredPathsWebSecurityConfigurerAdapter.class })\n\tpublic IgnoredPathsWebSecurityConfigurerAdapter ignoredPathsWebSecurityConfigurerAdapter() {\n\t\treturn new IgnoredPathsWebSecurityConfigurerAdapter();\n\t}\n\n\t@Configuration\n\tprotected static class ManagementSecurityPropertiesConfiguration\n\t\t\timplements SecurityPrerequisite {\n\n\t\tprivate final SecurityProperties security;\n\n\t\tprivate final ManagementServerProperties management;\n\n\t\tpublic ManagementSecurityPropertiesConfiguration(\n\t\t\t\tObjectProvider<SecurityProperties> securityProvider,\n\t\t\t\tObjectProvider<ManagementServerProperties> managementProvider) {\n\t\t\tthis.security = securityProvider.getIfAvailable();\n\t\t\tthis.management = managementProvider.getIfAvailable();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() {\n\t\t\tif (this.management != null && this.security != null) {\n\t\t\t\tthis.security.getUser().getRole()\n\t\t\t\t\t\t.addAll(this.management.getSecurity().getRoles());\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Get the ignored paths in early\n\t@Order(SecurityProperties.IGNORED_ORDER + 1)\n\tprivate static class IgnoredPathsWebSecurityConfigurerAdapter\n\t\t\timplements WebSecurityConfigurer<WebSecurity> {\n\n\t\t@Autowired(required = false)\n\t\tprivate ErrorController errorController;\n\n\t\t@Autowired\n\t\tprivate SecurityProperties security;\n\n\t\t@Autowired\n\t\tprivate ManagementServerProperties management;\n\n\t\t@Autowired(required = false)\n\t\tprivate ManagementContextResolver contextResolver;\n\n\t\t@Autowired(required = false)\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic void configure(WebSecurity builder) throws Exception {\n\t\t}\n\n\t\t@Override\n\t\tpublic void init(WebSecurity builder) throws Exception {\n\t\t\tif (this.server == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tIgnoredRequestConfigurer ignoring = builder.ignoring();\n\t\t\t// The ignores are not cumulative, so to prevent overwriting the defaults\n\t\t\t// we add them back.\n\t\t\tSet<String> ignored = new LinkedHashSet<String>(\n\t\t\t\t\tSpringBootWebSecurityConfiguration.getIgnored(this.security));\n\t\t\tif (ignored.contains("none")) {\n\t\t\t\tignored.remove("none");\n\t\t\t}\n\t\t\tif (this.errorController != null) {\n\t\t\t\tignored.add(normalizePath(this.errorController.getErrorPath()));\n\t\t\t}\n\t\t\tRequestMatcher requestMatcher = getRequestMatcher();\n\t\t\tString[] paths = this.server.getPathsArray(ignored);\n\t\t\tif (!ObjectUtils.isEmpty(paths)) {\n\t\t\t\tList<RequestMatcher> matchers = new ArrayList<RequestMatcher>();\n\t\t\t\tfor (String pattern : paths) {\n\t\t\t\t\tmatchers.add(new AntPathRequestMatcher(pattern, null));\n\t\t\t\t}\n\t\t\t\tif (requestMatcher != null) {\n\t\t\t\t\tmatchers.add(requestMatcher);\n\t\t\t\t}\n\t\t\t\trequestMatcher = new OrRequestMatcher(matchers);\n\t\t\t}\n\t\t\tif (requestMatcher != null) {\n\t\t\t\tignoring.requestMatchers(requestMatcher);\n\t\t\t}\n\t\t}\n\n\t\tprivate RequestMatcher getRequestMatcher() {\n\t\t\tif (this.management.getSecurity().isEnabled()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver);\n\t\t}\n\n\t\tprivate String normalizePath(String errorPath) {\n\t\t\tString result = StringUtils.cleanPath(errorPath);\n\t\t\tif (!result.startsWith("/")) {\n\t\t\t\tresult = "/" + result;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean(WebSecurityConfiguration.class)\n\t@Conditional(WebSecurityEnablerCondition.class)\n\t@EnableWebSecurity\n\tprotected static class WebSecurityEnabler extends AuthenticationManagerConfiguration {\n\t}\n\n\t/**\n\t * WebSecurityEnabler condition.\n\t */\n\tstatic class WebSecurityEnablerCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context,\n\t\t\t\tAnnotatedTypeMetadata metadata) {\n\t\t\tString managementEnabled = context.getEnvironment()\n\t\t\t\t\t.getProperty("management.security.enabled", "true");\n\t\t\tString basicEnabled = context.getEnvironment()\n\t\t\t\t\t.getProperty("security.basic.enabled", "true");\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("WebSecurityEnabled");\n\t\t\tif ("true".equalsIgnoreCase(managementEnabled)\n\t\t\t\t\t&& !"true".equalsIgnoreCase(basicEnabled)) {\n\t\t\t\treturn ConditionOutcome.match(message.because("security enabled"));\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.because("security disabled"));\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })\n\t@ConditionalOnProperty(prefix = "management.security", name = "enabled", matchIfMissing = true)\n\t@Order(ManagementServerProperties.BASIC_AUTH_ORDER)\n\tprotected static class ManagementWebSecurityConfigurerAdapter\n\t\t\textends WebSecurityConfigurerAdapter {\n\n\t\tprivate final SecurityProperties security;\n\n\t\tprivate final ManagementServerProperties management;\n\n\t\tprivate final ManagementContextResolver contextResolver;\n\n\t\tpublic ManagementWebSecurityConfigurerAdapter(SecurityProperties security,\n\t\t\t\tManagementServerProperties management,\n\t\t\t\tObjectProvider<ManagementContextResolver> contextResolverProvider) {\n\t\t\tthis.security = security;\n\t\t\tthis.management = management;\n\t\t\tthis.contextResolver = contextResolverProvider.getIfAvailable();\n\t\t}\n\n\t\t@Override\n\t\tprotected void configure(HttpSecurity http) throws Exception {\n\t\t\t// secure endpoints\n\t\t\tRequestMatcher matcher = getRequestMatcher();\n\t\t\tif (matcher != null) {\n\t\t\t\t// Always protect them if present\n\t\t\t\tif (this.security.isRequireSsl()) {\n\t\t\t\t\thttp.requiresChannel().anyRequest().requiresSecure();\n\t\t\t\t}\n\t\t\t\tAuthenticationEntryPoint entryPoint = entryPoint();\n\t\t\t\thttp.exceptionHandling().authenticationEntryPoint(entryPoint);\n\t\t\t\t// Match all the requests for actuator endpoints ...\n\t\t\t\thttp.requestMatcher(matcher);\n\t\t\t\t// ... but permitAll() for the non-sensitive ones\n\t\t\t\tconfigurePermittedRequests(http.authorizeRequests());\n\t\t\t\thttp.httpBasic().authenticationEntryPoint(entryPoint);\n\t\t\t\t// No cookies for management endpoints by default\n\t\t\t\thttp.csrf().disable();\n\t\t\t\thttp.sessionManagement()\n\t\t\t\t\t\t.sessionCreationPolicy(asSpringSecuritySessionCreationPolicy(\n\t\t\t\t\t\t\t\tthis.management.getSecurity().getSessions()));\n\t\t\t\tSpringBootWebSecurityConfiguration.configureHeaders(http.headers(),\n\t\t\t\t\t\tthis.security.getHeaders());\n\t\t\t}\n\t\t}\n\n\t\tprivate SessionCreationPolicy asSpringSecuritySessionCreationPolicy(\n\t\t\t\tEnum<?> value) {\n\t\t\tif (value == null) {\n\t\t\t\treturn SessionCreationPolicy.STATELESS;\n\t\t\t}\n\t\t\treturn SessionCreationPolicy.valueOf(value.name());\n\t\t}\n\n\t\tprivate RequestMatcher getRequestMatcher() {\n\t\t\tif (this.management.getSecurity().isEnabled()) {\n\t\t\t\treturn LazyEndpointPathRequestMatcher\n\t\t\t\t\t\t.getRequestMatcher(this.contextResolver);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate AuthenticationEntryPoint entryPoint() {\n\t\t\tBasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();\n\t\t\tentryPoint.setRealmName(this.security.getBasic().getRealm());\n\t\t\treturn entryPoint;\n\t\t}\n\n\t\tprivate void configurePermittedRequests(\n\t\t\t\tExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) {\n\t\t\t// Permit access to the non-sensitive endpoints\n\t\t\trequests.requestMatchers(new LazyEndpointPathRequestMatcher(\n\t\t\t\t\tthis.contextResolver, EndpointPaths.NON_SENSITIVE)).permitAll();\n\t\t\t// Restrict the rest to the configured roles\n\t\t\tList<String> roles = this.management.getSecurity().getRoles();\n\t\t\trequests.anyRequest().hasAnyRole(roles.toArray(new String[roles.size()]));\n\t\t}\n\n\t}\n\n\tprivate enum EndpointPaths {\n\n\t\tALL,\n\n\t\tNON_SENSITIVE {\n\n\t\t\t@Override\n\t\t\tprotected boolean isIncluded(MvcEndpoint endpoint) {\n\t\t\t\treturn !endpoint.isSensitive();\n\t\t\t}\n\n\t\t};\n\n\t\tpublic String[] getPaths(EndpointHandlerMapping endpointHandlerMapping) {\n\t\t\tif (endpointHandlerMapping == null) {\n\t\t\t\treturn NO_PATHS;\n\t\t\t}\n\t\t\tSet<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints();\n\t\t\tSet<String> paths = new LinkedHashSet<String>(endpoints.size());\n\t\t\tfor (MvcEndpoint endpoint : endpoints) {\n\t\t\t\tif (isIncluded(endpoint)) {\n\t\t\t\t\tString path = endpointHandlerMapping.getPath(endpoint.getPath());\n\t\t\t\t\tpaths.add(path);\n\t\t\t\t\tif (!path.equals("")) {\n\t\t\t\t\t\tif (endpoint.isSensitive()) {\n\t\t\t\t\t\t\t// Ensure that nested paths are secured\n\t\t\t\t\t\t\tpaths.add(path + "/**");\n\t\t\t\t\t\t\t// Add Spring MVC-generated additional paths\n\t\t\t\t\t\t\tpaths.add(path + ".*");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpaths.add(path + "/");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn paths.toArray(new String[paths.size()]);\n\t\t}\n\n\t\tprotected boolean isIncluded(MvcEndpoint endpoint) {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tprivate static class LazyEndpointPathRequestMatcher implements RequestMatcher {\n\n\t\tprivate final EndpointPaths endpointPaths;\n\n\t\tprivate final ManagementContextResolver contextResolver;\n\n\t\tprivate RequestMatcher delegate;\n\n\t\tpublic static RequestMatcher getRequestMatcher(\n\t\t\t\tManagementContextResolver contextResolver) {\n\t\t\tif (contextResolver == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tManagementServerProperties management = contextResolver\n\t\t\t\t\t.getApplicationContext().getBean(ManagementServerProperties.class);\n\t\t\tServerProperties server = contextResolver.getApplicationContext()\n\t\t\t\t\t.getBean(ServerProperties.class);\n\t\t\tString path = management.getContextPath();\n\t\t\tif (StringUtils.hasText(path)) {\n\t\t\t\tAntPathRequestMatcher matcher = new AntPathRequestMatcher(\n\t\t\t\t\t\tserver.getPath(path) + "/**");\n\t\t\t\treturn matcher;\n\t\t\t}\n\t\t\t// Match everything, including the sensitive and non-sensitive paths\n\t\t\treturn new LazyEndpointPathRequestMatcher(contextResolver, EndpointPaths.ALL);\n\t\t}\n\n\t\tLazyEndpointPathRequestMatcher(ManagementContextResolver contextResolver,\n\t\t\t\tEndpointPaths endpointPaths) {\n\t\t\tthis.contextResolver = contextResolver;\n\t\t\tthis.endpointPaths = endpointPaths;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(HttpServletRequest request) {\n\t\t\tif (this.delegate == null) {\n\t\t\t\tthis.delegate = createDelegate();\n\t\t\t}\n\t\t\treturn this.delegate.matches(request);\n\t\t}\n\n\t\tprivate RequestMatcher createDelegate() {\n\t\t\tServerProperties server = this.contextResolver.getApplicationContext()\n\t\t\t\t\t.getBean(ServerProperties.class);\n\t\t\tList<RequestMatcher> matchers = new ArrayList<RequestMatcher>();\n\t\t\tEndpointHandlerMapping endpointHandlerMapping = getRequiredEndpointHandlerMapping();\n\t\t\tfor (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) {\n\t\t\t\tmatchers.add(new AntPathRequestMatcher(server.getPath(path)));\n\t\t\t}\n\t\t\treturn (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers));\n\t\t}\n\n\t\tprivate EndpointHandlerMapping getRequiredEndpointHandlerMapping() {\n\t\t\tEndpointHandlerMapping endpointHandlerMapping = null;\n\t\t\tApplicationContext context = this.contextResolver.getApplicationContext();\n\t\t\tif (context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) {\n\t\t\t\tendpointHandlerMapping = context.getBean(EndpointHandlerMapping.class);\n\t\t\t}\n\t\t\tif (endpointHandlerMapping == null) {\n\t\t\t\t// Maybe there are actually no endpoints (e.g. management.port=-1)\n\t\t\t\tendpointHandlerMapping = new EndpointHandlerMapping(\n\t\t\t\t\t\tCollections.<MvcEndpoint>emptySet());\n\t\t\t}\n\t\t\treturn endpointHandlerMapping;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
