{'_old_path': PosixPath('spring-boot-developer-tools/src/main/java/org/springframework/boot/developertools/remote/client/RemoteClientConfiguration.java'), '_new_path': PosixPath('spring-boot-devtools/src/main/java/org/springframework/boot/devtools/remote/client/RemoteClientConfiguration.java'), 'change_type': <ModificationType.RENAME: 3>, 'diff': '@@ -14,7 +14,7 @@\n  * limitations under the License.\n  */\n \n-package org.springframework.boot.developertools.remote.client;\n+package org.springframework.boot.devtools.remote.client;\n \n import java.net.URL;\n import java.util.Arrays;\n@@ -33,20 +33,20 @@ import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.context.properties.EnableConfigurationProperties;\n-import org.springframework.boot.developertools.autoconfigure.DeveloperToolsProperties;\n-import org.springframework.boot.developertools.autoconfigure.OptionalLiveReloadServer;\n-import org.springframework.boot.developertools.autoconfigure.RemoteDeveloperToolsProperties;\n-import org.springframework.boot.developertools.classpath.ClassPathChangedEvent;\n-import org.springframework.boot.developertools.classpath.ClassPathFileSystemWatcher;\n-import org.springframework.boot.developertools.classpath.ClassPathRestartStrategy;\n-import org.springframework.boot.developertools.classpath.PatternClassPathRestartStrategy;\n-import org.springframework.boot.developertools.livereload.LiveReloadServer;\n-import org.springframework.boot.developertools.restart.DefaultRestartInitializer;\n-import org.springframework.boot.developertools.restart.RestartScope;\n-import org.springframework.boot.developertools.restart.Restarter;\n-import org.springframework.boot.developertools.tunnel.client.HttpTunnelConnection;\n-import org.springframework.boot.developertools.tunnel.client.TunnelClient;\n-import org.springframework.boot.developertools.tunnel.client.TunnelConnection;\n+import org.springframework.boot.devtools.autoconfigure.DevToolsProperties;\n+import org.springframework.boot.devtools.autoconfigure.OptionalLiveReloadServer;\n+import org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties;\n+import org.springframework.boot.devtools.classpath.ClassPathChangedEvent;\n+import org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher;\n+import org.springframework.boot.devtools.classpath.ClassPathRestartStrategy;\n+import org.springframework.boot.devtools.classpath.PatternClassPathRestartStrategy;\n+import org.springframework.boot.devtools.livereload.LiveReloadServer;\n+import org.springframework.boot.devtools.restart.DefaultRestartInitializer;\n+import org.springframework.boot.devtools.restart.RestartScope;\n+import org.springframework.boot.devtools.restart.Restarter;\n+import org.springframework.boot.devtools.tunnel.client.HttpTunnelConnection;\n+import org.springframework.boot.devtools.tunnel.client.TunnelClient;\n+import org.springframework.boot.devtools.tunnel.client.TunnelConnection;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n@@ -63,16 +63,16 @@ import org.springframework.util.Assert;\n  *\n  * @author Phillip Webb\n  * @since 1.3.0\n- * @see org.springframework.boot.developertools.RemoteSpringApplication\n+ * @see org.springframework.boot.devtools.RemoteSpringApplication\n  */\n @Configuration\n-@EnableConfigurationProperties(DeveloperToolsProperties.class)\n+@EnableConfigurationProperties(DevToolsProperties.class)\n public class RemoteClientConfiguration {\n \n \tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n \n \t@Autowired\n-\tprivate DeveloperToolsProperties properties;\n+\tprivate DevToolsProperties properties;\n \n \t@Value("${remoteUrl}")\n \tprivate String remoteUrl;\n@@ -91,18 +91,18 @@ public class RemoteClientConfiguration {\n \t}\n \n \tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n-\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n+\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n \t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n \t\tString secret = remoteProperties.getSecret();\n \t\tAssert.state(secret != null,\n-\t\t\t\t"The environment value \'spring.developertools.remote.secret\' "\n+\t\t\t\t"The environment value \'spring.devtools.remote.secret\' "\n \t\t\t\t\t\t+ "is required to secure your connection.");\n \t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n \t}\n \n \t@PostConstruct\n \tprivate void logWarnings() {\n-\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n+\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n \t\tif (!remoteProperties.getDebug().isEnabled()\n \t\t\t\t&& !remoteProperties.getRestart().isEnabled()) {\n \t\t\tlogger.warn("Remote restart and debug are both disabled.");\n@@ -116,11 +116,11 @@ public class RemoteClientConfiguration {\n \t/**\n \t * LiveReload configuration.\n \t */\n-\t@ConditionalOnProperty(prefix = "spring.developertools.livereload", name = "enabled", matchIfMissing = true)\n+\t@ConditionalOnProperty(prefix = "spring.devtools.livereload", name = "enabled", matchIfMissing = true)\n \tstatic class LiveReloadConfiguration {\n \n \t\t@Autowired\n-\t\tprivate DeveloperToolsProperties properties;\n+\t\tprivate DevToolsProperties properties;\n \n \t\t@Autowired(required = false)\n \t\tprivate LiveReloadServer liveReloadServer;\n@@ -162,11 +162,11 @@ public class RemoteClientConfiguration {\n \t/**\n \t * Client configuration for remote update and restarts.\n \t */\n-\t@ConditionalOnProperty(prefix = "spring.developertools.remote.restart", name = "enabled", matchIfMissing = true)\n+\t@ConditionalOnProperty(prefix = "spring.devtools.remote.restart", name = "enabled", matchIfMissing = true)\n \tstatic class RemoteRestartClientConfiguration {\n \n \t\t@Autowired\n-\t\tprivate DeveloperToolsProperties properties;\n+\t\tprivate DevToolsProperties properties;\n \n \t\t@Value("${remoteUrl}")\n \t\tprivate String remoteUrl;\n@@ -200,13 +200,13 @@ public class RemoteClientConfiguration {\n \t/**\n \t * Client configuration for remote debug HTTP tunneling.\n \t */\n-\t@ConditionalOnProperty(prefix = "spring.developertools.remote.debug", name = "enabled", matchIfMissing = true)\n+\t@ConditionalOnProperty(prefix = "spring.devtools.remote.debug", name = "enabled", matchIfMissing = true)\n \t@ConditionalOnClass(Filter.class)\n \t@Conditional(LocalDebugPortAvailableCondition.class)\n \tstatic class RemoteDebugTunnelClientConfiguration {\n \n \t\t@Autowired\n-\t\tprivate DeveloperToolsProperties properties;\n+\t\tprivate DevToolsProperties properties;\n \n \t\t@Value("${remoteUrl}")\n \t\tprivate String remoteUrl;\n@@ -214,7 +214,7 @@ public class RemoteClientConfiguration {\n \t\t@Bean\n \t\tpublic TunnelClient remoteDebugTunnelClient(\n \t\t\t\tClientHttpRequestFactory requestFactory) {\n-\t\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n+\t\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n \t\t\tString url = this.remoteUrl + remoteProperties.getContextPath() + "/debug";\n \t\t\tTunnelConnection connection = new HttpTunnelConnection(url, requestFactory);\n \t\t\tint localPort = remoteProperties.getDebug().getLocalPort();\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.devtools.remote.client;\n\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.OptionalLiveReloadServer;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties;\nimport org.springframework.boot.devtools.classpath.ClassPathChangedEvent;\nimport org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher;\nimport org.springframework.boot.devtools.classpath.ClassPathRestartStrategy;\nimport org.springframework.boot.devtools.classpath.PatternClassPathRestartStrategy;\nimport org.springframework.boot.devtools.livereload.LiveReloadServer;\nimport org.springframework.boot.devtools.restart.DefaultRestartInitializer;\nimport org.springframework.boot.devtools.restart.RestartScope;\nimport org.springframework.boot.devtools.restart.Restarter;\nimport org.springframework.boot.devtools.tunnel.client.HttpTunnelConnection;\nimport org.springframework.boot.devtools.tunnel.client.TunnelClient;\nimport org.springframework.boot.devtools.tunnel.client.TunnelConnection;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.InterceptingClientHttpRequestFactory;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.util.Assert;\n\n/**\n * Configuration used to connect to remote Spring Boot applications.\n *\n * @author Phillip Webb\n * @since 1.3.0\n * @see org.springframework.boot.devtools.RemoteSpringApplication\n */\n@Configuration\n@EnableConfigurationProperties(DevToolsProperties.class)\npublic class RemoteClientConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n\n\t@Autowired\n\tprivate DevToolsProperties properties;\n\n\t@Value("${remoteUrl}")\n\tprivate String remoteUrl;\n\n\t@Bean\n\tpublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n\t}\n\n\t@Bean\n\tpublic ClientHttpRequestFactory clientHttpRequestFactory() {\n\t\tList<ClientHttpRequestInterceptor> interceptors = Arrays\n\t\t\t\t.asList(getSecurityInterceptor());\n\t\treturn new InterceptingClientHttpRequestFactory(\n\t\t\t\tnew SimpleClientHttpRequestFactory(), interceptors);\n\t}\n\n\tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n\t\tString secret = remoteProperties.getSecret();\n\t\tAssert.state(secret != null,\n\t\t\t\t"The environment value \'spring.devtools.remote.secret\' "\n\t\t\t\t\t\t+ "is required to secure your connection.");\n\t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n\t}\n\n\t@PostConstruct\n\tprivate void logWarnings() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tif (!remoteProperties.getDebug().isEnabled()\n\t\t\t\t&& !remoteProperties.getRestart().isEnabled()) {\n\t\t\tlogger.warn("Remote restart and debug are both disabled.");\n\t\t}\n\t\tif (!this.remoteUrl.startsWith("https://")) {\n\t\t\tlogger.warn("The connection to " + this.remoteUrl\n\t\t\t\t\t+ " is insecure. You should use a URL starting with \'https://\'.");\n\t\t}\n\t}\n\n\t/**\n\t * LiveReload configuration.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.livereload", name = "enabled", matchIfMissing = true)\n\tstatic class LiveReloadConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Autowired(required = false)\n\t\tprivate LiveReloadServer liveReloadServer;\n\n\t\t@Autowired\n\t\tprivate ClientHttpRequestFactory clientHttpRequestFactory;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\n\t\t@Bean\n\t\t@RestartScope\n\t\t@ConditionalOnMissingBean\n\t\tpublic LiveReloadServer liveReloadServer() {\n\t\t\treturn new LiveReloadServer(this.properties.getLivereload().getPort(),\n\t\t\t\t\tRestarter.getInstance().getThreadFactory());\n\t\t}\n\n\t\t@EventListener\n\t\tpublic void onClassPathChanged(ClassPathChangedEvent event) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath();\n\t\t\tthis.executor.execute(new DelayedLiveReloadTrigger(\n\t\t\t\t\toptionalLiveReloadServer(), this.clientHttpRequestFactory, url));\n\t\t}\n\n\t\t@Bean\n\t\tpublic OptionalLiveReloadServer optionalLiveReloadServer() {\n\t\t\treturn new OptionalLiveReloadServer(this.liveReloadServer);\n\t\t}\n\n\t\tfinal ExecutorService getExecutor() {\n\t\t\treturn this.executor;\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote update and restarts.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.remote.restart", name = "enabled", matchIfMissing = true)\n\tstatic class RemoteRestartClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic ClassPathFileSystemWatcher classPathFileSystemWatcher() {\n\t\t\tDefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();\n\t\t\tURL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());\n\t\t\tif (urls == null) {\n\t\t\t\turls = new URL[0];\n\t\t\t}\n\t\t\treturn new ClassPathFileSystemWatcher(classPathRestartStrategy(), urls);\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathRestartStrategy classPathRestartStrategy() {\n\t\t\treturn new PatternClassPathRestartStrategy(this.properties.getRestart()\n\t\t\t\t\t.getExclude());\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathChangeUploader classPathChangeUploader(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath()\n\t\t\t\t\t+ "/restart";\n\t\t\treturn new ClassPathChangeUploader(url, requestFactory);\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote debug HTTP tunneling.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.devtools.remote.debug", name = "enabled", matchIfMissing = true)\n\t@ConditionalOnClass(Filter.class)\n\t@Conditional(LocalDebugPortAvailableCondition.class)\n\tstatic class RemoteDebugTunnelClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic TunnelClient remoteDebugTunnelClient(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\t\tString url = this.remoteUrl + remoteProperties.getContextPath() + "/debug";\n\t\t\tTunnelConnection connection = new HttpTunnelConnection(url, requestFactory);\n\t\t\tint localPort = remoteProperties.getDebug().getLocalPort();\n\t\t\tTunnelClient client = new TunnelClient(localPort, connection);\n\t\t\tclient.addListener(new LoggingTunnelClientListener());\n\t\t\treturn client;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.developertools.remote.client;\n\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.developertools.autoconfigure.DeveloperToolsProperties;\nimport org.springframework.boot.developertools.autoconfigure.OptionalLiveReloadServer;\nimport org.springframework.boot.developertools.autoconfigure.RemoteDeveloperToolsProperties;\nimport org.springframework.boot.developertools.classpath.ClassPathChangedEvent;\nimport org.springframework.boot.developertools.classpath.ClassPathFileSystemWatcher;\nimport org.springframework.boot.developertools.classpath.ClassPathRestartStrategy;\nimport org.springframework.boot.developertools.classpath.PatternClassPathRestartStrategy;\nimport org.springframework.boot.developertools.livereload.LiveReloadServer;\nimport org.springframework.boot.developertools.restart.DefaultRestartInitializer;\nimport org.springframework.boot.developertools.restart.RestartScope;\nimport org.springframework.boot.developertools.restart.Restarter;\nimport org.springframework.boot.developertools.tunnel.client.HttpTunnelConnection;\nimport org.springframework.boot.developertools.tunnel.client.TunnelClient;\nimport org.springframework.boot.developertools.tunnel.client.TunnelConnection;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.InterceptingClientHttpRequestFactory;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.util.Assert;\n\n/**\n * Configuration used to connect to remote Spring Boot applications.\n *\n * @author Phillip Webb\n * @since 1.3.0\n * @see org.springframework.boot.developertools.RemoteSpringApplication\n */\n@Configuration\n@EnableConfigurationProperties(DeveloperToolsProperties.class)\npublic class RemoteClientConfiguration {\n\n\tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n\n\t@Autowired\n\tprivate DeveloperToolsProperties properties;\n\n\t@Value("${remoteUrl}")\n\tprivate String remoteUrl;\n\n\t@Bean\n\tpublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n\t}\n\n\t@Bean\n\tpublic ClientHttpRequestFactory clientHttpRequestFactory() {\n\t\tList<ClientHttpRequestInterceptor> interceptors = Arrays\n\t\t\t\t.asList(getSecurityInterceptor());\n\t\treturn new InterceptingClientHttpRequestFactory(\n\t\t\t\tnew SimpleClientHttpRequestFactory(), interceptors);\n\t}\n\n\tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n\t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n\t\tString secret = remoteProperties.getSecret();\n\t\tAssert.state(secret != null,\n\t\t\t\t"The environment value \'spring.developertools.remote.secret\' "\n\t\t\t\t\t\t+ "is required to secure your connection.");\n\t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n\t}\n\n\t@PostConstruct\n\tprivate void logWarnings() {\n\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n\t\tif (!remoteProperties.getDebug().isEnabled()\n\t\t\t\t&& !remoteProperties.getRestart().isEnabled()) {\n\t\t\tlogger.warn("Remote restart and debug are both disabled.");\n\t\t}\n\t\tif (!this.remoteUrl.startsWith("https://")) {\n\t\t\tlogger.warn("The connection to " + this.remoteUrl\n\t\t\t\t\t+ " is insecure. You should use a URL starting with \'https://\'.");\n\t\t}\n\t}\n\n\t/**\n\t * LiveReload configuration.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.developertools.livereload", name = "enabled", matchIfMissing = true)\n\tstatic class LiveReloadConfiguration {\n\n\t\t@Autowired\n\t\tprivate DeveloperToolsProperties properties;\n\n\t\t@Autowired(required = false)\n\t\tprivate LiveReloadServer liveReloadServer;\n\n\t\t@Autowired\n\t\tprivate ClientHttpRequestFactory clientHttpRequestFactory;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\n\t\t@Bean\n\t\t@RestartScope\n\t\t@ConditionalOnMissingBean\n\t\tpublic LiveReloadServer liveReloadServer() {\n\t\t\treturn new LiveReloadServer(this.properties.getLivereload().getPort(),\n\t\t\t\t\tRestarter.getInstance().getThreadFactory());\n\t\t}\n\n\t\t@EventListener\n\t\tpublic void onClassPathChanged(ClassPathChangedEvent event) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath();\n\t\t\tthis.executor.execute(new DelayedLiveReloadTrigger(\n\t\t\t\t\toptionalLiveReloadServer(), this.clientHttpRequestFactory, url));\n\t\t}\n\n\t\t@Bean\n\t\tpublic OptionalLiveReloadServer optionalLiveReloadServer() {\n\t\t\treturn new OptionalLiveReloadServer(this.liveReloadServer);\n\t\t}\n\n\t\tfinal ExecutorService getExecutor() {\n\t\t\treturn this.executor;\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote update and restarts.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.developertools.remote.restart", name = "enabled", matchIfMissing = true)\n\tstatic class RemoteRestartClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DeveloperToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic ClassPathFileSystemWatcher classPathFileSystemWatcher() {\n\t\t\tDefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();\n\t\t\tURL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());\n\t\t\tif (urls == null) {\n\t\t\t\turls = new URL[0];\n\t\t\t}\n\t\t\treturn new ClassPathFileSystemWatcher(classPathRestartStrategy(), urls);\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathRestartStrategy classPathRestartStrategy() {\n\t\t\treturn new PatternClassPathRestartStrategy(this.properties.getRestart()\n\t\t\t\t\t.getExclude());\n\t\t}\n\n\t\t@Bean\n\t\tpublic ClassPathChangeUploader classPathChangeUploader(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tString url = this.remoteUrl + this.properties.getRemote().getContextPath()\n\t\t\t\t\t+ "/restart";\n\t\t\treturn new ClassPathChangeUploader(url, requestFactory);\n\t\t}\n\n\t}\n\n\t/**\n\t * Client configuration for remote debug HTTP tunneling.\n\t */\n\t@ConditionalOnProperty(prefix = "spring.developertools.remote.debug", name = "enabled", matchIfMissing = true)\n\t@ConditionalOnClass(Filter.class)\n\t@Conditional(LocalDebugPortAvailableCondition.class)\n\tstatic class RemoteDebugTunnelClientConfiguration {\n\n\t\t@Autowired\n\t\tprivate DeveloperToolsProperties properties;\n\n\t\t@Value("${remoteUrl}")\n\t\tprivate String remoteUrl;\n\n\t\t@Bean\n\t\tpublic TunnelClient remoteDebugTunnelClient(\n\t\t\t\tClientHttpRequestFactory requestFactory) {\n\t\t\tRemoteDeveloperToolsProperties remoteProperties = this.properties.getRemote();\n\t\t\tString url = this.remoteUrl + remoteProperties.getContextPath() + "/debug";\n\t\t\tTunnelConnection connection = new HttpTunnelConnection(url, requestFactory);\n\t\t\tint localPort = remoteProperties.getDebug().getLocalPort();\n\t\t\tTunnelClient client = new TunnelClient(localPort, connection);\n\t\t\tclient.addListener(new LoggingTunnelClientListener());\n\t\t\treturn client;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
