{'_old_path': PosixPath('spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -1,5 +1,5 @@\n /*\n- * Copyright 2012-2019 the original author or authors.\n+ * Copyright 2012-2020 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the "License");\n  * you may not use this file except in compliance with the License.\n@@ -34,14 +34,7 @@ import com.fasterxml.jackson.databind.Module;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.databind.module.SimpleModule;\n-import com.fasterxml.jackson.datatype.joda.cfg.JacksonJodaDateFormat;\n-import com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\n import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-import org.joda.time.DateTime;\n-import org.joda.time.format.DateTimeFormat;\n \n import org.springframework.beans.BeanUtils;\n import org.springframework.beans.factory.BeanFactoryUtils;\n@@ -110,49 +103,6 @@ public class JacksonAutoConfiguration {\n \n \t}\n \n-\t@Deprecated\n-\t@Configuration(proxyBeanMethods = false)\n-\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class, DateTimeSerializer.class,\n-\t\t\tJacksonJodaDateFormat.class })\n-\tstatic class JodaDateTimeJacksonConfiguration {\n-\n-\t\tprivate static final Log logger = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n-\n-\t\t@Bean\n-\t\tSimpleModule jodaDateTimeSerializationModule(JacksonProperties jacksonProperties) {\n-\t\t\tlogger.warn("Auto-configuration of Jackson\'s Joda-Time integration is deprecated in favor of using "\n-\t\t\t\t\t+ "java.time (JSR-310).");\n-\t\t\tSimpleModule module = new SimpleModule();\n-\t\t\tJacksonJodaDateFormat jacksonJodaFormat = getJacksonJodaDateFormat(jacksonProperties);\n-\t\t\tif (jacksonJodaFormat != null) {\n-\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(jacksonJodaFormat, 0));\n-\t\t\t}\n-\t\t\treturn module;\n-\t\t}\n-\n-\t\tprivate JacksonJodaDateFormat getJacksonJodaDateFormat(JacksonProperties jacksonProperties) {\n-\t\t\tif (jacksonProperties.getJodaDateTimeFormat() != null) {\n-\t\t\t\treturn new JacksonJodaDateFormat(\n-\t\t\t\t\t\tDateTimeFormat.forPattern(jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n-\t\t\t}\n-\t\t\tif (jacksonProperties.getDateFormat() != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\treturn new JacksonJodaDateFormat(\n-\t\t\t\t\t\t\tDateTimeFormat.forPattern(jacksonProperties.getDateFormat()).withZoneUTC());\n-\t\t\t\t}\n-\t\t\t\tcatch (IllegalArgumentException ex) {\n-\t\t\t\t\tif (logger.isWarnEnabled()) {\n-\t\t\t\t\t\tlogger.warn("spring.jackson.date-format could not be used to "\n-\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n-\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as well.");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\n-\t}\n-\n \t@Configuration(proxyBeanMethods = false)\n \t@ConditionalOnClass(ParameterNamesModule.class)\n \tstatic class ParameterNamesModuleConfiguration {\n', 'source_code': '/*\n * Copyright 2012-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\n\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.jackson.JsonComponentModule;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @author Johannes Edmeier\n * @author Phillip Webb\n * @author Eddú Meléndez\n * @since 1.1.0\n */\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(ObjectMapper.class)\npublic class JacksonAutoConfiguration {\n\n\tprivate static final Map<?, Boolean> FEATURE_DEFAULTS;\n\n\tstatic {\n\t\tMap<Object, Boolean> featureDefaults = new HashMap<>();\n\t\tfeatureDefaults.put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\t\tfeatureDefaults.put(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false);\n\t\tFEATURE_DEFAULTS = Collections.unmodifiableMap(featureDefaults);\n\t}\n\n\t@Bean\n\tpublic JsonComponentModule jsonComponentModule() {\n\t\treturn new JsonComponentModule();\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean\n\t\tObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(ParameterNamesModule.class)\n\tstatic class ParameterNamesModuleConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tParameterNamesModule parameterNamesModule() {\n\t\t\treturn new ParameterNamesModule(JsonCreator.Mode.DEFAULT);\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\tstatic class JacksonObjectMapperBuilderConfiguration {\n\n\t\t@Bean\n\t\t@Scope("prototype")\n\t\t@ConditionalOnMissingBean\n\t\tJackson2ObjectMapperBuilder jacksonObjectMapperBuilder(ApplicationContext applicationContext,\n\t\t\t\tList<Jackson2ObjectMapperBuilderCustomizer> customizers) {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(applicationContext);\n\t\t\tcustomize(builder, customizers);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void customize(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tList<Jackson2ObjectMapperBuilderCustomizer> customizers) {\n\t\t\tfor (Jackson2ObjectMapperBuilderCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(builder);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\t@EnableConfigurationProperties(JacksonProperties.class)\n\tstatic class Jackson2ObjectMapperBuilderCustomizerConfiguration {\n\n\t\t@Bean\n\t\tStandardJackson2ObjectMapperBuilderCustomizer standardJacksonObjectMapperBuilderCustomizer(\n\t\t\t\tApplicationContext applicationContext, JacksonProperties jacksonProperties) {\n\t\t\treturn new StandardJackson2ObjectMapperBuilderCustomizer(applicationContext, jacksonProperties);\n\t\t}\n\n\t\tstatic final class StandardJackson2ObjectMapperBuilderCustomizer\n\t\t\t\timplements Jackson2ObjectMapperBuilderCustomizer, Ordered {\n\n\t\t\tprivate final ApplicationContext applicationContext;\n\n\t\t\tprivate final JacksonProperties jacksonProperties;\n\n\t\t\tStandardJackson2ObjectMapperBuilderCustomizer(ApplicationContext applicationContext,\n\t\t\t\t\tJacksonProperties jacksonProperties) {\n\t\t\t\tthis.applicationContext = applicationContext;\n\t\t\t\tthis.jacksonProperties = jacksonProperties;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getOrder() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void customize(Jackson2ObjectMapperBuilder builder) {\n\n\t\t\t\tif (this.jacksonProperties.getDefaultPropertyInclusion() != null) {\n\t\t\t\t\tbuilder.serializationInclusion(this.jacksonProperties.getDefaultPropertyInclusion());\n\t\t\t\t}\n\t\t\t\tif (this.jacksonProperties.getTimeZone() != null) {\n\t\t\t\t\tbuilder.timeZone(this.jacksonProperties.getTimeZone());\n\t\t\t\t}\n\t\t\t\tconfigureFeatures(builder, FEATURE_DEFAULTS);\n\t\t\t\tconfigureVisibility(builder, this.jacksonProperties.getVisibility());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\t\tconfigureDateFormat(builder);\n\t\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\t\tconfigureModules(builder);\n\t\t\t\tconfigureLocale(builder);\n\t\t\t}\n\n\t\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder, Map<?, Boolean> features) {\n\t\t\t\tfeatures.forEach((feature, value) -> {\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tbuilder.featuresToEnable(feature);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.featuresToDisable(feature);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tprivate void configureVisibility(Jackson2ObjectMapperBuilder builder,\n\t\t\t\t\tMap<PropertyAccessor, JsonAutoDetect.Visibility> visibilities) {\n\t\t\t\tvisibilities.forEach(builder::visibility);\n\t\t\t}\n\n\t\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t\t// pattern string value\n\t\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\t\tif (dateFormat != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils.instantiateClass(dateFormatClass));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tSimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);\n\t\t\t\t\t\t// Since Jackson 2.6.3 we always need to set a TimeZone (see\n\t\t\t\t\t\t// gh-4170). If none in our properties fallback to the Jackson\'s\n\t\t\t\t\t\t// default\n\t\t\t\t\t\tTimeZone timeZone = this.jacksonProperties.getTimeZone();\n\t\t\t\t\t\tif (timeZone == null) {\n\t\t\t\t\t\t\ttimeZone = new ObjectMapper().getSerializationConfig().getTimeZone();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsimpleDateFormat.setTimeZone(timeZone);\n\t\t\t\t\t\tbuilder.dateFormat(simpleDateFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t\t// names in PropertyNamingStrategy which hold default provided\n\t\t\t\t// implementations\n\t\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\t\tif (strategy != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder, ClassUtils.forName(strategy, null));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategyClass(Jackson2ObjectMapperBuilder builder,\n\t\t\t\t\tClass<?> propertyNamingStrategyClass) {\n\t\t\t\tbuilder.propertyNamingStrategy(\n\t\t\t\t\t\t(PropertyNamingStrategy) BeanUtils.instantiateClass(propertyNamingStrategyClass));\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategyField(Jackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t\t// that may be added by Jackson in the future)\n\t\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class, fieldName,\n\t\t\t\t\t\tPropertyNamingStrategy.class);\n\t\t\t\tAssert.notNull(field, () -> "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\t\ttry {\n\t\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext, Module.class);\n\t\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[0]));\n\t\t\t}\n\n\t\t\tprivate void configureLocale(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\tLocale locale = this.jacksonProperties.getLocale();\n\t\t\t\tif (locale != null) {\n\t\t\t\t\tbuilder.locale(locale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory, Class<T> type) {\n\t\t\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type).values();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jackson;\n\nimport java.lang.reflect.Field;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.TimeZone;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.Module;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.PropertyNamingStrategy;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport com.fasterxml.jackson.datatype.joda.cfg.JacksonJodaDateFormat;\nimport com.fasterxml.jackson.datatype.joda.ser.DateTimeSerializer;\nimport com.fasterxml.jackson.module.paramnames.ParameterNamesModule;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.joda.time.DateTime;\nimport org.joda.time.format.DateTimeFormat;\n\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.jackson.JsonComponentModule;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Auto configuration for Jackson. The following auto-configuration will get applied:\n * <ul>\n * <li>an {@link ObjectMapper} in case none is already configured.</li>\n * <li>a {@link Jackson2ObjectMapperBuilder} in case none is already configured.</li>\n * <li>auto-registration for all {@link Module} beans with all {@link ObjectMapper} beans\n * (including the defaulted ones).</li>\n * </ul>\n *\n * @author Oliver Gierke\n * @author Andy Wilkinson\n * @author Marcel Overdijk\n * @author Sebastien Deleuze\n * @author Johannes Edmeier\n * @author Phillip Webb\n * @author Eddú Meléndez\n * @since 1.1.0\n */\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(ObjectMapper.class)\npublic class JacksonAutoConfiguration {\n\n\tprivate static final Map<?, Boolean> FEATURE_DEFAULTS;\n\n\tstatic {\n\t\tMap<Object, Boolean> featureDefaults = new HashMap<>();\n\t\tfeatureDefaults.put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n\t\tfeatureDefaults.put(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false);\n\t\tFEATURE_DEFAULTS = Collections.unmodifiableMap(featureDefaults);\n\t}\n\n\t@Bean\n\tpublic JsonComponentModule jsonComponentModule() {\n\t\treturn new JsonComponentModule();\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\tstatic class JacksonObjectMapperConfiguration {\n\n\t\t@Bean\n\t\t@Primary\n\t\t@ConditionalOnMissingBean\n\t\tObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {\n\t\t\treturn builder.createXmlMapper(false).build();\n\t\t}\n\n\t}\n\n\t@Deprecated\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass({ Jackson2ObjectMapperBuilder.class, DateTime.class, DateTimeSerializer.class,\n\t\t\tJacksonJodaDateFormat.class })\n\tstatic class JodaDateTimeJacksonConfiguration {\n\n\t\tprivate static final Log logger = LogFactory.getLog(JodaDateTimeJacksonConfiguration.class);\n\n\t\t@Bean\n\t\tSimpleModule jodaDateTimeSerializationModule(JacksonProperties jacksonProperties) {\n\t\t\tlogger.warn("Auto-configuration of Jackson\'s Joda-Time integration is deprecated in favor of using "\n\t\t\t\t\t+ "java.time (JSR-310).");\n\t\t\tSimpleModule module = new SimpleModule();\n\t\t\tJacksonJodaDateFormat jacksonJodaFormat = getJacksonJodaDateFormat(jacksonProperties);\n\t\t\tif (jacksonJodaFormat != null) {\n\t\t\t\tmodule.addSerializer(DateTime.class, new DateTimeSerializer(jacksonJodaFormat, 0));\n\t\t\t}\n\t\t\treturn module;\n\t\t}\n\n\t\tprivate JacksonJodaDateFormat getJacksonJodaDateFormat(JacksonProperties jacksonProperties) {\n\t\t\tif (jacksonProperties.getJodaDateTimeFormat() != null) {\n\t\t\t\treturn new JacksonJodaDateFormat(\n\t\t\t\t\t\tDateTimeFormat.forPattern(jacksonProperties.getJodaDateTimeFormat()).withZoneUTC());\n\t\t\t}\n\t\t\tif (jacksonProperties.getDateFormat() != null) {\n\t\t\t\ttry {\n\t\t\t\t\treturn new JacksonJodaDateFormat(\n\t\t\t\t\t\t\tDateTimeFormat.forPattern(jacksonProperties.getDateFormat()).withZoneUTC());\n\t\t\t\t}\n\t\t\t\tcatch (IllegalArgumentException ex) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn("spring.jackson.date-format could not be used to "\n\t\t\t\t\t\t\t\t+ "configure formatting of Joda\'s DateTime. You may want "\n\t\t\t\t\t\t\t\t+ "to configure spring.jackson.joda-date-time-format as well.");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(ParameterNamesModule.class)\n\tstatic class ParameterNamesModuleConfiguration {\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tParameterNamesModule parameterNamesModule() {\n\t\t\treturn new ParameterNamesModule(JsonCreator.Mode.DEFAULT);\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\tstatic class JacksonObjectMapperBuilderConfiguration {\n\n\t\t@Bean\n\t\t@Scope("prototype")\n\t\t@ConditionalOnMissingBean\n\t\tJackson2ObjectMapperBuilder jacksonObjectMapperBuilder(ApplicationContext applicationContext,\n\t\t\t\tList<Jackson2ObjectMapperBuilderCustomizer> customizers) {\n\t\t\tJackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();\n\t\t\tbuilder.applicationContext(applicationContext);\n\t\t\tcustomize(builder, customizers);\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate void customize(Jackson2ObjectMapperBuilder builder,\n\t\t\t\tList<Jackson2ObjectMapperBuilderCustomizer> customizers) {\n\t\t\tfor (Jackson2ObjectMapperBuilderCustomizer customizer : customizers) {\n\t\t\t\tcustomizer.customize(builder);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)\n\t@EnableConfigurationProperties(JacksonProperties.class)\n\tstatic class Jackson2ObjectMapperBuilderCustomizerConfiguration {\n\n\t\t@Bean\n\t\tStandardJackson2ObjectMapperBuilderCustomizer standardJacksonObjectMapperBuilderCustomizer(\n\t\t\t\tApplicationContext applicationContext, JacksonProperties jacksonProperties) {\n\t\t\treturn new StandardJackson2ObjectMapperBuilderCustomizer(applicationContext, jacksonProperties);\n\t\t}\n\n\t\tstatic final class StandardJackson2ObjectMapperBuilderCustomizer\n\t\t\t\timplements Jackson2ObjectMapperBuilderCustomizer, Ordered {\n\n\t\t\tprivate final ApplicationContext applicationContext;\n\n\t\t\tprivate final JacksonProperties jacksonProperties;\n\n\t\t\tStandardJackson2ObjectMapperBuilderCustomizer(ApplicationContext applicationContext,\n\t\t\t\t\tJacksonProperties jacksonProperties) {\n\t\t\t\tthis.applicationContext = applicationContext;\n\t\t\t\tthis.jacksonProperties = jacksonProperties;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int getOrder() {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void customize(Jackson2ObjectMapperBuilder builder) {\n\n\t\t\t\tif (this.jacksonProperties.getDefaultPropertyInclusion() != null) {\n\t\t\t\t\tbuilder.serializationInclusion(this.jacksonProperties.getDefaultPropertyInclusion());\n\t\t\t\t}\n\t\t\t\tif (this.jacksonProperties.getTimeZone() != null) {\n\t\t\t\t\tbuilder.timeZone(this.jacksonProperties.getTimeZone());\n\t\t\t\t}\n\t\t\t\tconfigureFeatures(builder, FEATURE_DEFAULTS);\n\t\t\t\tconfigureVisibility(builder, this.jacksonProperties.getVisibility());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getDeserialization());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getSerialization());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getMapper());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getParser());\n\t\t\t\tconfigureFeatures(builder, this.jacksonProperties.getGenerator());\n\t\t\t\tconfigureDateFormat(builder);\n\t\t\t\tconfigurePropertyNamingStrategy(builder);\n\t\t\t\tconfigureModules(builder);\n\t\t\t\tconfigureLocale(builder);\n\t\t\t}\n\n\t\t\tprivate void configureFeatures(Jackson2ObjectMapperBuilder builder, Map<?, Boolean> features) {\n\t\t\t\tfeatures.forEach((feature, value) -> {\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tbuilder.featuresToEnable(feature);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.featuresToDisable(feature);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tprivate void configureVisibility(Jackson2ObjectMapperBuilder builder,\n\t\t\t\t\tMap<PropertyAccessor, JsonAutoDetect.Visibility> visibilities) {\n\t\t\t\tvisibilities.forEach(builder::visibility);\n\t\t\t}\n\n\t\t\tprivate void configureDateFormat(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\t// We support a fully qualified class name extending DateFormat or a date\n\t\t\t\t// pattern string value\n\t\t\t\tString dateFormat = this.jacksonProperties.getDateFormat();\n\t\t\t\tif (dateFormat != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tClass<?> dateFormatClass = ClassUtils.forName(dateFormat, null);\n\t\t\t\t\t\tbuilder.dateFormat((DateFormat) BeanUtils.instantiateClass(dateFormatClass));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tSimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);\n\t\t\t\t\t\t// Since Jackson 2.6.3 we always need to set a TimeZone (see\n\t\t\t\t\t\t// gh-4170). If none in our properties fallback to the Jackson\'s\n\t\t\t\t\t\t// default\n\t\t\t\t\t\tTimeZone timeZone = this.jacksonProperties.getTimeZone();\n\t\t\t\t\t\tif (timeZone == null) {\n\t\t\t\t\t\t\ttimeZone = new ObjectMapper().getSerializationConfig().getTimeZone();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsimpleDateFormat.setTimeZone(timeZone);\n\t\t\t\t\t\tbuilder.dateFormat(simpleDateFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\t// We support a fully qualified class name extending Jackson\'s\n\t\t\t\t// PropertyNamingStrategy or a string value corresponding to the constant\n\t\t\t\t// names in PropertyNamingStrategy which hold default provided\n\t\t\t\t// implementations\n\t\t\t\tString strategy = this.jacksonProperties.getPropertyNamingStrategy();\n\t\t\t\tif (strategy != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconfigurePropertyNamingStrategyClass(builder, ClassUtils.forName(strategy, null));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\t\t\tconfigurePropertyNamingStrategyField(builder, strategy);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategyClass(Jackson2ObjectMapperBuilder builder,\n\t\t\t\t\tClass<?> propertyNamingStrategyClass) {\n\t\t\t\tbuilder.propertyNamingStrategy(\n\t\t\t\t\t\t(PropertyNamingStrategy) BeanUtils.instantiateClass(propertyNamingStrategyClass));\n\t\t\t}\n\n\t\t\tprivate void configurePropertyNamingStrategyField(Jackson2ObjectMapperBuilder builder, String fieldName) {\n\t\t\t\t// Find the field (this way we automatically support new constants\n\t\t\t\t// that may be added by Jackson in the future)\n\t\t\t\tField field = ReflectionUtils.findField(PropertyNamingStrategy.class, fieldName,\n\t\t\t\t\t\tPropertyNamingStrategy.class);\n\t\t\t\tAssert.notNull(field, () -> "Constant named \'" + fieldName + "\' not found on "\n\t\t\t\t\t\t+ PropertyNamingStrategy.class.getName());\n\t\t\t\ttry {\n\t\t\t\t\tbuilder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void configureModules(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\tCollection<Module> moduleBeans = getBeans(this.applicationContext, Module.class);\n\t\t\t\tbuilder.modulesToInstall(moduleBeans.toArray(new Module[0]));\n\t\t\t}\n\n\t\t\tprivate void configureLocale(Jackson2ObjectMapperBuilder builder) {\n\t\t\t\tLocale locale = this.jacksonProperties.getLocale();\n\t\t\t\tif (locale != null) {\n\t\t\t\t\tbuilder.locale(locale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate static <T> Collection<T> getBeans(ListableBeanFactory beanFactory, Class<T> type) {\n\t\t\t\treturn BeanFactoryUtils.beansOfTypeIncludingAncestors(beanFactory, type).values();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
