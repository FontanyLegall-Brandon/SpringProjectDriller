{'_old_path': None, '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/CrshAutoConfiguration.java'), 'change_type': <ModificationType.ADD: 1>, 'diff': '@@ -0,0 +1,462 @@\n+/*\n+ * Copyright 2013 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.boot.actuate.autoconfigure;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+import org.crsh.auth.AuthenticationPlugin;\n+import org.crsh.plugin.CRaSHPlugin;\n+import org.crsh.plugin.PluginContext;\n+import org.crsh.plugin.PluginDiscovery;\n+import org.crsh.plugin.PluginLifeCycle;\n+import org.crsh.plugin.PropertyDescriptor;\n+import org.crsh.plugin.ServiceLoaderDiscovery;\n+import org.crsh.vfs.FS;\n+import org.crsh.vfs.spi.AbstractFSDriver;\n+import org.springframework.beans.factory.ListableBeanFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.actuate.properties.CrshProperties;\n+import org.springframework.boot.actuate.properties.CrshProperties.AuthenticationProperties;\n+import org.springframework.boot.actuate.properties.CrshProperties.JaasAuthenticationProperties;\n+import org.springframework.boot.actuate.properties.CrshProperties.KeyAuthenticationProperties;\n+import org.springframework.boot.actuate.properties.CrshProperties.SimpleAuthenticationProperties;\n+import org.springframework.boot.actuate.properties.CrshProperties.SpringAuthenticationProperties;\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.context.properties.EnableConfigurationProperties;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.SpringVersion;\n+import org.springframework.core.io.Resource;\n+import org.springframework.core.io.support.ResourcePatternResolver;\n+import org.springframework.security.access.AccessDecisionManager;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.access.SecurityConfig;\n+import org.springframework.security.authentication.AuthenticationManager;\n+import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n+import org.springframework.util.Assert;\n+import org.springframework.util.ClassUtils;\n+import org.springframework.util.StringUtils;\n+\n+/**\n+ * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell into a Spring\n+ * Boot enabled application. By default a SSH daemon is started on port 2000 with a default username\n+ * <code>user</code> and password (default password is logged during application startup).\n+ * \n+ * <p>\n+ * This configuration will auto detect the existence of a Spring Security {@link AuthenticationManager}\n+ * and will delegate authentication requests for shell access to this detected instance.\n+ * \n+ * <p>\n+ * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in the\n+ * application context. Those beans will get auto detected during startup and registered with the\n+ * underlying shell infrastructure.\n+ * \n+ * <p>\n+ * Additional shell commands can be implemented using the guide and documentation at \n+ * <a href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands using\n+ * the following classpath scanning pattern <code>classpath*:/commands/**</code>. To add different\n+ * locations or override the default use <code>shell.command_path_patterns</code> in your application\n+ * configuration.\n+ * \n+ * @author Christian Dupuis\n+ */\n+@Configuration\n+@ConditionalOnClass({ PluginLifeCycle.class })\n+@EnableConfigurationProperties({ CrshProperties.class })\n+@AutoConfigureAfter(SecurityAutoConfiguration.class)\n+public class CrshAutoConfiguration {\n+\n+\t@Autowired\n+\tprivate CrshProperties properties;\n+\t\n+\t\n+\t@Bean\n+\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'jaas\'}")\n+\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n+\tpublic AuthenticationProperties jaasAuthenticationProperties() {\n+\t\treturn new JaasAuthenticationProperties();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'key\'}")\n+\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n+\tpublic AuthenticationProperties keyAuthenticationProperties() {\n+\t\treturn new KeyAuthenticationProperties();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'simple\'}")\n+\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n+\tpublic AuthenticationProperties simpleAuthenticationProperties() {\n+\t\treturn new SimpleAuthenticationProperties();\n+\t}\n+\t\n+\t@Bean\n+\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'spring\'}")\n+\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n+\tpublic AuthenticationProperties SpringAuthenticationProperties() {\n+\t\treturn new SpringAuthenticationProperties();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnBean({ AuthenticationManager.class })\n+\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n+\t\treturn new AuthenticationManagerAdapter();\n+\t}\n+\n+\t@Bean\n+\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n+\tpublic PluginLifeCycle shellBootstrap() {\n+\t\tCrshBootstrap bs = new CrshBootstrap();\n+\t\tbs.setConfig(properties.mergeProperties(new Properties()));\n+\t\treturn bs;\n+\t}\n+\n+\n+\tpublic static class CrshBootstrap extends PluginLifeCycle {\n+\t\t\n+\t\t@Autowired\n+\t\tprivate ListableBeanFactory beanFactory;\n+\t\t\n+\t\t@Autowired\n+\t\tprivate CrshProperties properties;\n+\n+\t\t@Autowired\n+\t\tprivate ResourcePatternResolver resourceLoader;\n+\n+\t\t\n+\t\t@PreDestroy\n+\t\tpublic void destroy() {\n+\t\t\tstop();\n+\t\t}\n+\n+\t\t@PostConstruct\n+\t\tpublic void init() throws Exception {\n+\t\t\tFS commandFileSystem = createFileSystem(properties.getCommandPathPatterns());\n+\t\t\tFS confFileSystem = createFileSystem(properties.getConfigPathPatterns());\n+\n+\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(resourceLoader.getClassLoader(),\n+\t\t\t\t\tbeanFactory, properties.getDisabledPlugins());\n+\n+\t\t\tPluginContext context = new PluginContext(discovery, createPluginContextAttributes(), \n+\t\t\t\t\tcommandFileSystem, confFileSystem,\tresourceLoader.getClassLoader());\n+\n+\t\t\tcontext.refresh();\n+\t\t\tstart(context);\n+\t\t}\n+\n+\t\t\n+\t\tprotected FS createFileSystem(String[] pathPatterns) throws IOException, URISyntaxException {\n+\t\t\tAssert.notNull(pathPatterns);\n+\t\t\tFS cmdFS = new FS();\n+\t\t\tfor (String pathPattern : pathPatterns) {\n+\t\t\t\tcmdFS.mount(new SimpleFileSystemDriver(new DirectoryHandle(pathPattern, resourceLoader)));\n+\t\t\t}\n+\t\t\treturn cmdFS;\n+\t\t}\n+\t\t\n+\t\tprotected Map<String, Object> createPluginContextAttributes() {\n+\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n+\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage().getImplementationVersion();\n+\t\t\tif (bootVersion != null) {\n+\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n+\t\t\t}\n+\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n+\t\t\tif (beanFactory != null) {\n+\t\t\t\tattributes.put("spring.beanfactory", beanFactory);\n+\t\t\t}\n+\t\t\treturn attributes;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\n+\t@SuppressWarnings("rawtypes")\n+\tprivate static class AuthenticationManagerAdapter extends CRaSHPlugin<AuthenticationPlugin> implements\n+\t\t\tAuthenticationPlugin<String> {\n+\t\t\n+\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor.create(\n+\t\t\t\t"auth.spring.roles", "ADMIN", "Comma separated list of roles required to access the shell");\n+\t\t\n+\t\n+\t\t@Autowired(required=false)\n+\t\tprivate AccessDecisionManager accessDecisionManager;\n+\t\t\n+\t\t@Autowired\n+\t\tprivate AuthenticationManager authenticationManager;\n+\t\t\n+\t\tprivate String[] roles = new String[] { "ROLE_ADMIN" };\n+\t\t\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean authenticate(String username, String password) throws Exception {\n+\t\t\t// Authenticate first to make credentials are valid\n+\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username, password);\n+\t\t\ttry {\n+\t\t\t\ttoken = authenticationManager.authenticate(token);\n+\t\t\t}\n+\t\t\tcatch (AuthenticationException ae) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n+\t\t\tif (accessDecisionManager != null && token.isAuthenticated() && roles != null) {\n+\t\t\t\ttry {\n+\t\t\t\t\taccessDecisionManager.decide(token, this, SecurityConfig.createList(roles));\n+\t\t\t\t}\n+\t\t\t\tcatch (AccessDeniedException e) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn token.isAuthenticated();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<String> getCredentialType() {\n+\t\t\treturn String.class;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic AuthenticationPlugin<String> getImplementation() {\n+\t\t\treturn this;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn "spring";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void init() {\n+\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n+\t\t\tif (rolesPropertyValue != null) {\n+\t\t\t\tthis.roles = StringUtils.commaDelimitedListToStringArray(rolesPropertyValue);\n+\t\t\t}\n+\t\t}\n+\n+\t\t\n+\t\t@Override\n+\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n+\t\t\treturn Arrays.<PropertyDescriptor<?>>asList(ROLES);\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\t\n+\tprivate static class BeanFactoryFilteringPluginDiscovery extends ServiceLoaderDiscovery {\n+\n+\t\tprivate ListableBeanFactory beanFactory;\n+\t\t\n+\t\tprivate String[] disabledPlugins;\n+\n+\t\t\n+\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader, ListableBeanFactory beanFactory, \n+\t\t\t\tString[] disabledPlugins)\n+\t\t\t\tthrows NullPointerException {\n+\t\t\tsuper(classLoader);\n+\t\t\tthis.beanFactory = beanFactory;\n+\t\t\tthis.disabledPlugins = disabledPlugins;\n+\t\t}\n+\n+\t\t\n+\t\t@Override\n+\t\t@SuppressWarnings("rawtypes")\n+\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n+\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n+\n+\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n+\t\t\t\tif (!shouldFilter(p)) {\n+\t\t\t\t\tplugins.add(p);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tCollection<CRaSHPlugin> springPlugins = beanFactory.getBeansOfType(CRaSHPlugin.class).values();\n+\t\t\tfor (CRaSHPlugin<?> p : springPlugins) {\n+\t\t\t\tif (!shouldFilter(p)) {\n+\t\t\t\t\tplugins.add(p);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\treturn plugins;\n+\t\t}\n+\t\t\n+\t\t\n+\t\t@SuppressWarnings("rawtypes")\n+\t\tprotected boolean shouldFilter(CRaSHPlugin<?> plugin) {\n+\t\t\tAssert.notNull(plugin);\n+\t\t\t\n+\t\t\tSet<Class> classes = ClassUtils.getAllInterfacesAsSet(plugin);\n+\t\t\tclasses.add(plugin.getClass());\n+\t\t\t\n+\t\t\tfor (Class<?> clazz : classes) {\n+\t\t\t\tif (disabledPlugins != null && disabledPlugins.length > 0) {\n+\t\t\t\t\tfor (String disabledPlugin : disabledPlugins) {\n+\t\t\t\t\t\tif (ClassUtils.getShortName(clazz).equalsIgnoreCase(disabledPlugin) \n+\t\t\t\t\t\t\t\t|| ClassUtils.getQualifiedName(clazz).equalsIgnoreCase(disabledPlugin)) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\n+\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n+\n+\t\tprivate ResourceHandle root;\n+\n+\n+\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n+\t\t\tthis.root = handle;\n+\t\t}\n+\n+\t\t\n+\t\t@Override\n+\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle) throws IOException {\n+\t\t\tif (handle instanceof DirectoryHandle) {\n+\t\t\t\treturn ((DirectoryHandle) handle).members();\n+\t\t\t}\n+\t\t\treturn Collections.emptySet();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n+\t\t\tif (handle instanceof FileHandle) {\n+\t\t\t\treturn ((FileHandle) handle).getLastModified();\n+\t\t\t}\n+\t\t\treturn -1;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n+\t\t\treturn handle instanceof DirectoryHandle;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String name(ResourceHandle handle) throws IOException {\n+\t\t\treturn handle.getName();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n+\t\t\tif (handle instanceof FileHandle) {\n+\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream()).iterator();\n+\t\t\t}\n+\t\t\treturn Collections.<InputStream>emptyList().iterator();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ResourceHandle root() throws IOException {\n+\t\t\treturn root;\n+\t\t}\n+\n+\t}\n+\t\n+\t\n+\tprivate static class DirectoryHandle extends ResourceHandle {\n+\n+\t\tprivate ResourcePatternResolver resourceLoader;\n+\n+\n+\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader) {\n+\t\t\tsuper(name);\n+\t\t\tthis.resourceLoader = resourceLoader;\n+\t\t}\n+\n+\t\t\n+\t\tpublic List<ResourceHandle> members() throws IOException {\n+\t\t\tResource[] resources = resourceLoader.getResources(getName());\n+\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n+\t\t\tfor (Resource resource : resources) {\n+\t\t\t\tif (!resource.getURL().getPath().endsWith("/")) {\n+\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn files;\n+\t\t}\n+\n+\t}\n+\t\n+\n+\tprivate static class FileHandle extends ResourceHandle {\n+\n+\t\tprivate Resource resource;\n+\n+\n+\t\tpublic FileHandle(String name, Resource resource) {\n+\t\t\tsuper(name);\n+\t\t\tthis.resource = resource;\n+\t\t}\n+\n+\t\t\n+\t\tpublic InputStream openStream() throws IOException {\n+\t\t\treturn this.resource.getInputStream();\n+\t\t}\n+\t\t\n+\t\tpublic long getLastModified() {\n+\t\t\ttry {\n+\t\t\t\treturn this.resource.lastModified();\n+\t\t\t}\n+\t\t\tcatch (IOException e) {}\n+\t\t\treturn -1;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\n+\tprivate abstract static class ResourceHandle {\n+\n+\t\tprivate String name;\n+\n+\t\t\n+\t\tpublic ResourceHandle(String name) {\n+\t\t\tthis.name = name;\n+\t\t}\n+\n+\t\t\n+\t\tpublic String getName() {\n+\t\t\treturn name;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+}\n', 'source_code': '/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URISyntaxException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\n\nimport org.crsh.auth.AuthenticationPlugin;\nimport org.crsh.plugin.CRaSHPlugin;\nimport org.crsh.plugin.PluginContext;\nimport org.crsh.plugin.PluginDiscovery;\nimport org.crsh.plugin.PluginLifeCycle;\nimport org.crsh.plugin.PropertyDescriptor;\nimport org.crsh.plugin.ServiceLoaderDiscovery;\nimport org.crsh.vfs.FS;\nimport org.crsh.vfs.spi.AbstractFSDriver;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.properties.CrshProperties;\nimport org.springframework.boot.actuate.properties.CrshProperties.AuthenticationProperties;\nimport org.springframework.boot.actuate.properties.CrshProperties.JaasAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.CrshProperties.KeyAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.CrshProperties.SimpleAuthenticationProperties;\nimport org.springframework.boot.actuate.properties.CrshProperties.SpringAuthenticationProperties;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.SpringVersion;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.security.access.AccessDecisionManager;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.access.SecurityConfig;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for embedding an extensible shell into a Spring\n * Boot enabled application. By default a SSH daemon is started on port 2000 with a default username\n * <code>user</code> and password (default password is logged during application startup).\n * \n * <p>\n * This configuration will auto detect the existence of a Spring Security {@link AuthenticationManager}\n * and will delegate authentication requests for shell access to this detected instance.\n * \n * <p>\n * To add customizations to the shell simply define beans of type {@link CRaSHPlugin} in the\n * application context. Those beans will get auto detected during startup and registered with the\n * underlying shell infrastructure.\n * \n * <p>\n * Additional shell commands can be implemented using the guide and documentation at \n * <a href="http://www.crashub.org">crashub.org</a>. By default Boot will search for commands using\n * the following classpath scanning pattern <code>classpath*:/commands/**</code>. To add different\n * locations or override the default use <code>shell.command_path_patterns</code> in your application\n * configuration.\n * \n * @author Christian Dupuis\n */\n@Configuration\n@ConditionalOnClass({ PluginLifeCycle.class })\n@EnableConfigurationProperties({ CrshProperties.class })\n@AutoConfigureAfter(SecurityAutoConfiguration.class)\npublic class CrshAutoConfiguration {\n\n\t@Autowired\n\tprivate CrshProperties properties;\n\t\n\t\n\t@Bean\n\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'jaas\'}")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties jaasAuthenticationProperties() {\n\t\treturn new JaasAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'key\'}")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties keyAuthenticationProperties() {\n\t\treturn new KeyAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'simple\'}")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties simpleAuthenticationProperties() {\n\t\treturn new SimpleAuthenticationProperties();\n\t}\n\t\n\t@Bean\n\t@ConditionalOnExpression("#{environment[\'shell.auth\'] == \'spring\'}")\n\t@ConditionalOnMissingBean({ AuthenticationProperties.class })\n\tpublic AuthenticationProperties SpringAuthenticationProperties() {\n\t\treturn new SpringAuthenticationProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnBean({ AuthenticationManager.class })\n\tpublic CRaSHPlugin<?> shellAuthenticationManager() {\n\t\treturn new AuthenticationManagerAdapter();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean({ PluginLifeCycle.class })\n\tpublic PluginLifeCycle shellBootstrap() {\n\t\tCrshBootstrap bs = new CrshBootstrap();\n\t\tbs.setConfig(properties.mergeProperties(new Properties()));\n\t\treturn bs;\n\t}\n\n\n\tpublic static class CrshBootstrap extends PluginLifeCycle {\n\t\t\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\t\t\n\t\t@Autowired\n\t\tprivate CrshProperties properties;\n\n\t\t@Autowired\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\t\t\n\t\t@PreDestroy\n\t\tpublic void destroy() {\n\t\t\tstop();\n\t\t}\n\n\t\t@PostConstruct\n\t\tpublic void init() throws Exception {\n\t\t\tFS commandFileSystem = createFileSystem(properties.getCommandPathPatterns());\n\t\t\tFS confFileSystem = createFileSystem(properties.getConfigPathPatterns());\n\n\t\t\tPluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery(resourceLoader.getClassLoader(),\n\t\t\t\t\tbeanFactory, properties.getDisabledPlugins());\n\n\t\t\tPluginContext context = new PluginContext(discovery, createPluginContextAttributes(), \n\t\t\t\t\tcommandFileSystem, confFileSystem,\tresourceLoader.getClassLoader());\n\n\t\t\tcontext.refresh();\n\t\t\tstart(context);\n\t\t}\n\n\t\t\n\t\tprotected FS createFileSystem(String[] pathPatterns) throws IOException, URISyntaxException {\n\t\t\tAssert.notNull(pathPatterns);\n\t\t\tFS cmdFS = new FS();\n\t\t\tfor (String pathPattern : pathPatterns) {\n\t\t\t\tcmdFS.mount(new SimpleFileSystemDriver(new DirectoryHandle(pathPattern, resourceLoader)));\n\t\t\t}\n\t\t\treturn cmdFS;\n\t\t}\n\t\t\n\t\tprotected Map<String, Object> createPluginContextAttributes() {\n\t\t\tMap<String, Object> attributes = new HashMap<String, Object>();\n\t\t\tString bootVersion = CrshAutoConfiguration.class.getPackage().getImplementationVersion();\n\t\t\tif (bootVersion != null) {\n\t\t\t\tattributes.put("spring.boot.version", bootVersion);\n\t\t\t}\n\t\t\tattributes.put("spring.version", SpringVersion.getVersion());\n\t\t\tif (beanFactory != null) {\n\t\t\t\tattributes.put("spring.beanfactory", beanFactory);\n\t\t\t}\n\t\t\treturn attributes;\n\t\t}\n\t\t\n\t}\n\t\n\n\t@SuppressWarnings("rawtypes")\n\tprivate static class AuthenticationManagerAdapter extends CRaSHPlugin<AuthenticationPlugin> implements\n\t\t\tAuthenticationPlugin<String> {\n\t\t\n\t\tprivate static final PropertyDescriptor<String> ROLES = PropertyDescriptor.create(\n\t\t\t\t"auth.spring.roles", "ADMIN", "Comma separated list of roles required to access the shell");\n\t\t\n\t\n\t\t@Autowired(required=false)\n\t\tprivate AccessDecisionManager accessDecisionManager;\n\t\t\n\t\t@Autowired\n\t\tprivate AuthenticationManager authenticationManager;\n\t\t\n\t\tprivate String[] roles = new String[] { "ROLE_ADMIN" };\n\t\t\n\t\t\n\t\t@Override\n\t\tpublic boolean authenticate(String username, String password) throws Exception {\n\t\t\t// Authenticate first to make credentials are valid\n\t\t\tAuthentication token = new UsernamePasswordAuthenticationToken(username, password);\n\t\t\ttry {\n\t\t\t\ttoken = authenticationManager.authenticate(token);\n\t\t\t}\n\t\t\tcatch (AuthenticationException ae) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// Test access rights if a Spring Security AccessDecisionManager is installed\n\t\t\tif (accessDecisionManager != null && token.isAuthenticated() && roles != null) {\n\t\t\t\ttry {\n\t\t\t\t\taccessDecisionManager.decide(token, this, SecurityConfig.createList(roles));\n\t\t\t\t}\n\t\t\t\tcatch (AccessDeniedException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn token.isAuthenticated();\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<String> getCredentialType() {\n\t\t\treturn String.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic AuthenticationPlugin<String> getImplementation() {\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn "spring";\n\t\t}\n\n\t\t@Override\n\t\tpublic void init() {\n\t\t\tString rolesPropertyValue = getContext().getProperty(ROLES);\n\t\t\tif (rolesPropertyValue != null) {\n\t\t\t\tthis.roles = StringUtils.commaDelimitedListToStringArray(rolesPropertyValue);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t@Override\n\t\tprotected Iterable<PropertyDescriptor<?>> createConfigurationCapabilities() {\n\t\t\treturn Arrays.<PropertyDescriptor<?>>asList(ROLES);\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tprivate static class BeanFactoryFilteringPluginDiscovery extends ServiceLoaderDiscovery {\n\n\t\tprivate ListableBeanFactory beanFactory;\n\t\t\n\t\tprivate String[] disabledPlugins;\n\n\t\t\n\t\tpublic BeanFactoryFilteringPluginDiscovery(ClassLoader classLoader, ListableBeanFactory beanFactory, \n\t\t\t\tString[] disabledPlugins)\n\t\t\t\tthrows NullPointerException {\n\t\t\tsuper(classLoader);\n\t\t\tthis.beanFactory = beanFactory;\n\t\t\tthis.disabledPlugins = disabledPlugins;\n\t\t}\n\n\t\t\n\t\t@Override\n\t\t@SuppressWarnings("rawtypes")\n\t\tpublic Iterable<CRaSHPlugin<?>> getPlugins() {\n\t\t\tList<CRaSHPlugin<?>> plugins = new ArrayList<CRaSHPlugin<?>>();\n\n\t\t\tfor (CRaSHPlugin<?> p : super.getPlugins()) {\n\t\t\t\tif (!shouldFilter(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCollection<CRaSHPlugin> springPlugins = beanFactory.getBeansOfType(CRaSHPlugin.class).values();\n\t\t\tfor (CRaSHPlugin<?> p : springPlugins) {\n\t\t\t\tif (!shouldFilter(p)) {\n\t\t\t\t\tplugins.add(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn plugins;\n\t\t}\n\t\t\n\t\t\n\t\t@SuppressWarnings("rawtypes")\n\t\tprotected boolean shouldFilter(CRaSHPlugin<?> plugin) {\n\t\t\tAssert.notNull(plugin);\n\t\t\t\n\t\t\tSet<Class> classes = ClassUtils.getAllInterfacesAsSet(plugin);\n\t\t\tclasses.add(plugin.getClass());\n\t\t\t\n\t\t\tfor (Class<?> clazz : classes) {\n\t\t\t\tif (disabledPlugins != null && disabledPlugins.length > 0) {\n\t\t\t\t\tfor (String disabledPlugin : disabledPlugins) {\n\t\t\t\t\t\tif (ClassUtils.getShortName(clazz).equalsIgnoreCase(disabledPlugin) \n\t\t\t\t\t\t\t\t|| ClassUtils.getQualifiedName(clazz).equalsIgnoreCase(disabledPlugin)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\t\n\n\tprivate static class SimpleFileSystemDriver extends AbstractFSDriver<ResourceHandle> {\n\n\t\tprivate ResourceHandle root;\n\n\n\t\tpublic SimpleFileSystemDriver(ResourceHandle handle) {\n\t\t\tthis.root = handle;\n\t\t}\n\n\t\t\n\t\t@Override\n\t\tpublic Iterable<ResourceHandle> children(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof DirectoryHandle) {\n\t\t\t\treturn ((DirectoryHandle) handle).members();\n\t\t\t}\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn ((FileHandle) handle).getLastModified();\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDir(ResourceHandle handle) throws IOException {\n\t\t\treturn handle instanceof DirectoryHandle;\n\t\t}\n\n\t\t@Override\n\t\tpublic String name(ResourceHandle handle) throws IOException {\n\t\t\treturn handle.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<InputStream> open(ResourceHandle handle) throws IOException {\n\t\t\tif (handle instanceof FileHandle) {\n\t\t\t\treturn Collections.singletonList(((FileHandle) handle).openStream()).iterator();\n\t\t\t}\n\t\t\treturn Collections.<InputStream>emptyList().iterator();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResourceHandle root() throws IOException {\n\t\t\treturn root;\n\t\t}\n\n\t}\n\t\n\t\n\tprivate static class DirectoryHandle extends ResourceHandle {\n\n\t\tprivate ResourcePatternResolver resourceLoader;\n\n\n\t\tpublic DirectoryHandle(String name, ResourcePatternResolver resourceLoader) {\n\t\t\tsuper(name);\n\t\t\tthis.resourceLoader = resourceLoader;\n\t\t}\n\n\t\t\n\t\tpublic List<ResourceHandle> members() throws IOException {\n\t\t\tResource[] resources = resourceLoader.getResources(getName());\n\t\t\tList<ResourceHandle> files = new ArrayList<ResourceHandle>();\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (!resource.getURL().getPath().endsWith("/")) {\n\t\t\t\t\tfiles.add(new FileHandle(resource.getFilename(), resource));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn files;\n\t\t}\n\n\t}\n\t\n\n\tprivate static class FileHandle extends ResourceHandle {\n\n\t\tprivate Resource resource;\n\n\n\t\tpublic FileHandle(String name, Resource resource) {\n\t\t\tsuper(name);\n\t\t\tthis.resource = resource;\n\t\t}\n\n\t\t\n\t\tpublic InputStream openStream() throws IOException {\n\t\t\treturn this.resource.getInputStream();\n\t\t}\n\t\t\n\t\tpublic long getLastModified() {\n\t\t\ttry {\n\t\t\t\treturn this.resource.lastModified();\n\t\t\t}\n\t\t\tcatch (IOException e) {}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t}\n\t\n\n\tprivate abstract static class ResourceHandle {\n\n\t\tprivate String name;\n\n\t\t\n\t\tpublic ResourceHandle(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t\t\n\t}\n\t\n}\n', 'source_code_before': None, '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
