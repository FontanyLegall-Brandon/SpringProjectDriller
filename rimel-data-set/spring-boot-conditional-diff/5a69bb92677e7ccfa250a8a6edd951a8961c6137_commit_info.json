{'_old_path': None, '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/HornetQAutoConfiguration.java'), 'change_type': <ModificationType.ADD: 1>, 'diff': '@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2012-2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the "License");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an "AS IS" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.boot.autoconfigure.jms;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.jms.ConnectionFactory;\n+\n+import org.hornetq.api.core.TransportConfiguration;\n+import org.hornetq.api.core.client.HornetQClient;\n+import org.hornetq.api.core.client.ServerLocator;\n+import org.hornetq.api.jms.HornetQJMSClient;\n+import org.hornetq.api.jms.JMSFactoryType;\n+import org.hornetq.core.remoting.impl.invm.InVMConnectorFactory;\n+import org.hornetq.core.remoting.impl.netty.NettyConnectorFactory;\n+import org.hornetq.core.remoting.impl.netty.TransportConstants;\n+import org.hornetq.jms.client.HornetQConnectionFactory;\n+import org.hornetq.jms.server.config.JMSConfiguration;\n+import org.hornetq.jms.server.config.JMSQueueConfiguration;\n+import org.hornetq.jms.server.config.TopicConfiguration;\n+import org.hornetq.jms.server.config.impl.JMSConfigurationImpl;\n+import org.hornetq.jms.server.config.impl.JMSQueueConfigurationImpl;\n+import org.hornetq.jms.server.config.impl.TopicConfigurationImpl;\n+import org.hornetq.jms.server.embedded.EmbeddedJMS;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.autoconfigure.AutoConfigureBefore;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.boot.context.properties.EnableConfigurationProperties;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.AnnotationAwareOrderComparator;\n+import org.springframework.util.ClassUtils;\n+\n+/**\n+ * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration\n+ * Auto-configuration} to integrate with an HornetQ broker. Connect by default to a broker\n+ * available on the local machine with the default settings. If the necessary classes are\n+ * present, the broker can also be embedded in the application itself.\n+ * \n+ * @author Stephane Nicoll\n+ * @since 1.1.0\n+ */\n+@Configuration\n+@AutoConfigureBefore(JmsAutoConfiguration.class)\n+@ConditionalOnClass({ ConnectionFactory.class, HornetQJMSClient.class })\n+@EnableConfigurationProperties(HornetQProperties.class)\n+public class HornetQAutoConfiguration {\n+\n+\tprivate static final String EMBEDDED_JMS_CLASS = "org.hornetq.jms.server.embedded.EmbeddedJMS";\n+\n+\t@Autowired\n+\tprivate HornetQProperties properties;\n+\n+\t/**\n+\t * Create the {@link ConnectionFactory} to use if none is provided. If no\n+\t * {@linkplain HornetQProperties#getMode() mode} has been explicitly set, connect to\n+\t * the embedded server if it has been requested or to a broker available on the local\n+\t * machine with the default settings otherwise.\n+\t */\n+\t@Bean\n+\t@ConditionalOnMissingBean\n+\tpublic ConnectionFactory jmsConnectionFactory() {\n+\t\tHornetQMode mode = this.properties.getMode();\n+\t\tif (mode == null) {\n+\t\t\tmode = deduceMode();\n+\t\t}\n+\t\tif (mode == HornetQMode.EMBEDDED) {\n+\t\t\treturn createEmbeddedConnectionFactory();\n+\t\t}\n+\t\treturn createNativeConnectionFactory();\n+\t}\n+\n+\t/**\n+\t * Deduce the {@link HornetQMode} to use if none has been set.\n+\t */\n+\tprivate HornetQMode deduceMode() {\n+\t\tif (this.properties.getEmbedded().isEnabled()\n+\t\t\t\t&& ClassUtils.isPresent(EMBEDDED_JMS_CLASS, null)) {\n+\t\t\treturn HornetQMode.EMBEDDED;\n+\t\t}\n+\t\treturn HornetQMode.NATIVE;\n+\t}\n+\n+\tprivate ConnectionFactory createEmbeddedConnectionFactory() {\n+\t\ttry {\n+\t\t\tTransportConfiguration transportConfiguration = new TransportConfiguration(\n+\t\t\t\t\tInVMConnectorFactory.class.getName());\n+\t\t\tServerLocator serviceLocator = HornetQClient\n+\t\t\t\t\t.createServerLocatorWithoutHA(transportConfiguration);\n+\t\t\treturn new HornetQConnectionFactory(serviceLocator);\n+\t\t}\n+\t\tcatch (NoClassDefFoundError ex) {\n+\t\t\tthrow new IllegalStateException("Unable to create InVM "\n+\t\t\t\t\t+ "HornetQ connection, ensure that hornet-jms-server.jar "\n+\t\t\t\t\t+ "is in the classpath", ex);\n+\t\t}\n+\t}\n+\n+\tprivate ConnectionFactory createNativeConnectionFactory() {\n+\t\tMap<String, Object> params = new HashMap<String, Object>();\n+\t\tparams.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost());\n+\t\tparams.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort());\n+\t\tTransportConfiguration transportConfiguration = new TransportConfiguration(\n+\t\t\t\tNettyConnectorFactory.class.getName(), params);\n+\t\treturn HornetQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF,\n+\t\t\t\ttransportConfiguration);\n+\t}\n+\n+\t/**\n+\t * Configuration used to create the embedded HornetQ server.\n+\t */\n+\t@Configuration\n+\t@ConditionalOnClass(name = EMBEDDED_JMS_CLASS)\n+\t@ConditionalOnProperty(prefix = "spring.hornetq.embedded", value = "enabled")\n+\tstatic class EmbeddedServerConfiguration {\n+\n+\t\t@Autowired\n+\t\tprivate HornetQProperties properties;\n+\n+\t\t@Autowired(required = false)\n+\t\tprivate List<HornetQConfigurationCustomizer> configurationCustomizers;\n+\n+\t\t@Autowired(required = false)\n+\t\tprivate List<JMSQueueConfiguration> queuesConfiguration;\n+\n+\t\t@Autowired(required = false)\n+\t\tprivate List<TopicConfiguration> topicsConfiguration;\n+\n+\t\t@Bean\n+\t\t@ConditionalOnMissingBean\n+\t\tpublic org.hornetq.core.config.Configuration hornetQConfiguration() {\n+\t\t\treturn new HornetQEmbeddedConfigurationFactory(this.properties)\n+\t\t\t\t\t.createConfiguration();\n+\t\t}\n+\n+\t\t@Bean(initMethod = "start", destroyMethod = "stop")\n+\t\t@ConditionalOnMissingBean\n+\t\tpublic EmbeddedJMS hornetQServer(\n+\t\t\t\torg.hornetq.core.config.Configuration configuration,\n+\t\t\t\tJMSConfiguration jmsConfiguration) {\n+\t\t\tEmbeddedJMS server = new EmbeddedJMS();\n+\t\t\tapplyCustomizers(configuration);\n+\t\t\tserver.setConfiguration(configuration);\n+\t\t\tserver.setJmsConfiguration(jmsConfiguration);\n+\t\t\tserver.setRegistry(new HornetQNoOpBindingRegistry());\n+\t\t\treturn server;\n+\t\t}\n+\n+\t\tprivate void applyCustomizers(org.hornetq.core.config.Configuration configuration) {\n+\t\t\tif (this.configurationCustomizers != null) {\n+\t\t\t\tAnnotationAwareOrderComparator.sort(this.configurationCustomizers);\n+\t\t\t\tfor (HornetQConfigurationCustomizer customizer : this.configurationCustomizers) {\n+\t\t\t\t\tcustomizer.customize(configuration);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Bean\n+\t\t@ConditionalOnMissingBean\n+\t\tpublic JMSConfiguration hornetQJmsConfiguration() {\n+\t\t\tJMSConfiguration configuration = new JMSConfigurationImpl();\n+\t\t\taddAll(configuration.getQueueConfigurations(), this.queuesConfiguration);\n+\t\t\taddAll(configuration.getTopicConfigurations(), this.topicsConfiguration);\n+\t\t\taddQueues(configuration, this.properties.getEmbedded().getQueues());\n+\t\t\taddTopis(configuration, this.properties.getEmbedded().getTopics());\n+\t\t\treturn configuration;\n+\t\t}\n+\n+\t\tprivate <T> void addAll(List<T> list, Collection<? extends T> items) {\n+\t\t\tif (items != null) {\n+\t\t\t\tlist.addAll(items);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void addQueues(JMSConfiguration configuration, String[] queues) {\n+\t\t\tboolean persistent = this.properties.getEmbedded().isPersistent();\n+\t\t\tfor (String queue : queues) {\n+\t\t\t\tconfiguration.getQueueConfigurations().add(\n+\t\t\t\t\t\tnew JMSQueueConfigurationImpl(queue, null, persistent, "/queue/"\n+\t\t\t\t\t\t\t\t+ queue));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void addTopis(JMSConfiguration configuration, String[] topics) {\n+\t\t\tfor (String topic : topics) {\n+\t\t\t\tconfiguration.getTopicConfigurations().add(\n+\t\t\t\t\t\tnew TopicConfigurationImpl(topic, "/topic/" + topic));\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+}\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.jms;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.jms.ConnectionFactory;\n\nimport org.hornetq.api.core.TransportConfiguration;\nimport org.hornetq.api.core.client.HornetQClient;\nimport org.hornetq.api.core.client.ServerLocator;\nimport org.hornetq.api.jms.HornetQJMSClient;\nimport org.hornetq.api.jms.JMSFactoryType;\nimport org.hornetq.core.remoting.impl.invm.InVMConnectorFactory;\nimport org.hornetq.core.remoting.impl.netty.NettyConnectorFactory;\nimport org.hornetq.core.remoting.impl.netty.TransportConstants;\nimport org.hornetq.jms.client.HornetQConnectionFactory;\nimport org.hornetq.jms.server.config.JMSConfiguration;\nimport org.hornetq.jms.server.config.JMSQueueConfiguration;\nimport org.hornetq.jms.server.config.TopicConfiguration;\nimport org.hornetq.jms.server.config.impl.JMSConfigurationImpl;\nimport org.hornetq.jms.server.config.impl.JMSQueueConfigurationImpl;\nimport org.hornetq.jms.server.config.impl.TopicConfigurationImpl;\nimport org.hornetq.jms.server.embedded.EmbeddedJMS;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.util.ClassUtils;\n\n/**\n * {@link org.springframework.boot.autoconfigure.EnableAutoConfiguration\n * Auto-configuration} to integrate with an HornetQ broker. Connect by default to a broker\n * available on the local machine with the default settings. If the necessary classes are\n * present, the broker can also be embedded in the application itself.\n * \n * @author Stephane Nicoll\n * @since 1.1.0\n */\n@Configuration\n@AutoConfigureBefore(JmsAutoConfiguration.class)\n@ConditionalOnClass({ ConnectionFactory.class, HornetQJMSClient.class })\n@EnableConfigurationProperties(HornetQProperties.class)\npublic class HornetQAutoConfiguration {\n\n\tprivate static final String EMBEDDED_JMS_CLASS = "org.hornetq.jms.server.embedded.EmbeddedJMS";\n\n\t@Autowired\n\tprivate HornetQProperties properties;\n\n\t/**\n\t * Create the {@link ConnectionFactory} to use if none is provided. If no\n\t * {@linkplain HornetQProperties#getMode() mode} has been explicitly set, connect to\n\t * the embedded server if it has been requested or to a broker available on the local\n\t * machine with the default settings otherwise.\n\t */\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic ConnectionFactory jmsConnectionFactory() {\n\t\tHornetQMode mode = this.properties.getMode();\n\t\tif (mode == null) {\n\t\t\tmode = deduceMode();\n\t\t}\n\t\tif (mode == HornetQMode.EMBEDDED) {\n\t\t\treturn createEmbeddedConnectionFactory();\n\t\t}\n\t\treturn createNativeConnectionFactory();\n\t}\n\n\t/**\n\t * Deduce the {@link HornetQMode} to use if none has been set.\n\t */\n\tprivate HornetQMode deduceMode() {\n\t\tif (this.properties.getEmbedded().isEnabled()\n\t\t\t\t&& ClassUtils.isPresent(EMBEDDED_JMS_CLASS, null)) {\n\t\t\treturn HornetQMode.EMBEDDED;\n\t\t}\n\t\treturn HornetQMode.NATIVE;\n\t}\n\n\tprivate ConnectionFactory createEmbeddedConnectionFactory() {\n\t\ttry {\n\t\t\tTransportConfiguration transportConfiguration = new TransportConfiguration(\n\t\t\t\t\tInVMConnectorFactory.class.getName());\n\t\t\tServerLocator serviceLocator = HornetQClient\n\t\t\t\t\t.createServerLocatorWithoutHA(transportConfiguration);\n\t\t\treturn new HornetQConnectionFactory(serviceLocator);\n\t\t}\n\t\tcatch (NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException("Unable to create InVM "\n\t\t\t\t\t+ "HornetQ connection, ensure that hornet-jms-server.jar "\n\t\t\t\t\t+ "is in the classpath", ex);\n\t\t}\n\t}\n\n\tprivate ConnectionFactory createNativeConnectionFactory() {\n\t\tMap<String, Object> params = new HashMap<String, Object>();\n\t\tparams.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost());\n\t\tparams.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort());\n\t\tTransportConfiguration transportConfiguration = new TransportConfiguration(\n\t\t\t\tNettyConnectorFactory.class.getName(), params);\n\t\treturn HornetQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF,\n\t\t\t\ttransportConfiguration);\n\t}\n\n\t/**\n\t * Configuration used to create the embedded HornetQ server.\n\t */\n\t@Configuration\n\t@ConditionalOnClass(name = EMBEDDED_JMS_CLASS)\n\t@ConditionalOnProperty(prefix = "spring.hornetq.embedded", value = "enabled")\n\tstatic class EmbeddedServerConfiguration {\n\n\t\t@Autowired\n\t\tprivate HornetQProperties properties;\n\n\t\t@Autowired(required = false)\n\t\tprivate List<HornetQConfigurationCustomizer> configurationCustomizers;\n\n\t\t@Autowired(required = false)\n\t\tprivate List<JMSQueueConfiguration> queuesConfiguration;\n\n\t\t@Autowired(required = false)\n\t\tprivate List<TopicConfiguration> topicsConfiguration;\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic org.hornetq.core.config.Configuration hornetQConfiguration() {\n\t\t\treturn new HornetQEmbeddedConfigurationFactory(this.properties)\n\t\t\t\t\t.createConfiguration();\n\t\t}\n\n\t\t@Bean(initMethod = "start", destroyMethod = "stop")\n\t\t@ConditionalOnMissingBean\n\t\tpublic EmbeddedJMS hornetQServer(\n\t\t\t\torg.hornetq.core.config.Configuration configuration,\n\t\t\t\tJMSConfiguration jmsConfiguration) {\n\t\t\tEmbeddedJMS server = new EmbeddedJMS();\n\t\t\tapplyCustomizers(configuration);\n\t\t\tserver.setConfiguration(configuration);\n\t\t\tserver.setJmsConfiguration(jmsConfiguration);\n\t\t\tserver.setRegistry(new HornetQNoOpBindingRegistry());\n\t\t\treturn server;\n\t\t}\n\n\t\tprivate void applyCustomizers(org.hornetq.core.config.Configuration configuration) {\n\t\t\tif (this.configurationCustomizers != null) {\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.configurationCustomizers);\n\t\t\t\tfor (HornetQConfigurationCustomizer customizer : this.configurationCustomizers) {\n\t\t\t\t\tcustomizer.customize(configuration);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Bean\n\t\t@ConditionalOnMissingBean\n\t\tpublic JMSConfiguration hornetQJmsConfiguration() {\n\t\t\tJMSConfiguration configuration = new JMSConfigurationImpl();\n\t\t\taddAll(configuration.getQueueConfigurations(), this.queuesConfiguration);\n\t\t\taddAll(configuration.getTopicConfigurations(), this.topicsConfiguration);\n\t\t\taddQueues(configuration, this.properties.getEmbedded().getQueues());\n\t\t\taddTopis(configuration, this.properties.getEmbedded().getTopics());\n\t\t\treturn configuration;\n\t\t}\n\n\t\tprivate <T> void addAll(List<T> list, Collection<? extends T> items) {\n\t\t\tif (items != null) {\n\t\t\t\tlist.addAll(items);\n\t\t\t}\n\t\t}\n\n\t\tprivate void addQueues(JMSConfiguration configuration, String[] queues) {\n\t\t\tboolean persistent = this.properties.getEmbedded().isPersistent();\n\t\t\tfor (String queue : queues) {\n\t\t\t\tconfiguration.getQueueConfigurations().add(\n\t\t\t\t\t\tnew JMSQueueConfigurationImpl(queue, null, persistent, "/queue/"\n\t\t\t\t\t\t\t\t+ queue));\n\t\t\t}\n\t\t}\n\n\t\tprivate void addTopis(JMSConfiguration configuration, String[] topics) {\n\t\t\tfor (String topic : topics) {\n\t\t\t\tconfiguration.getTopicConfigurations().add(\n\t\t\t\t\t\tnew TopicConfigurationImpl(topic, "/topic/" + topic));\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': None, '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
