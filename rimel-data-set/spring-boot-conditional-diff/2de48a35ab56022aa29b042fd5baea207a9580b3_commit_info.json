{'_old_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), '_new_path': PosixPath('spring-boot-actuator/src/main/java/org/springframework/boot/actuate/autoconfigure/EndpointWebMvcChildContextConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -24,22 +24,17 @@ import javax.servlet.Filter;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-\n import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.HierarchicalBeanFactory;\n import org.springframework.beans.factory.ListableBeanFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.actuate.autoconfigure.ManagementWebSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;\n import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\n import org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\n import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\n import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\n-import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\n import org.springframework.boot.autoconfigure.condition.SearchStrategy;\n import org.springframework.boot.autoconfigure.hateoas.HypermediaHttpMessageConverterConfiguration;\n import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\n@@ -57,7 +52,6 @@ import org.springframework.core.annotation.AnnotationAwareOrderComparator;\n import org.springframework.hateoas.LinkDiscoverer;\n import org.springframework.hateoas.config.EnableHypermediaSupport;\n import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n-import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n import org.springframework.web.servlet.DispatcherServlet;\n import org.springframework.web.servlet.HandlerAdapter;\n import org.springframework.web.servlet.HandlerExceptionResolver;\n@@ -80,9 +74,6 @@ import org.springframework.web.servlet.config.annotation.EnableWebMvc;\n @Import(ManagementContextConfigurationsImportSelector.class)\n public class EndpointWebMvcChildContextConfiguration {\n \n-\tprivate static Log logger = LogFactory\n-\t\t\t.getLog(EndpointWebMvcChildContextConfiguration.class);\n-\n \t@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n \tpublic DispatcherServlet dispatcherServlet() {\n \t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n@@ -121,19 +112,14 @@ public class EndpointWebMvcChildContextConfiguration {\n \t */\n \t@Bean\n \t@ConditionalOnBean(ErrorAttributes.class)\n-\tpublic ManagementErrorEndpoint errorEndpoint(ServerProperties serverProperties,\n-\t\t\tErrorAttributes errorAttributes) {\n-\t\treturn new ManagementErrorEndpoint(serverProperties.getError().getPath(),\n-\t\t\t\terrorAttributes);\n+\tpublic ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes) {\n+\t\treturn new ManagementErrorEndpoint(errorAttributes);\n \t}\n \n \t/**\n-\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s. See\n-\t * {@link SecureEndpointHandlerMappingConfiguration} for an extended version that also\n-\t * configures the security filter.\n+\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s.\n \t */\n \t@Configuration\n-\t@ConditionalOnMissingClass("org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter")\n \tprotected static class EndpointHandlerMappingConfiguration {\n \n \t\t@Autowired\n@@ -141,45 +127,6 @@ public class EndpointWebMvcChildContextConfiguration {\n \t\t\t\tListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {\n \t\t\t// In a child context we definitely want to see the parent endpoints\n \t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n-\t\t\tpostProcessMapping(beanFactory, mapping);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Hook to allow additional post processing of {@link EndpointHandlerMapping}.\n-\t\t * @param beanFactory the source bean factory\n-\t\t * @param mapping the mapping to customize\n-\t\t */\n-\t\tprotected void postProcessMapping(ListableBeanFactory beanFactory,\n-\t\t\t\tEndpointHandlerMapping mapping) {\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * Extension of {@link EndpointHandlerMappingConfiguration} that also configures the\n-\t * security filter.\n-\t */\n-\t@Configuration\n-\t@ConditionalOnClass(WebSecurityConfigurerAdapter.class)\n-\tprotected static class SecureEndpointHandlerMappingConfiguration\n-\t\t\textends EndpointHandlerMappingConfiguration {\n-\n-\t\t@Override\n-\t\tprotected void postProcessMapping(ListableBeanFactory beanFactory,\n-\t\t\t\tEndpointHandlerMapping mapping) {\n-\t\t\t// The parent context has the security filter, so we need to get it injected\n-\t\t\t// with our EndpointHandlerMapping if we can.\n-\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n-\t\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n-\t\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n-\t\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n-\t\t\t\tbean.setEndpointHandlerMapping(mapping);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tlogger.warn("No single bean of type "\n-\t\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n-\t\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n-\t\t\t}\n \t\t}\n \n \t}\n', 'source_code': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaHttpMessageConverterConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.context.embedded.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.hateoas.LinkDiscoverer;\nimport org.springframework.hateoas.config.EnableHypermediaSupport;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.HandlerExecutionChain;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\n@EnableWebMvc\n@Import(ManagementContextConfigurationsImportSelector.class)\npublic class EndpointWebMvcChildContextConfiguration {\n\n\t@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)\n\tpublic CompositeHandlerMapping compositeHandlerMapping() {\n\t\treturn new CompositeHandlerMapping();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)\n\tpublic CompositeHandlerAdapter compositeHandlerAdapter() {\n\t\treturn new CompositeHandlerAdapter();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)\n\tpublic CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {\n\t\treturn new CompositeHandlerExceptionResolver();\n\t}\n\n\t@Bean\n\tpublic ServerCustomization serverCustomization() {\n\t\treturn new ServerCustomization();\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.\n\t * So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\t@ConditionalOnBean(ErrorAttributes.class)\n\tpublic ManagementErrorEndpoint errorEndpoint(ErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(errorAttributes);\n\t}\n\n\t/**\n\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s.\n\t */\n\t@Configuration\n\tprotected static class EndpointHandlerMappingConfiguration {\n\n\t\t@Autowired\n\t\tpublic void handlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {\n\t\t\t// In a child context we definitely want to see the parent endpoints\n\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ LinkDiscoverer.class })\n\t@Import(HypermediaHttpMessageConverterConfiguration.class)\n\t@EnableHypermediaSupport(type = EnableHypermediaSupport.HypermediaType.HAL)\n\tstatic class HypermediaConfiguration {\n\n\t}\n\n\tstatic class ServerCustomization\n\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage>emptySet());\n\t\t\t// and the context path\n\t\t\tcontainer.setContextPath("");\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.server.getError().getPath()));\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerMapping implements HandlerMapping {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerMapping> mappings;\n\n\t\t@Override\n\t\tpublic HandlerExecutionChain getHandler(HttpServletRequest request)\n\t\t\t\tthrows Exception {\n\t\t\tif (this.mappings == null) {\n\t\t\t\tthis.mappings = extractMappings();\n\t\t\t}\n\t\t\tfor (HandlerMapping mapping : this.mappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate List<HandlerMapping> extractMappings() {\n\t\t\tList<HandlerMapping> list = new ArrayList<HandlerMapping>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerMapping.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerAdapter implements HandlerAdapter {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerAdapter> adapters;\n\n\t\tprivate List<HandlerAdapter> extractAdapters() {\n\t\t\tList<HandlerAdapter> list = new ArrayList<HandlerAdapter>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supports(Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView handle(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler) throws Exception {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.handle(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.getLastModified(request, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerExceptionResolver implements HandlerExceptionResolver {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerExceptionResolver> resolvers;\n\n\t\tprivate List<HandlerExceptionResolver> extractResolvers() {\n\t\t\tList<HandlerExceptionResolver> list = new ArrayList<HandlerExceptionResolver>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerExceptionResolver.class)\n\t\t\t\t\t.values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView resolveException(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler, Exception ex) {\n\t\t\tif (this.resolvers == null) {\n\t\t\t\tthis.resolvers = extractResolvers();\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver mapping : this.resolvers) {\n\t\t\t\tModelAndView mav = mapping.resolveException(request, response, handler,\n\t\t\t\t\t\tex);\n\t\t\t\tif (mav != null) {\n\t\t\t\t\treturn mav;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.autoconfigure;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.servlet.Filter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryUtils;\nimport org.springframework.beans.factory.HierarchicalBeanFactory;\nimport org.springframework.beans.factory.ListableBeanFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.actuate.autoconfigure.ManagementWebSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;\nimport org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;\nimport org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;\nimport org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;\nimport org.springframework.boot.autoconfigure.condition.SearchStrategy;\nimport org.springframework.boot.autoconfigure.hateoas.HypermediaHttpMessageConverterConfiguration;\nimport org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;\nimport org.springframework.boot.autoconfigure.web.ErrorAttributes;\nimport org.springframework.boot.autoconfigure.web.ServerProperties;\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.boot.context.embedded.ErrorPage;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.hateoas.LinkDiscoverer;\nimport org.springframework.hateoas.config.EnableHypermediaSupport;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.HandlerAdapter;\nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.HandlerExecutionChain;\nimport org.springframework.web.servlet.HandlerMapping;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n/**\n * Configuration triggered from {@link EndpointWebMvcAutoConfiguration} when a new\n * {@link EmbeddedServletContainer} running on a different port is required.\n *\n * @author Dave Syer\n * @author Stephane Nicoll\n * @author Andy Wilkinson\n * @see EndpointWebMvcAutoConfiguration\n */\n@Configuration\n@EnableWebMvc\n@Import(ManagementContextConfigurationsImportSelector.class)\npublic class EndpointWebMvcChildContextConfiguration {\n\n\tprivate static Log logger = LogFactory\n\t\t\t.getLog(EndpointWebMvcChildContextConfiguration.class);\n\n\t@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n\tpublic DispatcherServlet dispatcherServlet() {\n\t\tDispatcherServlet dispatcherServlet = new DispatcherServlet();\n\t\t// Ensure the parent configuration does not leak down to us\n\t\tdispatcherServlet.setDetectAllHandlerAdapters(false);\n\t\tdispatcherServlet.setDetectAllHandlerExceptionResolvers(false);\n\t\tdispatcherServlet.setDetectAllHandlerMappings(false);\n\t\tdispatcherServlet.setDetectAllViewResolvers(false);\n\t\treturn dispatcherServlet;\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)\n\tpublic CompositeHandlerMapping compositeHandlerMapping() {\n\t\treturn new CompositeHandlerMapping();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)\n\tpublic CompositeHandlerAdapter compositeHandlerAdapter() {\n\t\treturn new CompositeHandlerAdapter();\n\t}\n\n\t@Bean(name = DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)\n\tpublic CompositeHandlerExceptionResolver compositeHandlerExceptionResolver() {\n\t\treturn new CompositeHandlerExceptionResolver();\n\t}\n\n\t@Bean\n\tpublic ServerCustomization serverCustomization() {\n\t\treturn new ServerCustomization();\n\t}\n\n\t/*\n\t * The error controller is present but not mapped as an endpoint in this context\n\t * because of the DispatcherServlet having had its HandlerMapping explicitly disabled.\n\t * So we expose the same feature but only for machine endpoints.\n\t */\n\t@Bean\n\t@ConditionalOnBean(ErrorAttributes.class)\n\tpublic ManagementErrorEndpoint errorEndpoint(ServerProperties serverProperties,\n\t\t\tErrorAttributes errorAttributes) {\n\t\treturn new ManagementErrorEndpoint(serverProperties.getError().getPath(),\n\t\t\t\terrorAttributes);\n\t}\n\n\t/**\n\t * Configuration to add {@link HandlerMapping} for {@link MvcEndpoint}s. See\n\t * {@link SecureEndpointHandlerMappingConfiguration} for an extended version that also\n\t * configures the security filter.\n\t */\n\t@Configuration\n\t@ConditionalOnMissingClass("org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter")\n\tprotected static class EndpointHandlerMappingConfiguration {\n\n\t\t@Autowired\n\t\tpublic void handlerMapping(MvcEndpoints endpoints,\n\t\t\t\tListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {\n\t\t\t// In a child context we definitely want to see the parent endpoints\n\t\t\tmapping.setDetectHandlerMethodsInAncestorContexts(true);\n\t\t\tpostProcessMapping(beanFactory, mapping);\n\t\t}\n\n\t\t/**\n\t\t * Hook to allow additional post processing of {@link EndpointHandlerMapping}.\n\t\t * @param beanFactory the source bean factory\n\t\t * @param mapping the mapping to customize\n\t\t */\n\t\tprotected void postProcessMapping(ListableBeanFactory beanFactory,\n\t\t\t\tEndpointHandlerMapping mapping) {\n\t\t}\n\n\t}\n\n\t/**\n\t * Extension of {@link EndpointHandlerMappingConfiguration} that also configures the\n\t * security filter.\n\t */\n\t@Configuration\n\t@ConditionalOnClass(WebSecurityConfigurerAdapter.class)\n\tprotected static class SecureEndpointHandlerMappingConfiguration\n\t\t\textends EndpointHandlerMappingConfiguration {\n\n\t\t@Override\n\t\tprotected void postProcessMapping(ListableBeanFactory beanFactory,\n\t\t\t\tEndpointHandlerMapping mapping) {\n\t\t\t// The parent context has the security filter, so we need to get it injected\n\t\t\t// with our EndpointHandlerMapping if we can.\n\t\t\tif (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,\n\t\t\t\t\tManagementWebSecurityConfigurerAdapter.class).length == 1) {\n\t\t\t\tManagementWebSecurityConfigurerAdapter bean = beanFactory\n\t\t\t\t\t\t.getBean(ManagementWebSecurityConfigurerAdapter.class);\n\t\t\t\tbean.setEndpointHandlerMapping(mapping);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn("No single bean of type "\n\t\t\t\t\t\t+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()\n\t\t\t\t\t\t+ " found (this might make some endpoints inaccessible without authentication)");\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })\n\t@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)\n\tpublic static class EndpointWebMvcChildContextSecurityConfiguration {\n\n\t\t@Bean\n\t\tpublic Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {\n\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n\t\t\treturn parent.getBean("springSecurityFilterChain", Filter.class);\n\t\t}\n\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass({ LinkDiscoverer.class })\n\t@Import(HypermediaHttpMessageConverterConfiguration.class)\n\t@EnableHypermediaSupport(type = EnableHypermediaSupport.HypermediaType.HAL)\n\tstatic class HypermediaConfiguration {\n\n\t}\n\n\tstatic class ServerCustomization\n\t\t\timplements EmbeddedServletContainerCustomizer, Ordered {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\t// This needs to be lazily initialized because EmbeddedServletContainerCustomizer\n\t\t// instances get their callback very early in the context lifecycle.\n\t\tprivate ManagementServerProperties managementServerProperties;\n\n\t\tprivate ServerProperties server;\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n\t\t\tif (this.managementServerProperties == null) {\n\t\t\t\tthis.managementServerProperties = BeanFactoryUtils\n\t\t\t\t\t\t.beanOfTypeIncludingAncestors(this.beanFactory,\n\t\t\t\t\t\t\t\tManagementServerProperties.class);\n\t\t\t\tthis.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(\n\t\t\t\t\t\tthis.beanFactory, ServerProperties.class);\n\t\t\t}\n\t\t\t// Customize as per the parent context first (so e.g. the access logs go to\n\t\t\t// the same place)\n\t\t\tthis.server.customize(container);\n\t\t\t// Then reset the error pages\n\t\t\tcontainer.setErrorPages(Collections.<ErrorPage>emptySet());\n\t\t\t// and the context path\n\t\t\tcontainer.setContextPath("");\n\t\t\t// and add the management-specific bits\n\t\t\tcontainer.setPort(this.managementServerProperties.getPort());\n\t\t\tcontainer.setAddress(this.managementServerProperties.getAddress());\n\t\t\tcontainer.addErrorPages(new ErrorPage(this.server.getError().getPath()));\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerMapping implements HandlerMapping {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerMapping> mappings;\n\n\t\t@Override\n\t\tpublic HandlerExecutionChain getHandler(HttpServletRequest request)\n\t\t\t\tthrows Exception {\n\t\t\tif (this.mappings == null) {\n\t\t\t\tthis.mappings = extractMappings();\n\t\t\t}\n\t\t\tfor (HandlerMapping mapping : this.mappings) {\n\t\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\n\t\t\t\tif (handler != null) {\n\t\t\t\t\treturn handler;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate List<HandlerMapping> extractMappings() {\n\t\t\tList<HandlerMapping> list = new ArrayList<HandlerMapping>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerMapping.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerAdapter implements HandlerAdapter {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerAdapter> adapters;\n\n\t\tprivate List<HandlerAdapter> extractAdapters() {\n\t\t\tList<HandlerAdapter> list = new ArrayList<HandlerAdapter>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean supports(Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView handle(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler) throws Exception {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.handle(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\t\tif (this.adapters == null) {\n\t\t\t\tthis.adapters = extractAdapters();\n\t\t\t}\n\t\t\tfor (HandlerAdapter mapping : this.adapters) {\n\t\t\t\tif (mapping.supports(handler)) {\n\t\t\t\t\treturn mapping.getLastModified(request, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\tstatic class CompositeHandlerExceptionResolver implements HandlerExceptionResolver {\n\n\t\t@Autowired\n\t\tprivate ListableBeanFactory beanFactory;\n\n\t\tprivate List<HandlerExceptionResolver> resolvers;\n\n\t\tprivate List<HandlerExceptionResolver> extractResolvers() {\n\t\t\tList<HandlerExceptionResolver> list = new ArrayList<HandlerExceptionResolver>();\n\t\t\tlist.addAll(this.beanFactory.getBeansOfType(HandlerExceptionResolver.class)\n\t\t\t\t\t.values());\n\t\t\tlist.remove(this);\n\t\t\tAnnotationAwareOrderComparator.sort(list);\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic ModelAndView resolveException(HttpServletRequest request,\n\t\t\t\tHttpServletResponse response, Object handler, Exception ex) {\n\t\t\tif (this.resolvers == null) {\n\t\t\t\tthis.resolvers = extractResolvers();\n\t\t\t}\n\t\t\tfor (HandlerExceptionResolver mapping : this.resolvers) {\n\t\t\t\tModelAndView mav = mapping.resolveException(request, response, handler,\n\t\t\t\t\t\tex);\n\t\t\t\tif (mav != null) {\n\t\t\t\t\treturn mav;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
