{'_old_path': PosixPath('spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/jdbc/TestDatabaseAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/jdbc/TestDatabaseAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -31,22 +31,16 @@ import org.springframework.beans.factory.support.BeanDefinitionRegistry;\n import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\n import org.springframework.beans.factory.support.RootBeanDefinition;\n import org.springframework.boot.autoconfigure.AutoConfigureBefore;\n-import org.springframework.boot.autoconfigure.condition.ConditionMessage;\n-import org.springframework.boot.autoconfigure.condition.ConditionOutcome;\n import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n-import org.springframework.boot.autoconfigure.condition.SpringBootCondition;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\n import org.springframework.boot.autoconfigure.jdbc.EmbeddedDatabaseConnection;\n-import org.springframework.boot.bind.RelaxedPropertyResolver;\n import org.springframework.context.EnvironmentAware;\n import org.springframework.context.annotation.Bean;\n-import org.springframework.context.annotation.ConditionContext;\n-import org.springframework.context.annotation.Conditional;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.core.Ordered;\n import org.springframework.core.annotation.Order;\n import org.springframework.core.env.Environment;\n-import org.springframework.core.type.AnnotatedTypeMetadata;\n import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;\n import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;\n import org.springframework.util.Assert;\n@@ -56,7 +50,6 @@ import org.springframework.util.ObjectUtils;\n  * Auto-configuration for a test database.\n  *\n  * @author Phillip Webb\n- * @author Eddú Meléndez\n  * @since 1.4.0\n  * @see AutoConfigureTestDatabase\n  */\n@@ -64,9 +57,6 @@ import org.springframework.util.ObjectUtils;\n @AutoConfigureBefore(DataSourceAutoConfiguration.class)\n public class TestDatabaseAutoConfiguration {\n \n-\tprivate static final String SPRING_TEST_DATABASE_PREFIX = "spring.test.database.";\n-\tprivate static final String REPLACE_PROPERTY = "replace";\n-\n \tprivate final Environment environment;\n \n \tTestDatabaseAutoConfiguration(Environment environment) {\n@@ -74,55 +64,18 @@ public class TestDatabaseAutoConfiguration {\n \t}\n \n \t@Bean\n-\t@Conditional(TestDatabaseReplaceAutoConfiguredCondition.class)\n+\t@ConditionalOnProperty(prefix = "spring.test.database", name = "replace", havingValue = "AUTO_CONFIGURED")\n \t@ConditionalOnMissingBean\n \tpublic DataSource dataSource() {\n \t\treturn new EmbeddedDataSourceFactory(this.environment).getEmbeddedDatabase();\n \t}\n \n \t@Bean\n-\t@Conditional(TestDatabaseReplaceAnyCondition.class)\n+\t@ConditionalOnProperty(prefix = "spring.test.database", name = "replace", havingValue = "ANY", matchIfMissing = true)\n \tpublic static EmbeddedDataSourceBeanFactoryPostProcessor embeddedDataSourceBeanFactoryPostProcessor() {\n \t\treturn new EmbeddedDataSourceBeanFactoryPostProcessor();\n \t}\n \n-\tstatic class TestDatabaseReplaceAutoConfiguredCondition extends SpringBootCondition {\n-\n-\t\t@Override\n-\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata\n-\t\t\t\tmetadata) {\n-\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(context.getEnvironment(), SPRING_TEST_DATABASE_PREFIX);\n-\t\t\tConditionMessage.Builder message = ConditionMessage\n-\t\t\t\t\t.forCondition("Test Database Replace Property");\n-\t\t\tif (resolver.containsProperty(REPLACE_PROPERTY) && "NONE".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n-\t\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("NONE").atAll());\n-\t\t\t}\n-\t\t\telse if (resolver.containsProperty(REPLACE_PROPERTY) && "AUTO_CONFIGURED".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n-\t\t\t\treturn ConditionOutcome.match(message.found("AUTO_CONFIGURED").atAll());\n-\t\t\t}\n-\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("spring.test.database.replace").atAll());\n-\t\t}\n-\n-\t}\n-\n-\tstatic class TestDatabaseReplaceAnyCondition extends SpringBootCondition {\n-\n-\t\t@Override\n-\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n-\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(context.getEnvironment(), SPRING_TEST_DATABASE_PREFIX);\n-\t\t\tConditionMessage.Builder message = ConditionMessage\n-\t\t\t\t\t.forCondition("Test Database Replace Property");\n-\t\t\tif (resolver.containsProperty(REPLACE_PROPERTY) && "NONE".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n-\t\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("NONE").atAll());\n-\t\t\t}\n-\t\t\telse if (!resolver.containsProperty(REPLACE_PROPERTY) || "ANY".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n-\t\t\t\treturn ConditionOutcome.match(message.found("ANY").atAll());\n-\t\t\t}\n-\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("spring.test.database.replace").atAll());\n-\t\t}\n-\n-\t}\n-\n \t@Order(Ordered.LOWEST_PRECEDENCE)\n \tprivate static class EmbeddedDataSourceBeanFactoryPostProcessor\n \t\t\timplements BeanDefinitionRegistryPostProcessor {\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.test.autoconfigure.jdbc;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.EmbeddedDatabaseConnection;\nimport org.springframework.context.EnvironmentAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.env.Environment;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Auto-configuration for a test database.\n *\n * @author Phillip Webb\n * @since 1.4.0\n * @see AutoConfigureTestDatabase\n */\n@Configuration\n@AutoConfigureBefore(DataSourceAutoConfiguration.class)\npublic class TestDatabaseAutoConfiguration {\n\n\tprivate final Environment environment;\n\n\tTestDatabaseAutoConfiguration(Environment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t@Bean\n\t@ConditionalOnProperty(prefix = "spring.test.database", name = "replace", havingValue = "AUTO_CONFIGURED")\n\t@ConditionalOnMissingBean\n\tpublic DataSource dataSource() {\n\t\treturn new EmbeddedDataSourceFactory(this.environment).getEmbeddedDatabase();\n\t}\n\n\t@Bean\n\t@ConditionalOnProperty(prefix = "spring.test.database", name = "replace", havingValue = "ANY", matchIfMissing = true)\n\tpublic static EmbeddedDataSourceBeanFactoryPostProcessor embeddedDataSourceBeanFactoryPostProcessor() {\n\t\treturn new EmbeddedDataSourceBeanFactoryPostProcessor();\n\t}\n\n\t@Order(Ordered.LOWEST_PRECEDENCE)\n\tprivate static class EmbeddedDataSourceBeanFactoryPostProcessor\n\t\t\timplements BeanDefinitionRegistryPostProcessor {\n\n\t\tprivate static final Log logger = LogFactory\n\t\t\t\t.getLog(EmbeddedDataSourceBeanFactoryPostProcessor.class);\n\n\t\t@Override\n\t\tpublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)\n\t\t\t\tthrows BeansException {\n\t\t\tAssert.isInstanceOf(ConfigurableListableBeanFactory.class, registry,\n\t\t\t\t\t"Test Database Auto-configuration can only be "\n\t\t\t\t\t\t\t+ "used with a ConfigurableListableBeanFactory");\n\t\t\tprocess(registry, (ConfigurableListableBeanFactory) registry);\n\t\t}\n\n\t\t@Override\n\t\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n\t\t\t\tthrows BeansException {\n\t\t}\n\n\t\tprivate void process(BeanDefinitionRegistry registry,\n\t\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\t\tBeanDefinitionHolder holder = getDataSourceBeanDefinition(beanFactory);\n\t\t\tif (holder != null) {\n\t\t\t\tString beanName = holder.getBeanName();\n\t\t\t\tboolean primary = holder.getBeanDefinition().isPrimary();\n\t\t\t\tlogger.info("Replacing \'" + beanName + "\' DataSource bean with "\n\t\t\t\t\t\t+ (primary ? "primary " : "") + "embedded version");\n\t\t\t\tregistry.registerBeanDefinition(beanName,\n\t\t\t\t\t\tcreateEmbeddedBeanDefinition(primary));\n\t\t\t}\n\t\t}\n\n\t\tprivate BeanDefinition createEmbeddedBeanDefinition(boolean primary) {\n\t\t\tBeanDefinition beanDefinition = new RootBeanDefinition(\n\t\t\t\t\tEmbeddedDataSourceFactoryBean.class);\n\t\t\tbeanDefinition.setPrimary(primary);\n\t\t\treturn beanDefinition;\n\t\t}\n\n\t\tprivate BeanDefinitionHolder getDataSourceBeanDefinition(\n\t\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\t\tString[] beanNames = beanFactory.getBeanNamesForType(DataSource.class);\n\t\t\tif (ObjectUtils.isEmpty(beanNames)) {\n\t\t\t\tlogger.warn("No DataSource beans found, "\n\t\t\t\t\t\t+ "embedded version will not be used");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (beanNames.length == 1) {\n\t\t\t\tString beanName = beanNames[0];\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName);\n\t\t\t}\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.warn("No primary DataSource found, "\n\t\t\t\t\t+ "embedded version will not be used");\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tprivate static class EmbeddedDataSourceFactoryBean\n\t\t\timplements FactoryBean<DataSource>, EnvironmentAware, InitializingBean {\n\n\t\tprivate EmbeddedDataSourceFactory factory;\n\n\t\tprivate EmbeddedDatabase embeddedDatabase;\n\n\t\t@Override\n\t\tpublic void setEnvironment(Environment environment) {\n\t\t\tthis.factory = new EmbeddedDataSourceFactory(environment);\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterPropertiesSet() throws Exception {\n\t\t\tthis.embeddedDatabase = this.factory.getEmbeddedDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataSource getObject() throws Exception {\n\t\t\treturn this.embeddedDatabase;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getObjectType() {\n\t\t\treturn EmbeddedDatabase.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isSingleton() {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tprivate static class EmbeddedDataSourceFactory {\n\n\t\tprivate final Environment environment;\n\n\t\tEmbeddedDataSourceFactory(Environment environment) {\n\t\t\tthis.environment = environment;\n\t\t}\n\n\t\tpublic EmbeddedDatabase getEmbeddedDatabase() {\n\t\t\tEmbeddedDatabaseConnection connection = this.environment.getProperty(\n\t\t\t\t\t"spring.test.database.connection", EmbeddedDatabaseConnection.class,\n\t\t\t\t\tEmbeddedDatabaseConnection.NONE);\n\t\t\tif (EmbeddedDatabaseConnection.NONE.equals(connection)) {\n\t\t\t\tconnection = EmbeddedDatabaseConnection.get(getClass().getClassLoader());\n\t\t\t}\n\t\t\tAssert.state(connection != EmbeddedDatabaseConnection.NONE,\n\t\t\t\t\t"Cannot determine embedded database for tests. If you want "\n\t\t\t\t\t\t\t+ "an embedded database please put a supported one "\n\t\t\t\t\t\t\t+ "on the classpath.");\n\t\t\treturn new EmbeddedDatabaseBuilder().generateUniqueName(true)\n\t\t\t\t\t.setType(connection.getType()).build();\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.test.autoconfigure.jdbc;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanDefinitionHolder;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.condition.ConditionMessage;\nimport org.springframework.boot.autoconfigure.condition.ConditionOutcome;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.SpringBootCondition;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.boot.autoconfigure.jdbc.EmbeddedDatabaseConnection;\nimport org.springframework.boot.bind.RelaxedPropertyResolver;\nimport org.springframework.context.EnvironmentAware;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ConditionContext;\nimport org.springframework.context.annotation.Conditional;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.type.AnnotatedTypeMetadata;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;\nimport org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Auto-configuration for a test database.\n *\n * @author Phillip Webb\n * @author Eddú Meléndez\n * @since 1.4.0\n * @see AutoConfigureTestDatabase\n */\n@Configuration\n@AutoConfigureBefore(DataSourceAutoConfiguration.class)\npublic class TestDatabaseAutoConfiguration {\n\n\tprivate static final String SPRING_TEST_DATABASE_PREFIX = "spring.test.database.";\n\tprivate static final String REPLACE_PROPERTY = "replace";\n\n\tprivate final Environment environment;\n\n\tTestDatabaseAutoConfiguration(Environment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t@Bean\n\t@Conditional(TestDatabaseReplaceAutoConfiguredCondition.class)\n\t@ConditionalOnMissingBean\n\tpublic DataSource dataSource() {\n\t\treturn new EmbeddedDataSourceFactory(this.environment).getEmbeddedDatabase();\n\t}\n\n\t@Bean\n\t@Conditional(TestDatabaseReplaceAnyCondition.class)\n\tpublic static EmbeddedDataSourceBeanFactoryPostProcessor embeddedDataSourceBeanFactoryPostProcessor() {\n\t\treturn new EmbeddedDataSourceBeanFactoryPostProcessor();\n\t}\n\n\tstatic class TestDatabaseReplaceAutoConfiguredCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata\n\t\t\t\tmetadata) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(context.getEnvironment(), SPRING_TEST_DATABASE_PREFIX);\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("Test Database Replace Property");\n\t\t\tif (resolver.containsProperty(REPLACE_PROPERTY) && "NONE".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n\t\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("NONE").atAll());\n\t\t\t}\n\t\t\telse if (resolver.containsProperty(REPLACE_PROPERTY) && "AUTO_CONFIGURED".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n\t\t\t\treturn ConditionOutcome.match(message.found("AUTO_CONFIGURED").atAll());\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("spring.test.database.replace").atAll());\n\t\t}\n\n\t}\n\n\tstatic class TestDatabaseReplaceAnyCondition extends SpringBootCondition {\n\n\t\t@Override\n\t\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\t\tRelaxedPropertyResolver resolver = new RelaxedPropertyResolver(context.getEnvironment(), SPRING_TEST_DATABASE_PREFIX);\n\t\t\tConditionMessage.Builder message = ConditionMessage\n\t\t\t\t\t.forCondition("Test Database Replace Property");\n\t\t\tif (resolver.containsProperty(REPLACE_PROPERTY) && "NONE".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n\t\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("NONE").atAll());\n\t\t\t}\n\t\t\telse if (!resolver.containsProperty(REPLACE_PROPERTY) || "ANY".equals(resolver.getProperty(REPLACE_PROPERTY))) {\n\t\t\t\treturn ConditionOutcome.match(message.found("ANY").atAll());\n\t\t\t}\n\t\t\treturn ConditionOutcome.noMatch(message.didNotFind("spring.test.database.replace").atAll());\n\t\t}\n\n\t}\n\n\t@Order(Ordered.LOWEST_PRECEDENCE)\n\tprivate static class EmbeddedDataSourceBeanFactoryPostProcessor\n\t\t\timplements BeanDefinitionRegistryPostProcessor {\n\n\t\tprivate static final Log logger = LogFactory\n\t\t\t\t.getLog(EmbeddedDataSourceBeanFactoryPostProcessor.class);\n\n\t\t@Override\n\t\tpublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)\n\t\t\t\tthrows BeansException {\n\t\t\tAssert.isInstanceOf(ConfigurableListableBeanFactory.class, registry,\n\t\t\t\t\t"Test Database Auto-configuration can only be "\n\t\t\t\t\t\t\t+ "used with a ConfigurableListableBeanFactory");\n\t\t\tprocess(registry, (ConfigurableListableBeanFactory) registry);\n\t\t}\n\n\t\t@Override\n\t\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n\t\t\t\tthrows BeansException {\n\t\t}\n\n\t\tprivate void process(BeanDefinitionRegistry registry,\n\t\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\t\tBeanDefinitionHolder holder = getDataSourceBeanDefinition(beanFactory);\n\t\t\tif (holder != null) {\n\t\t\t\tString beanName = holder.getBeanName();\n\t\t\t\tboolean primary = holder.getBeanDefinition().isPrimary();\n\t\t\t\tlogger.info("Replacing \'" + beanName + "\' DataSource bean with "\n\t\t\t\t\t\t+ (primary ? "primary " : "") + "embedded version");\n\t\t\t\tregistry.registerBeanDefinition(beanName,\n\t\t\t\t\t\tcreateEmbeddedBeanDefinition(primary));\n\t\t\t}\n\t\t}\n\n\t\tprivate BeanDefinition createEmbeddedBeanDefinition(boolean primary) {\n\t\t\tBeanDefinition beanDefinition = new RootBeanDefinition(\n\t\t\t\t\tEmbeddedDataSourceFactoryBean.class);\n\t\t\tbeanDefinition.setPrimary(primary);\n\t\t\treturn beanDefinition;\n\t\t}\n\n\t\tprivate BeanDefinitionHolder getDataSourceBeanDefinition(\n\t\t\t\tConfigurableListableBeanFactory beanFactory) {\n\t\t\tString[] beanNames = beanFactory.getBeanNamesForType(DataSource.class);\n\t\t\tif (ObjectUtils.isEmpty(beanNames)) {\n\t\t\t\tlogger.warn("No DataSource beans found, "\n\t\t\t\t\t\t+ "embedded version will not be used");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (beanNames.length == 1) {\n\t\t\t\tString beanName = beanNames[0];\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName);\n\t\t\t}\n\t\t\tfor (String beanName : beanNames) {\n\t\t\t\tBeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);\n\t\t\t\tif (beanDefinition.isPrimary()) {\n\t\t\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.warn("No primary DataSource found, "\n\t\t\t\t\t+ "embedded version will not be used");\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\tprivate static class EmbeddedDataSourceFactoryBean\n\t\t\timplements FactoryBean<DataSource>, EnvironmentAware, InitializingBean {\n\n\t\tprivate EmbeddedDataSourceFactory factory;\n\n\t\tprivate EmbeddedDatabase embeddedDatabase;\n\n\t\t@Override\n\t\tpublic void setEnvironment(Environment environment) {\n\t\t\tthis.factory = new EmbeddedDataSourceFactory(environment);\n\t\t}\n\n\t\t@Override\n\t\tpublic void afterPropertiesSet() throws Exception {\n\t\t\tthis.embeddedDatabase = this.factory.getEmbeddedDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic DataSource getObject() throws Exception {\n\t\t\treturn this.embeddedDatabase;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getObjectType() {\n\t\t\treturn EmbeddedDatabase.class;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isSingleton() {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tprivate static class EmbeddedDataSourceFactory {\n\n\t\tprivate final Environment environment;\n\n\t\tEmbeddedDataSourceFactory(Environment environment) {\n\t\t\tthis.environment = environment;\n\t\t}\n\n\t\tpublic EmbeddedDatabase getEmbeddedDatabase() {\n\t\t\tEmbeddedDatabaseConnection connection = this.environment.getProperty(\n\t\t\t\t\t"spring.test.database.connection", EmbeddedDatabaseConnection.class,\n\t\t\t\t\tEmbeddedDatabaseConnection.NONE);\n\t\t\tif (EmbeddedDatabaseConnection.NONE.equals(connection)) {\n\t\t\t\tconnection = EmbeddedDatabaseConnection.get(getClass().getClassLoader());\n\t\t\t}\n\t\t\tAssert.state(connection != EmbeddedDatabaseConnection.NONE,\n\t\t\t\t\t"Cannot determine embedded database for tests. If you want "\n\t\t\t\t\t\t\t+ "an embedded database please put a supported one "\n\t\t\t\t\t\t\t+ "on the classpath.");\n\t\t\treturn new EmbeddedDatabaseBuilder().generateUniqueName(true)\n\t\t\t\t\t.setType(connection.getType()).build();\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
