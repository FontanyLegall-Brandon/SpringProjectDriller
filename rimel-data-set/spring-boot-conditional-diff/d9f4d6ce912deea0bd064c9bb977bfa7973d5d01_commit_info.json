{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/cache/CacheAutoConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -38,7 +38,6 @@ import org.springframework.boot.context.properties.EnableConfigurationProperties\n import org.springframework.cache.CacheManager;\n import org.springframework.cache.annotation.EnableCaching;\n import org.springframework.cache.interceptor.CacheAspectSupport;\n-import org.springframework.cache.interceptor.CacheResolver;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.annotation.Import;\n@@ -62,7 +61,7 @@ import org.springframework.util.Assert;\n @Configuration\n @ConditionalOnClass(CacheManager.class)\n @ConditionalOnBean(CacheAspectSupport.class)\n-@ConditionalOnMissingBean({ CacheManager.class, CacheResolver.class })\n+@ConditionalOnMissingBean(value = CacheManager.class, name = "cacheResolver")\n @EnableConfigurationProperties(CacheProperties.class)\n @AutoConfigureBefore(HibernateJpaAutoConfiguration.class)\n @AutoConfigureAfter({ HazelcastAutoConfiguration.class, RedisAutoConfiguration.class })\n', 'source_code': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.cache;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration.CacheConfigurationImportSelector;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.jpa.EntityManagerFactoryDependsOnPostProcessor;\nimport org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;\nimport org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.cache.interceptor.CacheAspectSupport;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.ImportSelector;\nimport org.springframework.context.annotation.Role;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.orm.jpa.AbstractEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.util.Assert;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for the cache abstraction. Creates a\n * {@link CacheManager} if necessary when caching is enabled via {@link EnableCaching}.\n * <p>\n * Cache store can be auto-detected or specified explicitly via configuration.\n *\n * @author Stephane Nicoll\n * @since 1.3.0\n * @see EnableCaching\n */\n@Configuration\n@ConditionalOnClass(CacheManager.class)\n@ConditionalOnBean(CacheAspectSupport.class)\n@ConditionalOnMissingBean(value = CacheManager.class, name = "cacheResolver")\n@EnableConfigurationProperties(CacheProperties.class)\n@AutoConfigureBefore(HibernateJpaAutoConfiguration.class)\n@AutoConfigureAfter({ HazelcastAutoConfiguration.class, RedisAutoConfiguration.class })\n@Import({ CacheManagerCustomizers.class, CacheConfigurationImportSelector.class })\npublic class CacheAutoConfiguration {\n\n\tstatic final String VALIDATOR_BEAN_NAME = "cacheAutoConfigurationValidator";\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic static CacheManagerValidatorPostProcessor cacheAutoConfigurationValidatorPostProcessor() {\n\t\treturn new CacheManagerValidatorPostProcessor();\n\t}\n\n\t@Bean(name = VALIDATOR_BEAN_NAME)\n\tpublic CacheManagerValidator cacheAutoConfigurationValidator() {\n\t\treturn new CacheManagerValidator();\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)\n\t@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)\n\tprotected static class CacheManagerJpaDependencyConfiguration\n\t\t\textends EntityManagerFactoryDependsOnPostProcessor {\n\n\t\tpublic CacheManagerJpaDependencyConfiguration() {\n\t\t\tsuper("cacheManager");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link BeanFactoryPostProcessor} to ensure that the {@link CacheManagerValidator}\n\t * is triggered before {@link CacheAspectSupport} but without causing early\n\t * instantiation.\n\t */\n\tstatic class CacheManagerValidatorPostProcessor implements BeanFactoryPostProcessor {\n\t\t@Override\n\t\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n\t\t\t\tthrows BeansException {\n\t\t\tfor (String name : beanFactory.getBeanNamesForType(CacheAspectSupport.class,\n\t\t\t\t\tfalse, false)) {\n\t\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(name);\n\t\t\t\tdefinition.setDependsOn(\n\t\t\t\t\t\tappend(definition.getDependsOn(), VALIDATOR_BEAN_NAME));\n\t\t\t}\n\t\t}\n\n\t\tprivate String[] append(String[] array, String value) {\n\t\t\tString[] result = new String[array == null ? 1 : array.length + 1];\n\t\t\tif (array != null) {\n\t\t\t\tSystem.arraycopy(array, 0, result, 0, array.length);\n\t\t\t}\n\t\t\tresult[result.length - 1] = value;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Bean used to validate that a CacheManager exists and provide a more meaningful\n\t * exception.\n\t */\n\tstatic class CacheManagerValidator {\n\n\t\t@Autowired\n\t\tprivate CacheProperties cacheProperties;\n\n\t\t@Autowired(required = false)\n\t\tprivate CacheManager cacheManager;\n\n\t\t@PostConstruct\n\t\tpublic void checkHasCacheManager() {\n\t\t\tAssert.notNull(this.cacheManager,\n\t\t\t\t\t"No cache manager could "\n\t\t\t\t\t\t\t+ "be auto-configured, check your configuration (caching "\n\t\t\t\t\t\t\t+ "type is \'" + this.cacheProperties.getType() + "\')");\n\t\t}\n\t}\n\n\t/**\n\t * {@link ImportSelector} to add {@link CacheType} configuration classes.\n\t */\n\tstatic class CacheConfigurationImportSelector implements ImportSelector {\n\n\t\t@Override\n\t\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\t\tCacheType[] types = CacheType.values();\n\t\t\tString[] imports = new String[types.length];\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\timports[i] = CacheConfigurations.getConfigurationClass(types[i]);\n\t\t\t}\n\t\t\treturn imports;\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.cache;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.boot.autoconfigure.AutoConfigureBefore;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration.CacheConfigurationImportSelector;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.data.jpa.EntityManagerFactoryDependsOnPostProcessor;\nimport org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;\nimport org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration;\nimport org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.cache.interceptor.CacheAspectSupport;\nimport org.springframework.cache.interceptor.CacheResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.ImportSelector;\nimport org.springframework.context.annotation.Role;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.orm.jpa.AbstractEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.util.Assert;\n\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for the cache abstraction. Creates a\n * {@link CacheManager} if necessary when caching is enabled via {@link EnableCaching}.\n * <p>\n * Cache store can be auto-detected or specified explicitly via configuration.\n *\n * @author Stephane Nicoll\n * @since 1.3.0\n * @see EnableCaching\n */\n@Configuration\n@ConditionalOnClass(CacheManager.class)\n@ConditionalOnBean(CacheAspectSupport.class)\n@ConditionalOnMissingBean({ CacheManager.class, CacheResolver.class })\n@EnableConfigurationProperties(CacheProperties.class)\n@AutoConfigureBefore(HibernateJpaAutoConfiguration.class)\n@AutoConfigureAfter({ HazelcastAutoConfiguration.class, RedisAutoConfiguration.class })\n@Import({ CacheManagerCustomizers.class, CacheConfigurationImportSelector.class })\npublic class CacheAutoConfiguration {\n\n\tstatic final String VALIDATOR_BEAN_NAME = "cacheAutoConfigurationValidator";\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic static CacheManagerValidatorPostProcessor cacheAutoConfigurationValidatorPostProcessor() {\n\t\treturn new CacheManagerValidatorPostProcessor();\n\t}\n\n\t@Bean(name = VALIDATOR_BEAN_NAME)\n\tpublic CacheManagerValidator cacheAutoConfigurationValidator() {\n\t\treturn new CacheManagerValidator();\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)\n\t@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)\n\tprotected static class CacheManagerJpaDependencyConfiguration\n\t\t\textends EntityManagerFactoryDependsOnPostProcessor {\n\n\t\tpublic CacheManagerJpaDependencyConfiguration() {\n\t\t\tsuper("cacheManager");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link BeanFactoryPostProcessor} to ensure that the {@link CacheManagerValidator}\n\t * is triggered before {@link CacheAspectSupport} but without causing early\n\t * instantiation.\n\t */\n\tstatic class CacheManagerValidatorPostProcessor implements BeanFactoryPostProcessor {\n\t\t@Override\n\t\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n\t\t\t\tthrows BeansException {\n\t\t\tfor (String name : beanFactory.getBeanNamesForType(CacheAspectSupport.class,\n\t\t\t\t\tfalse, false)) {\n\t\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(name);\n\t\t\t\tdefinition.setDependsOn(\n\t\t\t\t\t\tappend(definition.getDependsOn(), VALIDATOR_BEAN_NAME));\n\t\t\t}\n\t\t}\n\n\t\tprivate String[] append(String[] array, String value) {\n\t\t\tString[] result = new String[array == null ? 1 : array.length + 1];\n\t\t\tif (array != null) {\n\t\t\t\tSystem.arraycopy(array, 0, result, 0, array.length);\n\t\t\t}\n\t\t\tresult[result.length - 1] = value;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Bean used to validate that a CacheManager exists and provide a more meaningful\n\t * exception.\n\t */\n\tstatic class CacheManagerValidator {\n\n\t\t@Autowired\n\t\tprivate CacheProperties cacheProperties;\n\n\t\t@Autowired(required = false)\n\t\tprivate CacheManager cacheManager;\n\n\t\t@PostConstruct\n\t\tpublic void checkHasCacheManager() {\n\t\t\tAssert.notNull(this.cacheManager,\n\t\t\t\t\t"No cache manager could "\n\t\t\t\t\t\t\t+ "be auto-configured, check your configuration (caching "\n\t\t\t\t\t\t\t+ "type is \'" + this.cacheProperties.getType() + "\')");\n\t\t}\n\t}\n\n\t/**\n\t * {@link ImportSelector} to add {@link CacheType} configuration classes.\n\t */\n\tstatic class CacheConfigurationImportSelector implements ImportSelector {\n\n\t\t@Override\n\t\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\t\tCacheType[] types = CacheType.values();\n\t\t\tString[] imports = new String[types.length];\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\timports[i] = CacheConfigurations.getConfigurationClass(types[i]);\n\t\t\t}\n\t\t\treturn imports;\n\t\t}\n\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
