{'_old_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/AuthenticationManagerConfiguration.java'), '_new_path': PosixPath('spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/AuthenticationManagerConfiguration.java'), 'change_type': <ModificationType.MODIFY: 5>, 'diff': '@@ -32,7 +32,6 @@ import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n import org.springframework.context.annotation.Primary;\n import org.springframework.context.event.ContextRefreshedEvent;\n-import org.springframework.core.Ordered;\n import org.springframework.core.annotation.Order;\n import org.springframework.security.authentication.AuthenticationEventPublisher;\n import org.springframework.security.authentication.AuthenticationManager;\n@@ -42,6 +41,8 @@ import org.springframework.security.config.annotation.ObjectPostProcessor;\n import org.springframework.security.config.annotation.SecurityConfigurer;\n import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\n import org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.AuthenticationException;\n import org.springframework.stereotype.Component;\n \n /**\n@@ -57,8 +58,8 @@ import org.springframework.stereotype.Component;\n  */\n @Configuration\n @ConditionalOnBean(ObjectPostProcessor.class)\n-@ConditionalOnMissingBean(AuthenticationManager.class)\n-@Order(Ordered.LOWEST_PRECEDENCE - 3)\n+@ConditionalOnMissingBean({ AuthenticationManager.class })\n+@Order(0)\n public class AuthenticationManagerConfiguration extends\n \t\tGlobalAuthenticationConfigurerAdapter {\n \n@@ -84,18 +85,27 @@ public class AuthenticationManagerConfiguration extends\n \n \t@Bean\n \t@Primary\n-\tpublic AuthenticationManager authenticationManager(AuthenticationManagerBuilder auth)\n-\t\t\tthrows Exception {\n+\tpublic AuthenticationManager authenticationManager(AuthenticationManagerBuilder auth,\n+\t\t\tApplicationContext context) throws Exception {\n+\n+\t\tif (isAuthenticationManagerAlreadyConfigured(context)) {\n+\t\t\treturn new LazyAuthenticationManager(auth);\n+\t\t}\n+\n \t\t/*\n \t\t * This AuthenticationManagerBuilder is for the global AuthenticationManager\n \t\t */\n \t\tBootDefaultingAuthenticationConfigurerAdapter configurer = new BootDefaultingAuthenticationConfigurerAdapter();\n-\t\tconfigurer.init(auth);\n \t\tconfigurer.configure(auth);\n \t\tAuthenticationManager manager = configurer.getAuthenticationManagerBuilder()\n \t\t\t\t.getOrBuild();\n \t\tconfigurer.configureParent(auth);\n \t\treturn manager;\n+\n+\t}\n+\n+\tprivate boolean isAuthenticationManagerAlreadyConfigured(ApplicationContext context) {\n+\t\treturn context.getBeanNamesForType(GlobalAuthenticationConfigurerAdapter.class).length > 2;\n \t}\n \n \t@Component\n@@ -142,8 +152,7 @@ public class AuthenticationManagerConfiguration extends\n \t * methods are invoked before configure, which cannot be guaranteed at this point.</li>\n \t * </ul>\n \t */\n-\tprivate class BootDefaultingAuthenticationConfigurerAdapter extends\n-\t\t\tGlobalAuthenticationConfigurerAdapter {\n+\tprivate class BootDefaultingAuthenticationConfigurerAdapter {\n \n \t\tprivate AuthenticationManagerBuilder defaultAuth;\n \n@@ -159,7 +168,6 @@ public class AuthenticationManagerConfiguration extends\n \t\t\treturn this.defaultAuth;\n \t\t}\n \n-\t\t@Override\n \t\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n \t\t\tif (auth.isConfigured()) {\n \t\t\t\tthis.defaultAuth = auth;\n@@ -188,4 +196,20 @@ public class AuthenticationManagerConfiguration extends\n \t\t}\n \t}\n \n+\tprivate static class LazyAuthenticationManager implements AuthenticationManager {\n+\n+\t\tprivate AuthenticationManagerBuilder builder;\n+\n+\t\tpublic LazyAuthenticationManager(AuthenticationManagerBuilder builder) {\n+\t\t\tthis.builder = builder;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Authentication authenticate(Authentication authentication)\n+\t\t\t\tthrows AuthenticationException {\n+\t\t\treturn builder.getOrBuild().authenticate(authentication);\n+\t\t}\n+\n+\t}\n+\n }\n', 'source_code': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security;\n\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.ObjectPostProcessor;\nimport org.springframework.security.config.annotation.SecurityConfigurer;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.stereotype.Component;\n\n/**\n * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be\n * disabled by providing a bean of type AuthenticationManager. The value provided by this\n * configuration will become the "global" authentication manager (from Spring Security),\n * or the parent of the global instance. Thus it acts as a fallback when no others are\n * provided, is used by method security if enabled, and as a parent authentication manager\n * for "local" authentication managers in individual filter chains.\n *\n * @author Dave Syer\n * @author Rob Winch\n */\n@Configuration\n@ConditionalOnBean(ObjectPostProcessor.class)\n@ConditionalOnMissingBean({ AuthenticationManager.class })\n@Order(0)\npublic class AuthenticationManagerConfiguration extends\n\t\tGlobalAuthenticationConfigurerAdapter {\n\n\t/*\n\t * Yes, this class is a GlobalAuthenticationConfigurerAdapter, even though none of\n\t * those methods are overridden: we want Spring Security to instantiate us early, so\n\t * we can in turn force the SecurityPrequisites to be instantiated. This will prevent\n\t * ordering issues between Spring Boot modules when they need to influence the default\n\t * security configuration.\n\t */\n\n\tprivate static Log logger = LogFactory\n\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t@Autowired\n\tprivate List<SecurityPrequisite> dependencies;\n\n\t@Autowired\n\tprivate SecurityProperties security;\n\n\t@Autowired\n\tprivate ObjectPostProcessor<Object> objectPostProcessor;\n\n\t@Bean\n\t@Primary\n\tpublic AuthenticationManager authenticationManager(AuthenticationManagerBuilder auth,\n\t\t\tApplicationContext context) throws Exception {\n\n\t\tif (isAuthenticationManagerAlreadyConfigured(context)) {\n\t\t\treturn new LazyAuthenticationManager(auth);\n\t\t}\n\n\t\t/*\n\t\t * This AuthenticationManagerBuilder is for the global AuthenticationManager\n\t\t */\n\t\tBootDefaultingAuthenticationConfigurerAdapter configurer = new BootDefaultingAuthenticationConfigurerAdapter();\n\t\tconfigurer.configure(auth);\n\t\tAuthenticationManager manager = configurer.getAuthenticationManagerBuilder()\n\t\t\t\t.getOrBuild();\n\t\tconfigurer.configureParent(auth);\n\t\treturn manager;\n\n\t}\n\n\tprivate boolean isAuthenticationManagerAlreadyConfigured(ApplicationContext context) {\n\t\treturn context.getBeanNamesForType(GlobalAuthenticationConfigurerAdapter.class).length > 2;\n\t}\n\n\t@Component\n\tprotected static class AuthenticationManagerConfigurationListener implements\n\t\t\tApplicationListener<ContextRefreshedEvent> {\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher authenticationEventPublisher;\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\t\tApplicationContext context = event.getApplicationContext();\n\t\t\tif (context.getBeanNamesForType(AuthenticationManager.class).length == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAuthenticationManager manager = context.getBean(AuthenticationManager.class);\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * We must add {@link BootDefaultingAuthenticationConfigurerAdapter} in the init phase\n\t * of the last {@link GlobalAuthenticationConfigurerAdapter}. The reason is that the\n\t * typical flow is something like:\n\t *\n\t * <ul>\n\t * <li>A\n\t * {@link GlobalAuthenticationConfigurerAdapter#init(AuthenticationManagerBuilder)}\n\t * exists that adds a {@link SecurityConfigurer} to the\n\t * {@link AuthenticationManagerBuilder}</li>\n\t * <li>\n\t * {@link AuthenticationManagerConfiguration#init(AuthenticationManagerBuilder)} adds\n\t * BootDefaultingAuthenticationConfigurerAdapter so it is after the\n\t * {@link SecurityConfigurer} in the first step</li>\n\t * <li>We then can default an {@link AuthenticationProvider} if necessary. Note we can\n\t * only invoke the\n\t * {@link AuthenticationManagerBuilder#authenticationProvider(AuthenticationProvider)}\n\t * method since all other methods add a {@link SecurityConfigurer} which is not\n\t * allowed in the configure stage. It is not allowed because we guarantee all init\n\t * methods are invoked before configure, which cannot be guaranteed at this point.</li>\n\t * </ul>\n\t */\n\tprivate class BootDefaultingAuthenticationConfigurerAdapter {\n\n\t\tprivate AuthenticationManagerBuilder defaultAuth;\n\n\t\tprivate AuthenticationManager parent;\n\n\t\tpublic void configureParent(AuthenticationManagerBuilder auth) {\n\t\t\tif (!auth.isConfigured() && this.parent != null) {\n\t\t\t\tauth.parentAuthenticationManager(this.parent);\n\t\t\t}\n\t\t}\n\n\t\tpublic AuthenticationManagerBuilder getAuthenticationManagerBuilder() {\n\t\t\treturn this.defaultAuth;\n\t\t}\n\n\t\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n\t\t\tif (auth.isConfigured()) {\n\t\t\t\tthis.defaultAuth = auth;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tUser user = AuthenticationManagerConfiguration.this.security.getUser();\n\t\t\tif (user.isDefaultPassword()) {\n\t\t\t\tlogger.info("\\n\\nUsing default security password: " + user.getPassword()\n\t\t\t\t\t\t+ "\\n\\n");\n\t\t\t}\n\n\t\t\tthis.defaultAuth = new AuthenticationManagerBuilder(\n\t\t\t\t\tAuthenticationManagerConfiguration.this.objectPostProcessor);\n\n\t\t\tSet<String> roles = new LinkedHashSet<String>(user.getRole());\n\n\t\t\tthis.parent = this.defaultAuth.inMemoryAuthentication()\n\t\t\t\t\t.withUser(user.getName()).password(user.getPassword())\n\t\t\t\t\t.roles(roles.toArray(new String[roles.size()])).and().and().build();\n\n\t\t\t// Defer actually setting the parent on the AuthenticationManagerBuilder\n\t\t\t// because it makes it "configured" and we are only in the init() phase\n\t\t\t// here.\n\n\t\t}\n\t}\n\n\tprivate static class LazyAuthenticationManager implements AuthenticationManager {\n\n\t\tprivate AuthenticationManagerBuilder builder;\n\n\t\tpublic LazyAuthenticationManager(AuthenticationManagerBuilder builder) {\n\t\t\tthis.builder = builder;\n\t\t}\n\n\t\t@Override\n\t\tpublic Authentication authenticate(Authentication authentication)\n\t\t\t\tthrows AuthenticationException {\n\t\t\treturn builder.getOrBuild().authenticate(authentication);\n\t\t}\n\n\t}\n\n}\n', 'source_code_before': '/*\n * Copyright 2012-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.autoconfigure.security;\n\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.event.ContextRefreshedEvent;\nimport org.springframework.core.Ordered;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.AuthenticationProvider;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.config.annotation.ObjectPostProcessor;\nimport org.springframework.security.config.annotation.SecurityConfigurer;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.stereotype.Component;\n\n/**\n * Configuration for a Spring Security in-memory {@link AuthenticationManager}. Can be\n * disabled by providing a bean of type AuthenticationManager. The value provided by this\n * configuration will become the "global" authentication manager (from Spring Security),\n * or the parent of the global instance. Thus it acts as a fallback when no others are\n * provided, is used by method security if enabled, and as a parent authentication manager\n * for "local" authentication managers in individual filter chains.\n *\n * @author Dave Syer\n * @author Rob Winch\n */\n@Configuration\n@ConditionalOnBean(ObjectPostProcessor.class)\n@ConditionalOnMissingBean(AuthenticationManager.class)\n@Order(Ordered.LOWEST_PRECEDENCE - 3)\npublic class AuthenticationManagerConfiguration extends\n\t\tGlobalAuthenticationConfigurerAdapter {\n\n\t/*\n\t * Yes, this class is a GlobalAuthenticationConfigurerAdapter, even though none of\n\t * those methods are overridden: we want Spring Security to instantiate us early, so\n\t * we can in turn force the SecurityPrequisites to be instantiated. This will prevent\n\t * ordering issues between Spring Boot modules when they need to influence the default\n\t * security configuration.\n\t */\n\n\tprivate static Log logger = LogFactory\n\t\t\t.getLog(AuthenticationManagerConfiguration.class);\n\n\t@Autowired\n\tprivate List<SecurityPrequisite> dependencies;\n\n\t@Autowired\n\tprivate SecurityProperties security;\n\n\t@Autowired\n\tprivate ObjectPostProcessor<Object> objectPostProcessor;\n\n\t@Bean\n\t@Primary\n\tpublic AuthenticationManager authenticationManager(AuthenticationManagerBuilder auth)\n\t\t\tthrows Exception {\n\t\t/*\n\t\t * This AuthenticationManagerBuilder is for the global AuthenticationManager\n\t\t */\n\t\tBootDefaultingAuthenticationConfigurerAdapter configurer = new BootDefaultingAuthenticationConfigurerAdapter();\n\t\tconfigurer.init(auth);\n\t\tconfigurer.configure(auth);\n\t\tAuthenticationManager manager = configurer.getAuthenticationManagerBuilder()\n\t\t\t\t.getOrBuild();\n\t\tconfigurer.configureParent(auth);\n\t\treturn manager;\n\t}\n\n\t@Component\n\tprotected static class AuthenticationManagerConfigurationListener implements\n\t\t\tApplicationListener<ContextRefreshedEvent> {\n\n\t\t@Autowired\n\t\tprivate AuthenticationEventPublisher authenticationEventPublisher;\n\n\t\t@Override\n\t\tpublic void onApplicationEvent(ContextRefreshedEvent event) {\n\t\t\tApplicationContext context = event.getApplicationContext();\n\t\t\tif (context.getBeanNamesForType(AuthenticationManager.class).length == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAuthenticationManager manager = context.getBean(AuthenticationManager.class);\n\t\t\tif (manager instanceof ProviderManager) {\n\t\t\t\t((ProviderManager) manager)\n\t\t\t\t\t\t.setAuthenticationEventPublisher(this.authenticationEventPublisher);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * We must add {@link BootDefaultingAuthenticationConfigurerAdapter} in the init phase\n\t * of the last {@link GlobalAuthenticationConfigurerAdapter}. The reason is that the\n\t * typical flow is something like:\n\t *\n\t * <ul>\n\t * <li>A\n\t * {@link GlobalAuthenticationConfigurerAdapter#init(AuthenticationManagerBuilder)}\n\t * exists that adds a {@link SecurityConfigurer} to the\n\t * {@link AuthenticationManagerBuilder}</li>\n\t * <li>\n\t * {@link AuthenticationManagerConfiguration#init(AuthenticationManagerBuilder)} adds\n\t * BootDefaultingAuthenticationConfigurerAdapter so it is after the\n\t * {@link SecurityConfigurer} in the first step</li>\n\t * <li>We then can default an {@link AuthenticationProvider} if necessary. Note we can\n\t * only invoke the\n\t * {@link AuthenticationManagerBuilder#authenticationProvider(AuthenticationProvider)}\n\t * method since all other methods add a {@link SecurityConfigurer} which is not\n\t * allowed in the configure stage. It is not allowed because we guarantee all init\n\t * methods are invoked before configure, which cannot be guaranteed at this point.</li>\n\t * </ul>\n\t */\n\tprivate class BootDefaultingAuthenticationConfigurerAdapter extends\n\t\t\tGlobalAuthenticationConfigurerAdapter {\n\n\t\tprivate AuthenticationManagerBuilder defaultAuth;\n\n\t\tprivate AuthenticationManager parent;\n\n\t\tpublic void configureParent(AuthenticationManagerBuilder auth) {\n\t\t\tif (!auth.isConfigured() && this.parent != null) {\n\t\t\t\tauth.parentAuthenticationManager(this.parent);\n\t\t\t}\n\t\t}\n\n\t\tpublic AuthenticationManagerBuilder getAuthenticationManagerBuilder() {\n\t\t\treturn this.defaultAuth;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(AuthenticationManagerBuilder auth) throws Exception {\n\t\t\tif (auth.isConfigured()) {\n\t\t\t\tthis.defaultAuth = auth;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tUser user = AuthenticationManagerConfiguration.this.security.getUser();\n\t\t\tif (user.isDefaultPassword()) {\n\t\t\t\tlogger.info("\\n\\nUsing default security password: " + user.getPassword()\n\t\t\t\t\t\t+ "\\n\\n");\n\t\t\t}\n\n\t\t\tthis.defaultAuth = new AuthenticationManagerBuilder(\n\t\t\t\t\tAuthenticationManagerConfiguration.this.objectPostProcessor);\n\n\t\t\tSet<String> roles = new LinkedHashSet<String>(user.getRole());\n\n\t\t\tthis.parent = this.defaultAuth.inMemoryAuthentication()\n\t\t\t\t\t.withUser(user.getName()).password(user.getPassword())\n\t\t\t\t\t.roles(roles.toArray(new String[roles.size()])).and().and().build();\n\n\t\t\t// Defer actually setting the parent on the AuthenticationManagerBuilder\n\t\t\t// because it makes it "configured" and we are only in the init() phase\n\t\t\t// here.\n\n\t\t}\n\t}\n\n}\n', '_nloc': None, '_complexity': None, '_token_count': None, '_function_list': []}
